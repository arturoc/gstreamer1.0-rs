/* automatically generated by rust-bindgen */
#![allow(raw_pointer_derive,non_camel_case_types,non_snake_case,non_upper_case_globals,missing_copy_implementations)]
pub use self::GstState::*;

pub type __builtin_va_list = ::libc::c_void;
pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
pub type gint8 = ::libc::c_char;
pub type guint8 = ::libc::c_uchar;
pub type gint16 = ::libc::c_short;
pub type guint16 = ::libc::c_ushort;
pub type gint32 = ::libc::c_int;
pub type guint32 = ::libc::c_uint;
pub type gint64 = ::libc::c_longlong;
pub type guint64 = ::libc::c_ulonglong;
pub type gssize = ::libc::c_longlong;
pub type gsize = ::libc::c_ulonglong;
pub type goffset = gint64;
pub type gintptr = ::libc::c_long;
pub type guintptr = ::libc::c_ulong;
pub type GPid = ::libc::c_int;
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulonglong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_longlong;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub __val: [::libc::c_int; 2u],
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Struct_Unnamed1 { unsafe { ::std::mem::zeroed() } }
}
pub type __fsid_t = Struct_Unnamed1;
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Struct_timespec { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
    pub tm_gmtoff: ::libc::c_long,
    pub tm_zone: *const ::libc::c_char,
}
impl ::std::default::Default for Struct_tm {
    fn default() -> Struct_tm { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_itimerspec {
    pub it_interval: Struct_timespec,
    pub it_value: Struct_timespec,
}
impl ::std::default::Default for Struct_itimerspec {
    fn default() -> Struct_itimerspec { unsafe { ::std::mem::zeroed() } }
}
pub type pid_t = __pid_t;
pub enum Struct___locale_data { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct___locale_struct {
    pub __locales: [*mut Struct___locale_data; 13u],
    pub __ctype_b: *const ::libc::c_ushort,
    pub __ctype_tolower: *const ::libc::c_int,
    pub __ctype_toupper: *const ::libc::c_int,
    pub __names: [*const ::libc::c_char; 13u],
}
impl ::std::default::Default for Struct___locale_struct {
    fn default() -> Struct___locale_struct { unsafe { ::std::mem::zeroed() } }
}
pub type __locale_t = *mut Struct___locale_struct;
pub type locale_t = __locale_t;
pub type gchar = ::libc::c_char;
pub type gshort = ::libc::c_short;
pub type glong = ::libc::c_long;
pub type gint = ::libc::c_int;
pub type gboolean = gint;
pub type guchar = ::libc::c_uchar;
pub type gushort = ::libc::c_ushort;
pub type gulong = ::libc::c_ulong;
pub type guint = ::libc::c_uint;
pub type gfloat = ::libc::c_float;
pub type gdouble = ::libc::c_double;
pub type gpointer = *mut ::libc::c_void;
pub type gconstpointer = *const ::libc::c_void;
pub type GCompareFunc =
    ::std::option::Option<extern "C" fn(a: gconstpointer, b: gconstpointer)
                              -> gint>;
pub type GCompareDataFunc =
    ::std::option::Option<extern "C" fn
                              (a: gconstpointer, b: gconstpointer,
                               user_data: gpointer) -> gint>;
pub type GEqualFunc =
    ::std::option::Option<extern "C" fn(a: gconstpointer, b: gconstpointer)
                              -> gboolean>;
pub type GDestroyNotify =
    ::std::option::Option<extern "C" fn(data: gpointer)>;
pub type GFunc =
    ::std::option::Option<extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc =
    ::std::option::Option<extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc =
    ::std::option::Option<extern "C" fn
                              (key: gpointer, value: gpointer,
                               user_data: gpointer)>;
pub type GFreeFunc = ::std::option::Option<extern "C" fn(data: gpointer)>;
pub type GTranslateFunc =
    ::std::option::Option<extern "C" fn(str: *const gchar, data: gpointer)
                              -> *const gchar>;
pub type GDoubleIEEE754 = Union__GDoubleIEEE754;
pub type GFloatIEEE754 = Union__GFloatIEEE754;
#[repr(C)]
#[derive(Copy)]
pub struct Union__GFloatIEEE754 {
    pub _bindgen_data_: [u32; 1u],
}
impl Union__GFloatIEEE754 {
    pub unsafe fn v_float(&mut self) -> *mut gfloat {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn mpn(&mut self) -> *mut Struct_Unnamed2 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union__GFloatIEEE754 {
    fn default() -> Union__GFloatIEEE754 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Struct_Unnamed2 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union__GDoubleIEEE754 {
    pub _bindgen_data_: [u64; 1u],
}
impl Union__GDoubleIEEE754 {
    pub unsafe fn v_double(&mut self) -> *mut gdouble {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn mpn(&mut self) -> *mut Struct_Unnamed3 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union__GDoubleIEEE754 {
    fn default() -> Union__GDoubleIEEE754 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Struct_Unnamed3 { unsafe { ::std::mem::zeroed() } }
}
pub type GTimeVal = Struct__GTimeVal;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
impl ::std::default::Default for Struct__GTimeVal {
    fn default() -> Struct__GTimeVal { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GBytes { }
pub type GBytes = Struct__GBytes;
pub type GArray = Struct__GArray;
pub type GByteArray = Struct__GByteArray;
pub type GPtrArray = Struct__GPtrArray;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GArray {
    pub data: *mut gchar,
    pub len: guint,
}
impl ::std::default::Default for Struct__GArray {
    fn default() -> Struct__GArray { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
impl ::std::default::Default for Struct__GByteArray {
    fn default() -> Struct__GByteArray { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
impl ::std::default::Default for Struct__GPtrArray {
    fn default() -> Struct__GPtrArray { unsafe { ::std::mem::zeroed() } }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
pub type GError = Struct__GError;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
impl ::std::default::Default for Struct__GError {
    fn default() -> Struct__GError { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed4 = ::libc::c_uint;
pub const G_THREAD_ERROR_AGAIN: ::libc::c_uint = 0;
pub type GThreadError = Enum_Unnamed4;
pub type GThreadFunc =
    ::std::option::Option<extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = Struct__GThread;
pub type GMutex = Union__GMutex;
pub type GRecMutex = Struct__GRecMutex;
pub type GRWLock = Struct__GRWLock;
pub type GCond = Struct__GCond;
pub type GPrivate = Struct__GPrivate;
pub type GOnce = Struct__GOnce;
#[repr(C)]
#[derive(Copy)]
pub struct Union__GMutex {
    pub _bindgen_data_: [u64; 1u],
}
impl Union__GMutex {
    pub unsafe fn p(&mut self) -> *mut gpointer {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn i(&mut self) -> *mut [guint; 2u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union__GMutex {
    fn default() -> Union__GMutex { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GRWLock {
    pub p: gpointer,
    pub i: [guint; 2u],
}
impl ::std::default::Default for Struct__GRWLock {
    fn default() -> Struct__GRWLock { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCond {
    pub p: gpointer,
    pub i: [guint; 2u],
}
impl ::std::default::Default for Struct__GCond {
    fn default() -> Struct__GCond { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2u],
}
impl ::std::default::Default for Struct__GRecMutex {
    fn default() -> Struct__GRecMutex { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2u],
}
impl ::std::default::Default for Struct__GPrivate {
    fn default() -> Struct__GPrivate { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed5 = ::libc::c_uint;
pub const G_ONCE_STATUS_NOTCALLED: ::libc::c_uint = 0;
pub const G_ONCE_STATUS_PROGRESS: ::libc::c_uint = 1;
pub const G_ONCE_STATUS_READY: ::libc::c_uint = 2;
pub type GOnceStatus = Enum_Unnamed5;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
impl ::std::default::Default for Struct__GOnce {
    fn default() -> Struct__GOnce { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GAsyncQueue { }
pub type GAsyncQueue = Struct__GAsyncQueue;
pub type __sig_atomic_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub __val: [::libc::c_ulong; 16u],
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Struct_Unnamed6 { unsafe { ::std::mem::zeroed() } }
}
pub type __sigset_t = Struct_Unnamed6;
pub type sig_atomic_t = __sig_atomic_t;
pub type sigset_t = __sigset_t;
pub type uid_t = __uid_t;
#[repr(C)]
#[derive(Copy)]
pub struct Union_sigval {
    pub _bindgen_data_: [u64; 1u],
}
impl Union_sigval {
    pub unsafe fn sival_int(&mut self) -> *mut ::libc::c_int {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sival_ptr(&mut self) -> *mut *mut ::libc::c_void {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_sigval {
    fn default() -> Union_sigval { unsafe { ::std::mem::zeroed() } }
}
pub type sigval_t = Union_sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub si_signo: ::libc::c_int,
    pub si_errno: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub _sifields: Union_Unnamed8,
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Struct_Unnamed7 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed8 {
    pub _bindgen_data_: [u64; 14u],
}
impl Union_Unnamed8 {
    pub unsafe fn _pad(&mut self) -> *mut [::libc::c_int; 28u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _kill(&mut self) -> *mut Struct_Unnamed9 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _timer(&mut self) -> *mut Struct_Unnamed10 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _rt(&mut self) -> *mut Struct_Unnamed11 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _sigchld(&mut self) -> *mut Struct_Unnamed12 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _sigfault(&mut self) -> *mut Struct_Unnamed13 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _sigpoll(&mut self) -> *mut Struct_Unnamed14 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _sigsys(&mut self) -> *mut Struct_Unnamed15 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed8 {
    fn default() -> Union_Unnamed8 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Struct_Unnamed9 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed10 {
    pub si_tid: ::libc::c_int,
    pub si_overrun: ::libc::c_int,
    pub si_sigval: sigval_t,
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Struct_Unnamed10 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Struct_Unnamed11 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed12 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::libc::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Struct_Unnamed12 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub si_addr: *mut ::libc::c_void,
    pub si_addr_lsb: ::libc::c_short,
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Struct_Unnamed13 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub si_band: ::libc::c_long,
    pub si_fd: ::libc::c_int,
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Struct_Unnamed14 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed15 {
    pub _call_addr: *mut ::libc::c_void,
    pub _syscall: ::libc::c_int,
    pub _arch: ::libc::c_uint,
}
impl ::std::default::Default for Struct_Unnamed15 {
    fn default() -> Struct_Unnamed15 { unsafe { ::std::mem::zeroed() } }
}
pub type siginfo_t = Struct_Unnamed7;
pub type Enum_Unnamed16 = ::libc::c_int;
pub const SI_ASYNCNL: ::libc::c_int = -60;
pub const SI_TKILL: ::libc::c_int = -6;
pub const SI_SIGIO: ::libc::c_int = -5;
pub const SI_ASYNCIO: ::libc::c_int = -4;
pub const SI_MESGQ: ::libc::c_int = -3;
pub const SI_TIMER: ::libc::c_int = -2;
pub const SI_QUEUE: ::libc::c_int = -1;
pub const SI_USER: ::libc::c_int = 0;
pub const SI_KERNEL: ::libc::c_int = 128;
pub type Enum_Unnamed17 = ::libc::c_uint;
pub const ILL_ILLOPC: ::libc::c_uint = 1;
pub const ILL_ILLOPN: ::libc::c_uint = 2;
pub const ILL_ILLADR: ::libc::c_uint = 3;
pub const ILL_ILLTRP: ::libc::c_uint = 4;
pub const ILL_PRVOPC: ::libc::c_uint = 5;
pub const ILL_PRVREG: ::libc::c_uint = 6;
pub const ILL_COPROC: ::libc::c_uint = 7;
pub const ILL_BADSTK: ::libc::c_uint = 8;
pub type Enum_Unnamed18 = ::libc::c_uint;
pub const FPE_INTDIV: ::libc::c_uint = 1;
pub const FPE_INTOVF: ::libc::c_uint = 2;
pub const FPE_FLTDIV: ::libc::c_uint = 3;
pub const FPE_FLTOVF: ::libc::c_uint = 4;
pub const FPE_FLTUND: ::libc::c_uint = 5;
pub const FPE_FLTRES: ::libc::c_uint = 6;
pub const FPE_FLTINV: ::libc::c_uint = 7;
pub const FPE_FLTSUB: ::libc::c_uint = 8;
pub type Enum_Unnamed19 = ::libc::c_uint;
pub const SEGV_MAPERR: ::libc::c_uint = 1;
pub const SEGV_ACCERR: ::libc::c_uint = 2;
pub type Enum_Unnamed20 = ::libc::c_uint;
pub const BUS_ADRALN: ::libc::c_uint = 1;
pub const BUS_ADRERR: ::libc::c_uint = 2;
pub const BUS_OBJERR: ::libc::c_uint = 3;
pub const BUS_MCEERR_AR: ::libc::c_uint = 4;
pub const BUS_MCEERR_AO: ::libc::c_uint = 5;
pub type Enum_Unnamed21 = ::libc::c_uint;
pub const TRAP_BRKPT: ::libc::c_uint = 1;
pub const TRAP_TRACE: ::libc::c_uint = 2;
pub type Enum_Unnamed22 = ::libc::c_uint;
pub const CLD_EXITED: ::libc::c_uint = 1;
pub const CLD_KILLED: ::libc::c_uint = 2;
pub const CLD_DUMPED: ::libc::c_uint = 3;
pub const CLD_TRAPPED: ::libc::c_uint = 4;
pub const CLD_STOPPED: ::libc::c_uint = 5;
pub const CLD_CONTINUED: ::libc::c_uint = 6;
pub type Enum_Unnamed23 = ::libc::c_uint;
pub const POLL_IN: ::libc::c_uint = 1;
pub const POLL_OUT: ::libc::c_uint = 2;
pub const POLL_MSG: ::libc::c_uint = 3;
pub const POLL_ERR: ::libc::c_uint = 4;
pub const POLL_PRI: ::libc::c_uint = 5;
pub const POLL_HUP: ::libc::c_uint = 6;
pub type pthread_attr_t = Union_pthread_attr_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::libc::c_int,
    pub sigev_notify: ::libc::c_int,
    pub _sigev_un: Union_Unnamed24,
}
impl ::std::default::Default for Struct_sigevent {
    fn default() -> Struct_sigevent { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed24 {
    pub _bindgen_data_: [u64; 6u],
}
impl Union_Unnamed24 {
    pub unsafe fn _pad(&mut self) -> *mut [::libc::c_int; 12u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _tid(&mut self) -> *mut __pid_t {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn _sigev_thread(&mut self) -> *mut Struct_Unnamed25 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed24 {
    fn default() -> Union_Unnamed24 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed25 {
    pub _function: ::std::option::Option<extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
impl ::std::default::Default for Struct_Unnamed25 {
    fn default() -> Struct_Unnamed25 { unsafe { ::std::mem::zeroed() } }
}
pub type sigevent_t = Struct_sigevent;
pub type Enum_Unnamed26 = ::libc::c_uint;
pub const SIGEV_SIGNAL: ::libc::c_uint = 0;
pub const SIGEV_NONE: ::libc::c_uint = 1;
pub const SIGEV_THREAD: ::libc::c_uint = 2;
pub const SIGEV_THREAD_ID: ::libc::c_uint = 4;
pub type __sighandler_t =
    ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)>;
pub type sig_t = __sighandler_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaction {
    pub __sigaction_handler: Union_Unnamed27,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::libc::c_int,
    pub sa_restorer: ::std::option::Option<extern "C" fn()>,
}
impl ::std::default::Default for Struct_sigaction {
    fn default() -> Struct_sigaction { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed27 {
    pub _bindgen_data_: [u64; 1u],
}
impl Union_Unnamed27 {
    pub unsafe fn sa_handler(&mut self) -> *mut __sighandler_t {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sa_sigaction(&mut self)
     ->
         *mut ::std::option::Option<extern "C" fn
                                        (arg1: ::libc::c_int,
                                         arg2: *mut siginfo_t,
                                         arg3: *mut ::libc::c_void)> {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed27 {
    fn default() -> Union_Unnamed27 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigvec {
    pub sv_handler: __sighandler_t,
    pub sv_mask: ::libc::c_int,
    pub sv_flags: ::libc::c_int,
}
impl ::std::default::Default for Struct_sigvec {
    fn default() -> Struct_sigvec { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7u],
}
impl ::std::default::Default for Struct__fpx_sw_bytes {
    fn default() -> Struct__fpx_sw_bytes { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpreg {
    pub significand: [::libc::c_ushort; 4u],
    pub exponent: ::libc::c_ushort,
}
impl ::std::default::Default for Struct__fpreg {
    fn default() -> Struct__fpreg { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpxreg {
    pub significand: [::libc::c_ushort; 4u],
    pub exponent: ::libc::c_ushort,
    pub padding: [::libc::c_ushort; 3u],
}
impl ::std::default::Default for Struct__fpxreg {
    fn default() -> Struct__fpxreg { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__xmmreg {
    pub element: [__uint32_t; 4u],
}
impl ::std::default::Default for Struct__xmmreg {
    fn default() -> Struct__xmmreg { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [Struct__fpxreg; 8u],
    pub _xmm: [Struct__xmmreg; 16u],
    pub padding: [__uint32_t; 24u],
}
impl ::std::default::Default for Struct__fpstate {
    fn default() -> Struct__fpstate { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::libc::c_ushort,
    pub gs: ::libc::c_ushort,
    pub fs: ::libc::c_ushort,
    pub __pad0: ::libc::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub _bindgen_data_1_: [u64; 1u],
    pub __reserved1: [__uint64_t; 8u],
}
impl Struct_sigcontext {
    pub unsafe fn fpstate(&mut self) -> *mut *mut Struct__fpstate {
        ::std::mem::transmute(&self._bindgen_data_1_)
    }
    pub unsafe fn __fpstate_word(&mut self) -> *mut __uint64_t {
        ::std::mem::transmute(&self._bindgen_data_1_)
    }
}
impl ::std::default::Default for Struct_sigcontext {
    fn default() -> Struct_sigcontext { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2u],
    pub reserved2: [__uint64_t; 5u],
}
impl ::std::default::Default for Struct__xsave_hdr {
    fn default() -> Struct__xsave_hdr { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__ymmh_state {
    pub ymmh_space: [__uint32_t; 64u],
}
impl ::std::default::Default for Struct__ymmh_state {
    fn default() -> Struct__ymmh_state { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__xstate {
    pub fpstate: Struct__fpstate,
    pub xstate_hdr: Struct__xsave_hdr,
    pub ymmh: Struct__ymmh_state,
}
impl ::std::default::Default for Struct__xstate {
    fn default() -> Struct__xstate { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_onstack: ::libc::c_int,
}
impl ::std::default::Default for Struct_sigstack {
    fn default() -> Struct_sigstack { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed28 = ::libc::c_uint;
pub const SS_ONSTACK: ::libc::c_uint = 1;
pub const SS_DISABLE: ::libc::c_uint = 2;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: size_t,
}
impl ::std::default::Default for Struct_sigaltstack {
    fn default() -> Struct_sigaltstack { unsafe { ::std::mem::zeroed() } }
}
pub type stack_t = Struct_sigaltstack;
pub type greg_t = ::libc::c_longlong;
pub type gregset_t = [greg_t; 23u];
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_fpxreg {
    pub significand: [::libc::c_ushort; 4u],
    pub exponent: ::libc::c_ushort,
    pub padding: [::libc::c_ushort; 3u],
}
impl ::std::default::Default for Struct__libc_fpxreg {
    fn default() -> Struct__libc_fpxreg { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_xmmreg {
    pub element: [__uint32_t; 4u],
}
impl ::std::default::Default for Struct__libc_xmmreg {
    fn default() -> Struct__libc_xmmreg { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [Struct__libc_fpxreg; 8u],
    pub _xmm: [Struct__libc_xmmreg; 16u],
    pub padding: [__uint32_t; 24u],
}
impl ::std::default::Default for Struct__libc_fpstate {
    fn default() -> Struct__libc_fpstate { unsafe { ::std::mem::zeroed() } }
}
pub type fpregset_t = *mut Struct__libc_fpstate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed29 {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::libc::c_ulonglong; 8u],
}
impl ::std::default::Default for Struct_Unnamed29 {
    fn default() -> Struct_Unnamed29 { unsafe { ::std::mem::zeroed() } }
}
pub type mcontext_t = Struct_Unnamed29;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ucontext {
    pub uc_flags: ::libc::c_ulong,
    pub uc_link: *mut Struct_ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: Struct__libc_fpstate,
}
impl ::std::default::Default for Struct_ucontext {
    fn default() -> Struct_ucontext { unsafe { ::std::mem::zeroed() } }
}
pub type ucontext_t = Struct_ucontext;
pub type pthread_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Union_pthread_attr_t {
    pub _bindgen_data_: [u64; 7u],
}
impl Union_pthread_attr_t {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 56u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_pthread_attr_t {
    fn default() -> Union_pthread_attr_t { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_internal_list {
    pub __prev: *mut Struct___pthread_internal_list,
    pub __next: *mut Struct___pthread_internal_list,
}
impl ::std::default::Default for Struct___pthread_internal_list {
    fn default() -> Struct___pthread_internal_list {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = Struct___pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed30 {
    pub _bindgen_data_: [u64; 5u],
}
impl Union_Unnamed30 {
    pub unsafe fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 40u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed30 {
    fn default() -> Union_Unnamed30 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_mutex_s {
    pub __lock: ::libc::c_int,
    pub __count: ::libc::c_uint,
    pub __owner: ::libc::c_int,
    pub __nusers: ::libc::c_uint,
    pub __kind: ::libc::c_int,
    pub __spins: ::libc::c_short,
    pub __elision: ::libc::c_short,
    pub __list: __pthread_list_t,
}
impl ::std::default::Default for Struct___pthread_mutex_s {
    fn default() -> Struct___pthread_mutex_s {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_mutex_t = Union_Unnamed30;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed31 {
    pub _bindgen_data_: [u32; 1u],
}
impl Union_Unnamed31 {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 4u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_int {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed31 {
    fn default() -> Union_Unnamed31 { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_mutexattr_t = Union_Unnamed31;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed32 {
    pub _bindgen_data_: [u64; 6u],
}
impl Union_Unnamed32 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed33 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 48u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_longlong {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed32 {
    fn default() -> Union_Unnamed32 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed33 {
    pub __lock: ::libc::c_int,
    pub __futex: ::libc::c_uint,
    pub __total_seq: ::libc::c_ulonglong,
    pub __wakeup_seq: ::libc::c_ulonglong,
    pub __woken_seq: ::libc::c_ulonglong,
    pub __mutex: *mut ::libc::c_void,
    pub __nwaiters: ::libc::c_uint,
    pub __broadcast_seq: ::libc::c_uint,
}
impl ::std::default::Default for Struct_Unnamed33 {
    fn default() -> Struct_Unnamed33 { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_cond_t = Union_Unnamed32;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed34 {
    pub _bindgen_data_: [u32; 1u],
}
impl Union_Unnamed34 {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 4u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_int {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed34 {
    fn default() -> Union_Unnamed34 { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_condattr_t = Union_Unnamed34;
pub type pthread_key_t = ::libc::c_uint;
pub type pthread_once_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed35 {
    pub _bindgen_data_: [u64; 7u],
}
impl Union_Unnamed35 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed36 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 56u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed35 {
    fn default() -> Union_Unnamed35 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed36 {
    pub __lock: ::libc::c_int,
    pub __nr_readers: ::libc::c_uint,
    pub __readers_wakeup: ::libc::c_uint,
    pub __writer_wakeup: ::libc::c_uint,
    pub __nr_readers_queued: ::libc::c_uint,
    pub __nr_writers_queued: ::libc::c_uint,
    pub __writer: ::libc::c_int,
    pub __shared: ::libc::c_int,
    pub __pad1: ::libc::c_ulong,
    pub __pad2: ::libc::c_ulong,
    pub __flags: ::libc::c_uint,
}
impl ::std::default::Default for Struct_Unnamed36 {
    fn default() -> Struct_Unnamed36 { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlock_t = Union_Unnamed35;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed37 {
    pub _bindgen_data_: [u64; 1u],
}
impl Union_Unnamed37 {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 8u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed37 {
    fn default() -> Union_Unnamed37 { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlockattr_t = Union_Unnamed37;
pub type pthread_spinlock_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed38 {
    pub _bindgen_data_: [u64; 4u],
}
impl Union_Unnamed38 {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 32u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_long {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed38 {
    fn default() -> Union_Unnamed38 { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrier_t = Union_Unnamed38;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed39 {
    pub _bindgen_data_: [u32; 1u],
}
impl Union_Unnamed39 {
    pub unsafe fn __size(&mut self) -> *mut [::libc::c_char; 4u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn __align(&mut self) -> *mut ::libc::c_int {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed39 {
    fn default() -> Union_Unnamed39 { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrierattr_t = Union_Unnamed39;
pub type Enum_Unnamed40 = ::libc::c_uint;
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: ::libc::c_uint = 0;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: ::libc::c_uint = 1;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: ::libc::c_uint = 2;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: ::libc::c_uint = 3;
pub const G_BOOKMARK_FILE_ERROR_READ: ::libc::c_uint = 4;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: ::libc::c_uint = 5;
pub const G_BOOKMARK_FILE_ERROR_WRITE: ::libc::c_uint = 6;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: ::libc::c_uint = 7;
pub type GBookmarkFileError = Enum_Unnamed40;
pub enum Struct__GBookmarkFile { }
pub type GBookmarkFile = Struct__GBookmarkFile;
pub type Enum_Unnamed41 = ::libc::c_uint;
pub const G_CHECKSUM_MD5: ::libc::c_uint = 0;
pub const G_CHECKSUM_SHA1: ::libc::c_uint = 1;
pub const G_CHECKSUM_SHA256: ::libc::c_uint = 2;
pub const G_CHECKSUM_SHA512: ::libc::c_uint = 3;
pub type GChecksumType = Enum_Unnamed41;
pub enum Struct__GChecksum { }
pub type GChecksum = Struct__GChecksum;
pub type Enum_Unnamed42 = ::libc::c_uint;
pub const G_CONVERT_ERROR_NO_CONVERSION: ::libc::c_uint = 0;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: ::libc::c_uint = 1;
pub const G_CONVERT_ERROR_FAILED: ::libc::c_uint = 2;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: ::libc::c_uint = 3;
pub const G_CONVERT_ERROR_BAD_URI: ::libc::c_uint = 4;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: ::libc::c_uint = 5;
pub const G_CONVERT_ERROR_NO_MEMORY: ::libc::c_uint = 6;
pub type GConvertError = Enum_Unnamed42;
pub enum Struct__GIConv { }
pub type GIConv = *mut Struct__GIConv;
pub enum Struct__GData { }
pub type GData = Struct__GData;
pub type GDataForeachFunc =
    ::std::option::Option<extern "C" fn
                              (key_id: GQuark, data: gpointer,
                               user_data: gpointer)>;
pub type GDuplicateFunc =
    ::std::option::Option<extern "C" fn(data: gpointer, user_data: gpointer)
                              -> gpointer>;
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = Struct__GDate;
pub type Enum_Unnamed43 = ::libc::c_uint;
pub const G_DATE_DAY: ::libc::c_uint = 0;
pub const G_DATE_MONTH: ::libc::c_uint = 1;
pub const G_DATE_YEAR: ::libc::c_uint = 2;
pub type GDateDMY = Enum_Unnamed43;
pub type Enum_Unnamed44 = ::libc::c_uint;
pub const G_DATE_BAD_WEEKDAY: ::libc::c_uint = 0;
pub const G_DATE_MONDAY: ::libc::c_uint = 1;
pub const G_DATE_TUESDAY: ::libc::c_uint = 2;
pub const G_DATE_WEDNESDAY: ::libc::c_uint = 3;
pub const G_DATE_THURSDAY: ::libc::c_uint = 4;
pub const G_DATE_FRIDAY: ::libc::c_uint = 5;
pub const G_DATE_SATURDAY: ::libc::c_uint = 6;
pub const G_DATE_SUNDAY: ::libc::c_uint = 7;
pub type GDateWeekday = Enum_Unnamed44;
pub type Enum_Unnamed45 = ::libc::c_uint;
pub const G_DATE_BAD_MONTH: ::libc::c_uint = 0;
pub const G_DATE_JANUARY: ::libc::c_uint = 1;
pub const G_DATE_FEBRUARY: ::libc::c_uint = 2;
pub const G_DATE_MARCH: ::libc::c_uint = 3;
pub const G_DATE_APRIL: ::libc::c_uint = 4;
pub const G_DATE_MAY: ::libc::c_uint = 5;
pub const G_DATE_JUNE: ::libc::c_uint = 6;
pub const G_DATE_JULY: ::libc::c_uint = 7;
pub const G_DATE_AUGUST: ::libc::c_uint = 8;
pub const G_DATE_SEPTEMBER: ::libc::c_uint = 9;
pub const G_DATE_OCTOBER: ::libc::c_uint = 10;
pub const G_DATE_NOVEMBER: ::libc::c_uint = 11;
pub const G_DATE_DECEMBER: ::libc::c_uint = 12;
pub type GDateMonth = Enum_Unnamed45;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDate {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
}
impl ::std::default::Default for Struct__GDate {
    fn default() -> Struct__GDate { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTimeZone { }
pub type GTimeZone = Struct__GTimeZone;
pub type Enum_Unnamed46 = ::libc::c_uint;
pub const G_TIME_TYPE_STANDARD: ::libc::c_uint = 0;
pub const G_TIME_TYPE_DAYLIGHT: ::libc::c_uint = 1;
pub const G_TIME_TYPE_UNIVERSAL: ::libc::c_uint = 2;
pub type GTimeType = Enum_Unnamed46;
pub type GTimeSpan = gint64;
pub enum Struct__GDateTime { }
pub type GDateTime = Struct__GDateTime;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::libc::c_ushort,
    pub d_type: ::libc::c_uchar,
    pub d_name: [::libc::c_char; 256u],
}
impl ::std::default::Default for Struct_dirent {
    fn default() -> Struct_dirent { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed47 = ::libc::c_uint;
pub const DT_UNKNOWN: ::libc::c_uint = 0;
pub const DT_FIFO: ::libc::c_uint = 1;
pub const DT_CHR: ::libc::c_uint = 2;
pub const DT_DIR: ::libc::c_uint = 4;
pub const DT_BLK: ::libc::c_uint = 6;
pub const DT_REG: ::libc::c_uint = 8;
pub const DT_LNK: ::libc::c_uint = 10;
pub const DT_SOCK: ::libc::c_uint = 12;
pub const DT_WHT: ::libc::c_uint = 14;
pub enum Struct___dirstream { }
pub type DIR = Struct___dirstream;
pub enum Struct__GDir { }
pub type GDir = Struct__GDir;
pub type Enum_Unnamed48 = ::libc::c_uint;
pub const G_FILE_ERROR_EXIST: ::libc::c_uint = 0;
pub const G_FILE_ERROR_ISDIR: ::libc::c_uint = 1;
pub const G_FILE_ERROR_ACCES: ::libc::c_uint = 2;
pub const G_FILE_ERROR_NAMETOOLONG: ::libc::c_uint = 3;
pub const G_FILE_ERROR_NOENT: ::libc::c_uint = 4;
pub const G_FILE_ERROR_NOTDIR: ::libc::c_uint = 5;
pub const G_FILE_ERROR_NXIO: ::libc::c_uint = 6;
pub const G_FILE_ERROR_NODEV: ::libc::c_uint = 7;
pub const G_FILE_ERROR_ROFS: ::libc::c_uint = 8;
pub const G_FILE_ERROR_TXTBSY: ::libc::c_uint = 9;
pub const G_FILE_ERROR_FAULT: ::libc::c_uint = 10;
pub const G_FILE_ERROR_LOOP: ::libc::c_uint = 11;
pub const G_FILE_ERROR_NOSPC: ::libc::c_uint = 12;
pub const G_FILE_ERROR_NOMEM: ::libc::c_uint = 13;
pub const G_FILE_ERROR_MFILE: ::libc::c_uint = 14;
pub const G_FILE_ERROR_NFILE: ::libc::c_uint = 15;
pub const G_FILE_ERROR_BADF: ::libc::c_uint = 16;
pub const G_FILE_ERROR_INVAL: ::libc::c_uint = 17;
pub const G_FILE_ERROR_PIPE: ::libc::c_uint = 18;
pub const G_FILE_ERROR_AGAIN: ::libc::c_uint = 19;
pub const G_FILE_ERROR_INTR: ::libc::c_uint = 20;
pub const G_FILE_ERROR_IO: ::libc::c_uint = 21;
pub const G_FILE_ERROR_PERM: ::libc::c_uint = 22;
pub const G_FILE_ERROR_NOSYS: ::libc::c_uint = 23;
pub const G_FILE_ERROR_FAILED: ::libc::c_uint = 24;
pub type GFileError = Enum_Unnamed48;
pub type Enum_Unnamed49 = ::libc::c_uint;
pub const G_FILE_TEST_IS_REGULAR: ::libc::c_uint = 1;
pub const G_FILE_TEST_IS_SYMLINK: ::libc::c_uint = 2;
pub const G_FILE_TEST_IS_DIR: ::libc::c_uint = 4;
pub const G_FILE_TEST_IS_EXECUTABLE: ::libc::c_uint = 8;
pub const G_FILE_TEST_EXISTS: ::libc::c_uint = 16;
pub type GFileTest = Enum_Unnamed49;
pub type GMemVTable = Struct__GMemVTable;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMemVTable {
    pub malloc: ::std::option::Option<extern "C" fn(n_bytes: gsize)
                                          -> gpointer>,
    pub realloc: ::std::option::Option<extern "C" fn
                                           (mem: gpointer, n_bytes: gsize)
                                           -> gpointer>,
    pub free: ::std::option::Option<extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<extern "C" fn
                                          (n_blocks: gsize,
                                           n_block_bytes: gsize) -> gpointer>,
    pub try_malloc: ::std::option::Option<extern "C" fn(n_bytes: gsize)
                                              -> gpointer>,
    pub try_realloc: ::std::option::Option<extern "C" fn
                                               (mem: gpointer, n_bytes: gsize)
                                               -> gpointer>,
}
impl ::std::default::Default for Struct__GMemVTable {
    fn default() -> Struct__GMemVTable { unsafe { ::std::mem::zeroed() } }
}
pub type GNode = Struct__GNode;
pub type Enum_Unnamed50 = ::libc::c_uint;
pub const G_TRAVERSE_LEAVES: ::libc::c_uint = 1;
pub const G_TRAVERSE_NON_LEAVES: ::libc::c_uint = 2;
pub const G_TRAVERSE_ALL: ::libc::c_uint = 3;
pub const G_TRAVERSE_MASK: ::libc::c_uint = 3;
pub const G_TRAVERSE_LEAFS: ::libc::c_uint = 1;
pub const G_TRAVERSE_NON_LEAFS: ::libc::c_uint = 2;
pub type GTraverseFlags = Enum_Unnamed50;
pub type Enum_Unnamed51 = ::libc::c_uint;
pub const G_IN_ORDER: ::libc::c_uint = 0;
pub const G_PRE_ORDER: ::libc::c_uint = 1;
pub const G_POST_ORDER: ::libc::c_uint = 2;
pub const G_LEVEL_ORDER: ::libc::c_uint = 3;
pub type GTraverseType = Enum_Unnamed51;
pub type GNodeTraverseFunc =
    ::std::option::Option<extern "C" fn(node: *mut GNode, data: gpointer)
                              -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<extern "C" fn(node: *mut GNode, data: gpointer)>;
pub type GCopyFunc =
    ::std::option::Option<extern "C" fn(src: gconstpointer, data: gpointer)
                              -> gpointer>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
impl ::std::default::Default for Struct__GNode {
    fn default() -> Struct__GNode { unsafe { ::std::mem::zeroed() } }
}
pub type GList = Struct__GList;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
impl ::std::default::Default for Struct__GList {
    fn default() -> Struct__GList { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GHashTable { }
pub type GHashTable = Struct__GHashTable;
pub type GHRFunc =
    ::std::option::Option<extern "C" fn
                              (key: gpointer, value: gpointer,
                               user_data: gpointer) -> gboolean>;
pub type GHashTableIter = Struct__GHashTableIter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::libc::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
impl ::std::default::Default for Struct__GHashTableIter {
    fn default() -> Struct__GHashTableIter { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GHmac { }
pub type GHmac = Struct__GHmac;
pub type GHook = Struct__GHook;
pub type GHookList = Struct__GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<extern "C" fn
                              (new_hook: *mut GHook, sibling: *mut GHook)
                              -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<extern "C" fn(hook: *mut GHook, data: gpointer)
                              -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<extern "C" fn
                              (hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller =
    ::std::option::Option<extern "C" fn
                              (hook: *mut GHook, marshal_data: gpointer)
                              -> gboolean>;
pub type GHookFunc = ::std::option::Option<extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc =
    ::std::option::Option<extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<extern "C" fn
                              (hook_list: *mut GHookList, hook: *mut GHook)>;
pub type Enum_Unnamed52 = ::libc::c_uint;
pub const G_HOOK_FLAG_ACTIVE: ::libc::c_uint = 1;
pub const G_HOOK_FLAG_IN_CALL: ::libc::c_uint = 2;
pub const G_HOOK_FLAG_MASK: ::libc::c_uint = 15;
pub type GHookFlagMask = Enum_Unnamed52;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GHookList {
    pub seq_id: gulong,
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2u],
}
impl ::std::default::Default for Struct__GHookList {
    fn default() -> Struct__GHookList { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
impl ::std::default::Default for Struct__GHook {
    fn default() -> Struct__GHook { unsafe { ::std::mem::zeroed() } }
}
pub type GPollFD = Struct__GPollFD;
pub type GPollFunc =
    ::std::option::Option<extern "C" fn
                              (ufds: *mut GPollFD, nfsd: guint,
                               timeout_: gint) -> gint>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
impl ::std::default::Default for Struct__GPollFD {
    fn default() -> Struct__GPollFD { unsafe { ::std::mem::zeroed() } }
}
pub type GSList = Struct__GSList;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
impl ::std::default::Default for Struct__GSList {
    fn default() -> Struct__GSList { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed53 = ::libc::c_uint;
pub const G_IO_IN: ::libc::c_uint = 1;
pub const G_IO_OUT: ::libc::c_uint = 4;
pub const G_IO_PRI: ::libc::c_uint = 2;
pub const G_IO_ERR: ::libc::c_uint = 8;
pub const G_IO_HUP: ::libc::c_uint = 16;
pub const G_IO_NVAL: ::libc::c_uint = 32;
pub type GIOCondition = Enum_Unnamed53;
pub enum Struct__GMainContext { }
pub type GMainContext = Struct__GMainContext;
pub enum Struct__GMainLoop { }
pub type GMainLoop = Struct__GMainLoop;
pub type GSource = Struct__GSource;
pub enum Struct__GSourcePrivate { }
pub type GSourcePrivate = Struct__GSourcePrivate;
pub type GSourceCallbackFuncs = Struct__GSourceCallbackFuncs;
pub type GSourceFuncs = Struct__GSourceFuncs;
pub type GSourceFunc =
    ::std::option::Option<extern "C" fn(user_data: gpointer) -> gboolean>;
pub type GChildWatchFunc =
    ::std::option::Option<extern "C" fn
                              (pid: GPid, status: gint, user_data: gpointer)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::libc::c_char,
    pub _priv: *mut GSourcePrivate,
}
impl ::std::default::Default for Struct__GSource {
    fn default() -> Struct__GSource { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSourceCallbackFuncs {
    pub _ref: ::std::option::Option<extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<extern "C" fn
                                       (cb_data: gpointer,
                                        source: *mut GSource,
                                        func: *mut GSourceFunc,
                                        data: *mut gpointer)>,
}
impl ::std::default::Default for Struct__GSourceCallbackFuncs {
    fn default() -> Struct__GSourceCallbackFuncs {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GSourceDummyMarshal = ::std::option::Option<extern "C" fn()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSourceFuncs {
    pub prepare: ::std::option::Option<extern "C" fn
                                           (source: *mut GSource,
                                            timeout_: *mut gint) -> gboolean>,
    pub check: ::std::option::Option<extern "C" fn(source: *mut GSource)
                                         -> gboolean>,
    pub dispatch: ::std::option::Option<extern "C" fn
                                            (source: *mut GSource,
                                             callback: GSourceFunc,
                                             user_data: gpointer)
                                            -> gboolean>,
    pub finalize: ::std::option::Option<extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
impl ::std::default::Default for Struct__GSourceFuncs {
    fn default() -> Struct__GSourceFuncs { unsafe { ::std::mem::zeroed() } }
}
pub type gunichar = guint32;
pub type gunichar2 = guint16;
pub type Enum_Unnamed54 = ::libc::c_uint;
pub const G_UNICODE_CONTROL: ::libc::c_uint = 0;
pub const G_UNICODE_FORMAT: ::libc::c_uint = 1;
pub const G_UNICODE_UNASSIGNED: ::libc::c_uint = 2;
pub const G_UNICODE_PRIVATE_USE: ::libc::c_uint = 3;
pub const G_UNICODE_SURROGATE: ::libc::c_uint = 4;
pub const G_UNICODE_LOWERCASE_LETTER: ::libc::c_uint = 5;
pub const G_UNICODE_MODIFIER_LETTER: ::libc::c_uint = 6;
pub const G_UNICODE_OTHER_LETTER: ::libc::c_uint = 7;
pub const G_UNICODE_TITLECASE_LETTER: ::libc::c_uint = 8;
pub const G_UNICODE_UPPERCASE_LETTER: ::libc::c_uint = 9;
pub const G_UNICODE_SPACING_MARK: ::libc::c_uint = 10;
pub const G_UNICODE_ENCLOSING_MARK: ::libc::c_uint = 11;
pub const G_UNICODE_NON_SPACING_MARK: ::libc::c_uint = 12;
pub const G_UNICODE_DECIMAL_NUMBER: ::libc::c_uint = 13;
pub const G_UNICODE_LETTER_NUMBER: ::libc::c_uint = 14;
pub const G_UNICODE_OTHER_NUMBER: ::libc::c_uint = 15;
pub const G_UNICODE_CONNECT_PUNCTUATION: ::libc::c_uint = 16;
pub const G_UNICODE_DASH_PUNCTUATION: ::libc::c_uint = 17;
pub const G_UNICODE_CLOSE_PUNCTUATION: ::libc::c_uint = 18;
pub const G_UNICODE_FINAL_PUNCTUATION: ::libc::c_uint = 19;
pub const G_UNICODE_INITIAL_PUNCTUATION: ::libc::c_uint = 20;
pub const G_UNICODE_OTHER_PUNCTUATION: ::libc::c_uint = 21;
pub const G_UNICODE_OPEN_PUNCTUATION: ::libc::c_uint = 22;
pub const G_UNICODE_CURRENCY_SYMBOL: ::libc::c_uint = 23;
pub const G_UNICODE_MODIFIER_SYMBOL: ::libc::c_uint = 24;
pub const G_UNICODE_MATH_SYMBOL: ::libc::c_uint = 25;
pub const G_UNICODE_OTHER_SYMBOL: ::libc::c_uint = 26;
pub const G_UNICODE_LINE_SEPARATOR: ::libc::c_uint = 27;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: ::libc::c_uint = 28;
pub const G_UNICODE_SPACE_SEPARATOR: ::libc::c_uint = 29;
pub type GUnicodeType = Enum_Unnamed54;
pub type Enum_Unnamed55 = ::libc::c_uint;
pub const G_UNICODE_BREAK_MANDATORY: ::libc::c_uint = 0;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: ::libc::c_uint = 1;
pub const G_UNICODE_BREAK_LINE_FEED: ::libc::c_uint = 2;
pub const G_UNICODE_BREAK_COMBINING_MARK: ::libc::c_uint = 3;
pub const G_UNICODE_BREAK_SURROGATE: ::libc::c_uint = 4;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: ::libc::c_uint = 5;
pub const G_UNICODE_BREAK_INSEPARABLE: ::libc::c_uint = 6;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: ::libc::c_uint = 7;
pub const G_UNICODE_BREAK_CONTINGENT: ::libc::c_uint = 8;
pub const G_UNICODE_BREAK_SPACE: ::libc::c_uint = 9;
pub const G_UNICODE_BREAK_AFTER: ::libc::c_uint = 10;
pub const G_UNICODE_BREAK_BEFORE: ::libc::c_uint = 11;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: ::libc::c_uint = 12;
pub const G_UNICODE_BREAK_HYPHEN: ::libc::c_uint = 13;
pub const G_UNICODE_BREAK_NON_STARTER: ::libc::c_uint = 14;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: ::libc::c_uint = 15;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: ::libc::c_uint = 16;
pub const G_UNICODE_BREAK_QUOTATION: ::libc::c_uint = 17;
pub const G_UNICODE_BREAK_EXCLAMATION: ::libc::c_uint = 18;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: ::libc::c_uint = 19;
pub const G_UNICODE_BREAK_NUMERIC: ::libc::c_uint = 20;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: ::libc::c_uint = 21;
pub const G_UNICODE_BREAK_SYMBOL: ::libc::c_uint = 22;
pub const G_UNICODE_BREAK_ALPHABETIC: ::libc::c_uint = 23;
pub const G_UNICODE_BREAK_PREFIX: ::libc::c_uint = 24;
pub const G_UNICODE_BREAK_POSTFIX: ::libc::c_uint = 25;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: ::libc::c_uint = 26;
pub const G_UNICODE_BREAK_AMBIGUOUS: ::libc::c_uint = 27;
pub const G_UNICODE_BREAK_UNKNOWN: ::libc::c_uint = 28;
pub const G_UNICODE_BREAK_NEXT_LINE: ::libc::c_uint = 29;
pub const G_UNICODE_BREAK_WORD_JOINER: ::libc::c_uint = 30;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: ::libc::c_uint = 31;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: ::libc::c_uint = 32;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: ::libc::c_uint = 33;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: ::libc::c_uint = 34;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: ::libc::c_uint = 35;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: ::libc::c_uint = 36;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: ::libc::c_uint = 37;
pub const G_UNICODE_BREAK_HEBREW_LETTER: ::libc::c_uint = 38;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: ::libc::c_uint = 39;
pub type GUnicodeBreakType = Enum_Unnamed55;
pub type Enum_Unnamed56 = ::libc::c_int;
pub const G_UNICODE_SCRIPT_INVALID_CODE: ::libc::c_int = -1;
pub const G_UNICODE_SCRIPT_COMMON: ::libc::c_int = 0;
pub const G_UNICODE_SCRIPT_INHERITED: ::libc::c_int = 1;
pub const G_UNICODE_SCRIPT_ARABIC: ::libc::c_int = 2;
pub const G_UNICODE_SCRIPT_ARMENIAN: ::libc::c_int = 3;
pub const G_UNICODE_SCRIPT_BENGALI: ::libc::c_int = 4;
pub const G_UNICODE_SCRIPT_BOPOMOFO: ::libc::c_int = 5;
pub const G_UNICODE_SCRIPT_CHEROKEE: ::libc::c_int = 6;
pub const G_UNICODE_SCRIPT_COPTIC: ::libc::c_int = 7;
pub const G_UNICODE_SCRIPT_CYRILLIC: ::libc::c_int = 8;
pub const G_UNICODE_SCRIPT_DESERET: ::libc::c_int = 9;
pub const G_UNICODE_SCRIPT_DEVANAGARI: ::libc::c_int = 10;
pub const G_UNICODE_SCRIPT_ETHIOPIC: ::libc::c_int = 11;
pub const G_UNICODE_SCRIPT_GEORGIAN: ::libc::c_int = 12;
pub const G_UNICODE_SCRIPT_GOTHIC: ::libc::c_int = 13;
pub const G_UNICODE_SCRIPT_GREEK: ::libc::c_int = 14;
pub const G_UNICODE_SCRIPT_GUJARATI: ::libc::c_int = 15;
pub const G_UNICODE_SCRIPT_GURMUKHI: ::libc::c_int = 16;
pub const G_UNICODE_SCRIPT_HAN: ::libc::c_int = 17;
pub const G_UNICODE_SCRIPT_HANGUL: ::libc::c_int = 18;
pub const G_UNICODE_SCRIPT_HEBREW: ::libc::c_int = 19;
pub const G_UNICODE_SCRIPT_HIRAGANA: ::libc::c_int = 20;
pub const G_UNICODE_SCRIPT_KANNADA: ::libc::c_int = 21;
pub const G_UNICODE_SCRIPT_KATAKANA: ::libc::c_int = 22;
pub const G_UNICODE_SCRIPT_KHMER: ::libc::c_int = 23;
pub const G_UNICODE_SCRIPT_LAO: ::libc::c_int = 24;
pub const G_UNICODE_SCRIPT_LATIN: ::libc::c_int = 25;
pub const G_UNICODE_SCRIPT_MALAYALAM: ::libc::c_int = 26;
pub const G_UNICODE_SCRIPT_MONGOLIAN: ::libc::c_int = 27;
pub const G_UNICODE_SCRIPT_MYANMAR: ::libc::c_int = 28;
pub const G_UNICODE_SCRIPT_OGHAM: ::libc::c_int = 29;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: ::libc::c_int = 30;
pub const G_UNICODE_SCRIPT_ORIYA: ::libc::c_int = 31;
pub const G_UNICODE_SCRIPT_RUNIC: ::libc::c_int = 32;
pub const G_UNICODE_SCRIPT_SINHALA: ::libc::c_int = 33;
pub const G_UNICODE_SCRIPT_SYRIAC: ::libc::c_int = 34;
pub const G_UNICODE_SCRIPT_TAMIL: ::libc::c_int = 35;
pub const G_UNICODE_SCRIPT_TELUGU: ::libc::c_int = 36;
pub const G_UNICODE_SCRIPT_THAANA: ::libc::c_int = 37;
pub const G_UNICODE_SCRIPT_THAI: ::libc::c_int = 38;
pub const G_UNICODE_SCRIPT_TIBETAN: ::libc::c_int = 39;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: ::libc::c_int = 40;
pub const G_UNICODE_SCRIPT_YI: ::libc::c_int = 41;
pub const G_UNICODE_SCRIPT_TAGALOG: ::libc::c_int = 42;
pub const G_UNICODE_SCRIPT_HANUNOO: ::libc::c_int = 43;
pub const G_UNICODE_SCRIPT_BUHID: ::libc::c_int = 44;
pub const G_UNICODE_SCRIPT_TAGBANWA: ::libc::c_int = 45;
pub const G_UNICODE_SCRIPT_BRAILLE: ::libc::c_int = 46;
pub const G_UNICODE_SCRIPT_CYPRIOT: ::libc::c_int = 47;
pub const G_UNICODE_SCRIPT_LIMBU: ::libc::c_int = 48;
pub const G_UNICODE_SCRIPT_OSMANYA: ::libc::c_int = 49;
pub const G_UNICODE_SCRIPT_SHAVIAN: ::libc::c_int = 50;
pub const G_UNICODE_SCRIPT_LINEAR_B: ::libc::c_int = 51;
pub const G_UNICODE_SCRIPT_TAI_LE: ::libc::c_int = 52;
pub const G_UNICODE_SCRIPT_UGARITIC: ::libc::c_int = 53;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: ::libc::c_int = 54;
pub const G_UNICODE_SCRIPT_BUGINESE: ::libc::c_int = 55;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: ::libc::c_int = 56;
pub const G_UNICODE_SCRIPT_TIFINAGH: ::libc::c_int = 57;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: ::libc::c_int = 58;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: ::libc::c_int = 59;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: ::libc::c_int = 60;
pub const G_UNICODE_SCRIPT_UNKNOWN: ::libc::c_int = 61;
pub const G_UNICODE_SCRIPT_BALINESE: ::libc::c_int = 62;
pub const G_UNICODE_SCRIPT_CUNEIFORM: ::libc::c_int = 63;
pub const G_UNICODE_SCRIPT_PHOENICIAN: ::libc::c_int = 64;
pub const G_UNICODE_SCRIPT_PHAGS_PA: ::libc::c_int = 65;
pub const G_UNICODE_SCRIPT_NKO: ::libc::c_int = 66;
pub const G_UNICODE_SCRIPT_KAYAH_LI: ::libc::c_int = 67;
pub const G_UNICODE_SCRIPT_LEPCHA: ::libc::c_int = 68;
pub const G_UNICODE_SCRIPT_REJANG: ::libc::c_int = 69;
pub const G_UNICODE_SCRIPT_SUNDANESE: ::libc::c_int = 70;
pub const G_UNICODE_SCRIPT_SAURASHTRA: ::libc::c_int = 71;
pub const G_UNICODE_SCRIPT_CHAM: ::libc::c_int = 72;
pub const G_UNICODE_SCRIPT_OL_CHIKI: ::libc::c_int = 73;
pub const G_UNICODE_SCRIPT_VAI: ::libc::c_int = 74;
pub const G_UNICODE_SCRIPT_CARIAN: ::libc::c_int = 75;
pub const G_UNICODE_SCRIPT_LYCIAN: ::libc::c_int = 76;
pub const G_UNICODE_SCRIPT_LYDIAN: ::libc::c_int = 77;
pub const G_UNICODE_SCRIPT_AVESTAN: ::libc::c_int = 78;
pub const G_UNICODE_SCRIPT_BAMUM: ::libc::c_int = 79;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: ::libc::c_int = 80;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: ::libc::c_int = 81;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: ::libc::c_int = 82;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: ::libc::c_int = 83;
pub const G_UNICODE_SCRIPT_JAVANESE: ::libc::c_int = 84;
pub const G_UNICODE_SCRIPT_KAITHI: ::libc::c_int = 85;
pub const G_UNICODE_SCRIPT_LISU: ::libc::c_int = 86;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: ::libc::c_int = 87;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: ::libc::c_int = 88;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: ::libc::c_int = 89;
pub const G_UNICODE_SCRIPT_SAMARITAN: ::libc::c_int = 90;
pub const G_UNICODE_SCRIPT_TAI_THAM: ::libc::c_int = 91;
pub const G_UNICODE_SCRIPT_TAI_VIET: ::libc::c_int = 92;
pub const G_UNICODE_SCRIPT_BATAK: ::libc::c_int = 93;
pub const G_UNICODE_SCRIPT_BRAHMI: ::libc::c_int = 94;
pub const G_UNICODE_SCRIPT_MANDAIC: ::libc::c_int = 95;
pub const G_UNICODE_SCRIPT_CHAKMA: ::libc::c_int = 96;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: ::libc::c_int = 97;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: ::libc::c_int = 98;
pub const G_UNICODE_SCRIPT_MIAO: ::libc::c_int = 99;
pub const G_UNICODE_SCRIPT_SHARADA: ::libc::c_int = 100;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: ::libc::c_int = 101;
pub const G_UNICODE_SCRIPT_TAKRI: ::libc::c_int = 102;
pub const G_UNICODE_SCRIPT_BASSA_VAH: ::libc::c_int = 103;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: ::libc::c_int = 104;
pub const G_UNICODE_SCRIPT_DUPLOYAN: ::libc::c_int = 105;
pub const G_UNICODE_SCRIPT_ELBASAN: ::libc::c_int = 106;
pub const G_UNICODE_SCRIPT_GRANTHA: ::libc::c_int = 107;
pub const G_UNICODE_SCRIPT_KHOJKI: ::libc::c_int = 108;
pub const G_UNICODE_SCRIPT_KHUDAWADI: ::libc::c_int = 109;
pub const G_UNICODE_SCRIPT_LINEAR_A: ::libc::c_int = 110;
pub const G_UNICODE_SCRIPT_MAHAJANI: ::libc::c_int = 111;
pub const G_UNICODE_SCRIPT_MANICHAEAN: ::libc::c_int = 112;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: ::libc::c_int = 113;
pub const G_UNICODE_SCRIPT_MODI: ::libc::c_int = 114;
pub const G_UNICODE_SCRIPT_MRO: ::libc::c_int = 115;
pub const G_UNICODE_SCRIPT_NABATAEAN: ::libc::c_int = 116;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: ::libc::c_int = 117;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: ::libc::c_int = 118;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: ::libc::c_int = 119;
pub const G_UNICODE_SCRIPT_PALMYRENE: ::libc::c_int = 120;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: ::libc::c_int = 121;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: ::libc::c_int = 122;
pub const G_UNICODE_SCRIPT_SIDDHAM: ::libc::c_int = 123;
pub const G_UNICODE_SCRIPT_TIRHUTA: ::libc::c_int = 124;
pub const G_UNICODE_SCRIPT_WARANG_CITI: ::libc::c_int = 125;
pub type GUnicodeScript = Enum_Unnamed56;
pub type Enum_Unnamed57 = ::libc::c_uint;
pub const G_NORMALIZE_DEFAULT: ::libc::c_uint = 0;
pub const G_NORMALIZE_NFD: ::libc::c_uint = 0;
pub const G_NORMALIZE_DEFAULT_COMPOSE: ::libc::c_uint = 1;
pub const G_NORMALIZE_NFC: ::libc::c_uint = 1;
pub const G_NORMALIZE_ALL: ::libc::c_uint = 2;
pub const G_NORMALIZE_NFKD: ::libc::c_uint = 2;
pub const G_NORMALIZE_ALL_COMPOSE: ::libc::c_uint = 3;
pub const G_NORMALIZE_NFKC: ::libc::c_uint = 3;
pub type GNormalizeMode = Enum_Unnamed57;
pub type Enum_Unnamed58 = ::libc::c_uint;
pub const G_USER_DIRECTORY_DESKTOP: ::libc::c_uint = 0;
pub const G_USER_DIRECTORY_DOCUMENTS: ::libc::c_uint = 1;
pub const G_USER_DIRECTORY_DOWNLOAD: ::libc::c_uint = 2;
pub const G_USER_DIRECTORY_MUSIC: ::libc::c_uint = 3;
pub const G_USER_DIRECTORY_PICTURES: ::libc::c_uint = 4;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: ::libc::c_uint = 5;
pub const G_USER_DIRECTORY_TEMPLATES: ::libc::c_uint = 6;
pub const G_USER_DIRECTORY_VIDEOS: ::libc::c_uint = 7;
pub const G_USER_N_DIRECTORIES: ::libc::c_uint = 8;
pub type GUserDirectory = Enum_Unnamed58;
pub type GDebugKey = Struct__GDebugKey;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
impl ::std::default::Default for Struct__GDebugKey {
    fn default() -> Struct__GDebugKey { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed59 = ::libc::c_uint;
pub const G_FORMAT_SIZE_DEFAULT: ::libc::c_uint = 0;
pub const G_FORMAT_SIZE_LONG_FORMAT: ::libc::c_uint = 1;
pub const G_FORMAT_SIZE_IEC_UNITS: ::libc::c_uint = 2;
pub type GFormatSizeFlags = Enum_Unnamed59;
pub type GVoidFunc = ::std::option::Option<extern "C" fn()>;
pub type GString = Struct__GString;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GString {
    pub _str: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
impl ::std::default::Default for Struct__GString {
    fn default() -> Struct__GString { unsafe { ::std::mem::zeroed() } }
}
pub type GIOChannel = Struct__GIOChannel;
pub type GIOFuncs = Struct__GIOFuncs;
pub type Enum_Unnamed60 = ::libc::c_uint;
pub const G_IO_ERROR_NONE: ::libc::c_uint = 0;
pub const G_IO_ERROR_AGAIN: ::libc::c_uint = 1;
pub const G_IO_ERROR_INVAL: ::libc::c_uint = 2;
pub const G_IO_ERROR_UNKNOWN: ::libc::c_uint = 3;
pub type GIOError = Enum_Unnamed60;
pub type Enum_Unnamed61 = ::libc::c_uint;
pub const G_IO_CHANNEL_ERROR_FBIG: ::libc::c_uint = 0;
pub const G_IO_CHANNEL_ERROR_INVAL: ::libc::c_uint = 1;
pub const G_IO_CHANNEL_ERROR_IO: ::libc::c_uint = 2;
pub const G_IO_CHANNEL_ERROR_ISDIR: ::libc::c_uint = 3;
pub const G_IO_CHANNEL_ERROR_NOSPC: ::libc::c_uint = 4;
pub const G_IO_CHANNEL_ERROR_NXIO: ::libc::c_uint = 5;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: ::libc::c_uint = 6;
pub const G_IO_CHANNEL_ERROR_PIPE: ::libc::c_uint = 7;
pub const G_IO_CHANNEL_ERROR_FAILED: ::libc::c_uint = 8;
pub type GIOChannelError = Enum_Unnamed61;
pub type Enum_Unnamed62 = ::libc::c_uint;
pub const G_IO_STATUS_ERROR: ::libc::c_uint = 0;
pub const G_IO_STATUS_NORMAL: ::libc::c_uint = 1;
pub const G_IO_STATUS_EOF: ::libc::c_uint = 2;
pub const G_IO_STATUS_AGAIN: ::libc::c_uint = 3;
pub type GIOStatus = Enum_Unnamed62;
pub type Enum_Unnamed63 = ::libc::c_uint;
pub const G_SEEK_CUR: ::libc::c_uint = 0;
pub const G_SEEK_SET: ::libc::c_uint = 1;
pub const G_SEEK_END: ::libc::c_uint = 2;
pub type GSeekType = Enum_Unnamed63;
pub type Enum_Unnamed64 = ::libc::c_uint;
pub const G_IO_FLAG_APPEND: ::libc::c_uint = 1;
pub const G_IO_FLAG_NONBLOCK: ::libc::c_uint = 2;
pub const G_IO_FLAG_IS_READABLE: ::libc::c_uint = 4;
pub const G_IO_FLAG_IS_WRITABLE: ::libc::c_uint = 8;
pub const G_IO_FLAG_IS_WRITEABLE: ::libc::c_uint = 8;
pub const G_IO_FLAG_IS_SEEKABLE: ::libc::c_uint = 16;
pub const G_IO_FLAG_MASK: ::libc::c_uint = 31;
pub const G_IO_FLAG_GET_MASK: ::libc::c_uint = 31;
pub const G_IO_FLAG_SET_MASK: ::libc::c_uint = 3;
pub type GIOFlags = Enum_Unnamed64;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6u],
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
impl ::std::default::Default for Struct__GIOChannel {
    fn default() -> Struct__GIOChannel { unsafe { ::std::mem::zeroed() } }
}
pub type GIOFunc =
    ::std::option::Option<extern "C" fn
                              (source: *mut GIOChannel,
                               condition: GIOCondition, data: gpointer)
                              -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GIOFuncs {
    pub io_read: ::std::option::Option<extern "C" fn
                                           (channel: *mut GIOChannel,
                                            buf: *mut gchar, count: gsize,
                                            bytes_read: *mut gsize,
                                            err: *mut *mut GError)
                                           -> GIOStatus>,
    pub io_write: ::std::option::Option<extern "C" fn
                                            (channel: *mut GIOChannel,
                                             buf: *const gchar, count: gsize,
                                             bytes_written: *mut gsize,
                                             err: *mut *mut GError)
                                            -> GIOStatus>,
    pub io_seek: ::std::option::Option<extern "C" fn
                                           (channel: *mut GIOChannel,
                                            offset: gint64, _type: GSeekType,
                                            err: *mut *mut GError)
                                           -> GIOStatus>,
    pub io_close: ::std::option::Option<extern "C" fn
                                            (channel: *mut GIOChannel,
                                             err: *mut *mut GError)
                                            -> GIOStatus>,
    pub io_create_watch: ::std::option::Option<extern "C" fn
                                                   (channel: *mut GIOChannel,
                                                    condition: GIOCondition)
                                                   -> *mut GSource>,
    pub io_free: ::std::option::Option<extern "C" fn
                                           (channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<extern "C" fn
                                                (channel: *mut GIOChannel,
                                                 flags: GIOFlags,
                                                 err: *mut *mut GError)
                                                -> GIOStatus>,
    pub io_get_flags: ::std::option::Option<extern "C" fn
                                                (channel: *mut GIOChannel)
                                                -> GIOFlags>,
}
impl ::std::default::Default for Struct__GIOFuncs {
    fn default() -> Struct__GIOFuncs { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed65 = ::libc::c_uint;
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: ::libc::c_uint = 0;
pub const G_KEY_FILE_ERROR_PARSE: ::libc::c_uint = 1;
pub const G_KEY_FILE_ERROR_NOT_FOUND: ::libc::c_uint = 2;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: ::libc::c_uint = 3;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: ::libc::c_uint = 4;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: ::libc::c_uint = 5;
pub type GKeyFileError = Enum_Unnamed65;
pub enum Struct__GKeyFile { }
pub type GKeyFile = Struct__GKeyFile;
pub type Enum_Unnamed66 = ::libc::c_uint;
pub const G_KEY_FILE_NONE: ::libc::c_uint = 0;
pub const G_KEY_FILE_KEEP_COMMENTS: ::libc::c_uint = 1;
pub const G_KEY_FILE_KEEP_TRANSLATIONS: ::libc::c_uint = 2;
pub type GKeyFileFlags = Enum_Unnamed66;
pub enum Struct__GMappedFile { }
pub type GMappedFile = Struct__GMappedFile;
pub type Enum_Unnamed67 = ::libc::c_uint;
pub const G_MARKUP_ERROR_BAD_UTF8: ::libc::c_uint = 0;
pub const G_MARKUP_ERROR_EMPTY: ::libc::c_uint = 1;
pub const G_MARKUP_ERROR_PARSE: ::libc::c_uint = 2;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: ::libc::c_uint = 3;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: ::libc::c_uint = 4;
pub const G_MARKUP_ERROR_INVALID_CONTENT: ::libc::c_uint = 5;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: ::libc::c_uint = 6;
pub type GMarkupError = Enum_Unnamed67;
pub type Enum_Unnamed68 = ::libc::c_uint;
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: ::libc::c_uint = 1;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT: ::libc::c_uint = 2;
pub const G_MARKUP_PREFIX_ERROR_POSITION: ::libc::c_uint = 4;
pub const G_MARKUP_IGNORE_QUALIFIED: ::libc::c_uint = 8;
pub type GMarkupParseFlags = Enum_Unnamed68;
pub enum Struct__GMarkupParseContext { }
pub type GMarkupParseContext = Struct__GMarkupParseContext;
pub type GMarkupParser = Struct__GMarkupParser;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMarkupParser {
    pub start_element: ::std::option::Option<extern "C" fn
                                                 (context:
                                                      *mut GMarkupParseContext,
                                                  element_name: *const gchar,
                                                  attribute_names:
                                                      *mut *const gchar,
                                                  attribute_values:
                                                      *mut *const gchar,
                                                  user_data: gpointer,
                                                  error: *mut *mut GError)>,
    pub end_element: ::std::option::Option<extern "C" fn
                                               (context:
                                                    *mut GMarkupParseContext,
                                                element_name: *const gchar,
                                                user_data: gpointer,
                                                error: *mut *mut GError)>,
    pub text: ::std::option::Option<extern "C" fn
                                        (context: *mut GMarkupParseContext,
                                         text: *const gchar, text_len: gsize,
                                         user_data: gpointer,
                                         error: *mut *mut GError)>,
    pub passthrough: ::std::option::Option<extern "C" fn
                                               (context:
                                                    *mut GMarkupParseContext,
                                                passthrough_text:
                                                    *const gchar,
                                                text_len: gsize,
                                                user_data: gpointer,
                                                error: *mut *mut GError)>,
    pub error: ::std::option::Option<extern "C" fn
                                         (context: *mut GMarkupParseContext,
                                          error: *mut GError,
                                          user_data: gpointer)>,
}
impl ::std::default::Default for Struct__GMarkupParser {
    fn default() -> Struct__GMarkupParser { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed69 = ::libc::c_uint;
pub const G_MARKUP_COLLECT_INVALID: ::libc::c_uint = 0;
pub const G_MARKUP_COLLECT_STRING: ::libc::c_uint = 1;
pub const G_MARKUP_COLLECT_STRDUP: ::libc::c_uint = 2;
pub const G_MARKUP_COLLECT_BOOLEAN: ::libc::c_uint = 3;
pub const G_MARKUP_COLLECT_TRISTATE: ::libc::c_uint = 4;
pub const G_MARKUP_COLLECT_OPTIONAL: ::libc::c_uint = 65536;
pub type GMarkupCollectType = Enum_Unnamed69;
pub type Enum_Unnamed70 = ::libc::c_int;
pub const G_LOG_FLAG_RECURSION: ::libc::c_int = 1;
pub const G_LOG_FLAG_FATAL: ::libc::c_int = 2;
pub const G_LOG_LEVEL_ERROR: ::libc::c_int = 4;
pub const G_LOG_LEVEL_CRITICAL: ::libc::c_int = 8;
pub const G_LOG_LEVEL_WARNING: ::libc::c_int = 16;
pub const G_LOG_LEVEL_MESSAGE: ::libc::c_int = 32;
pub const G_LOG_LEVEL_INFO: ::libc::c_int = 64;
pub const G_LOG_LEVEL_DEBUG: ::libc::c_int = 128;
pub const G_LOG_LEVEL_MASK: ::libc::c_int = -4;
pub type GLogLevelFlags = Enum_Unnamed70;
pub type GLogFunc =
    ::std::option::Option<extern "C" fn
                              (log_domain: *const gchar,
                               log_level: GLogLevelFlags,
                               message: *const gchar, user_data: gpointer)>;
pub type GPrintFunc =
    ::std::option::Option<extern "C" fn(string: *const gchar)>;
pub enum Struct__GOptionContext { }
pub type GOptionContext = Struct__GOptionContext;
pub enum Struct__GOptionGroup { }
pub type GOptionGroup = Struct__GOptionGroup;
pub type GOptionEntry = Struct__GOptionEntry;
pub type Enum_Unnamed71 = ::libc::c_uint;
pub const G_OPTION_FLAG_NONE: ::libc::c_uint = 0;
pub const G_OPTION_FLAG_HIDDEN: ::libc::c_uint = 1;
pub const G_OPTION_FLAG_IN_MAIN: ::libc::c_uint = 2;
pub const G_OPTION_FLAG_REVERSE: ::libc::c_uint = 4;
pub const G_OPTION_FLAG_NO_ARG: ::libc::c_uint = 8;
pub const G_OPTION_FLAG_FILENAME: ::libc::c_uint = 16;
pub const G_OPTION_FLAG_OPTIONAL_ARG: ::libc::c_uint = 32;
pub const G_OPTION_FLAG_NOALIAS: ::libc::c_uint = 64;
pub type GOptionFlags = Enum_Unnamed71;
pub type Enum_Unnamed72 = ::libc::c_uint;
pub const G_OPTION_ARG_NONE: ::libc::c_uint = 0;
pub const G_OPTION_ARG_STRING: ::libc::c_uint = 1;
pub const G_OPTION_ARG_INT: ::libc::c_uint = 2;
pub const G_OPTION_ARG_CALLBACK: ::libc::c_uint = 3;
pub const G_OPTION_ARG_FILENAME: ::libc::c_uint = 4;
pub const G_OPTION_ARG_STRING_ARRAY: ::libc::c_uint = 5;
pub const G_OPTION_ARG_FILENAME_ARRAY: ::libc::c_uint = 6;
pub const G_OPTION_ARG_DOUBLE: ::libc::c_uint = 7;
pub const G_OPTION_ARG_INT64: ::libc::c_uint = 8;
pub type GOptionArg = Enum_Unnamed72;
pub type GOptionArgFunc =
    ::std::option::Option<extern "C" fn
                              (option_name: *const gchar, value: *const gchar,
                               data: gpointer, error: *mut *mut GError)
                              -> gboolean>;
pub type GOptionParseFunc =
    ::std::option::Option<extern "C" fn
                              (context: *mut GOptionContext,
                               group: *mut GOptionGroup, data: gpointer,
                               error: *mut *mut GError) -> gboolean>;
pub type GOptionErrorFunc =
    ::std::option::Option<extern "C" fn
                              (context: *mut GOptionContext,
                               group: *mut GOptionGroup, data: gpointer,
                               error: *mut *mut GError)>;
pub type Enum_Unnamed73 = ::libc::c_uint;
pub const G_OPTION_ERROR_UNKNOWN_OPTION: ::libc::c_uint = 0;
pub const G_OPTION_ERROR_BAD_VALUE: ::libc::c_uint = 1;
pub const G_OPTION_ERROR_FAILED: ::libc::c_uint = 2;
pub type GOptionError = Enum_Unnamed73;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
impl ::std::default::Default for Struct__GOptionEntry {
    fn default() -> Struct__GOptionEntry { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GPatternSpec { }
pub type GPatternSpec = Struct__GPatternSpec;
pub type GQueue = Struct__GQueue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
impl ::std::default::Default for Struct__GQueue {
    fn default() -> Struct__GQueue { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GRand { }
pub type GRand = Struct__GRand;
pub type Enum_Unnamed74 = ::libc::c_uint;
pub const G_REGEX_ERROR_COMPILE: ::libc::c_uint = 0;
pub const G_REGEX_ERROR_OPTIMIZE: ::libc::c_uint = 1;
pub const G_REGEX_ERROR_REPLACE: ::libc::c_uint = 2;
pub const G_REGEX_ERROR_MATCH: ::libc::c_uint = 3;
pub const G_REGEX_ERROR_INTERNAL: ::libc::c_uint = 4;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: ::libc::c_uint = 101;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: ::libc::c_uint = 102;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: ::libc::c_uint = 103;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: ::libc::c_uint = 104;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: ::libc::c_uint = 105;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: ::libc::c_uint = 106;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: ::libc::c_uint =
    107;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: ::libc::c_uint = 108;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: ::libc::c_uint = 109;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: ::libc::c_uint = 112;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: ::libc::c_uint = 113;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: ::libc::c_uint = 114;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: ::libc::c_uint = 115;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: ::libc::c_uint = 118;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: ::libc::c_uint = 120;
pub const G_REGEX_ERROR_MEMORY_ERROR: ::libc::c_uint = 121;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: ::libc::c_uint = 125;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: ::libc::c_uint = 126;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: ::libc::c_uint = 127;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: ::libc::c_uint = 128;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: ::libc::c_uint = 130;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: ::libc::c_uint
          =
    131;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: ::libc::c_uint = 134;
pub const G_REGEX_ERROR_INVALID_CONDITION: ::libc::c_uint = 135;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: ::libc::c_uint = 136;
pub const G_REGEX_ERROR_INFINITE_LOOP: ::libc::c_uint = 140;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: ::libc::c_uint =
    142;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: ::libc::c_uint = 143;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: ::libc::c_uint = 146;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: ::libc::c_uint = 147;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: ::libc::c_uint = 148;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: ::libc::c_uint = 149;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: ::libc::c_uint = 151;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: ::libc::c_uint = 154;
pub const G_REGEX_ERROR_DEFINE_REPETION: ::libc::c_uint = 155;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: ::libc::c_uint = 156;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: ::libc::c_uint = 157;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: ::libc::c_uint = 158;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN:
          ::libc::c_uint =
    159;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: ::libc::c_uint =
    160;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: ::libc::c_uint = 161;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: ::libc::c_uint = 162;
pub const G_REGEX_ERROR_MISSING_DIGIT: ::libc::c_uint = 163;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: ::libc::c_uint = 164;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: ::libc::c_uint = 165;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED:
          ::libc::c_uint =
    166;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: ::libc::c_uint = 168;
pub const G_REGEX_ERROR_MISSING_NAME: ::libc::c_uint = 169;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: ::libc::c_uint = 171;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: ::libc::c_uint = 172;
pub const G_REGEX_ERROR_NAME_TOO_LONG: ::libc::c_uint = 175;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: ::libc::c_uint = 176;
pub type GRegexError = Enum_Unnamed74;
pub type Enum_Unnamed75 = ::libc::c_uint;
pub const G_REGEX_CASELESS: ::libc::c_uint = 1;
pub const G_REGEX_MULTILINE: ::libc::c_uint = 2;
pub const G_REGEX_DOTALL: ::libc::c_uint = 4;
pub const G_REGEX_EXTENDED: ::libc::c_uint = 8;
pub const G_REGEX_ANCHORED: ::libc::c_uint = 16;
pub const G_REGEX_DOLLAR_ENDONLY: ::libc::c_uint = 32;
pub const G_REGEX_UNGREEDY: ::libc::c_uint = 512;
pub const G_REGEX_RAW: ::libc::c_uint = 2048;
pub const G_REGEX_NO_AUTO_CAPTURE: ::libc::c_uint = 4096;
pub const G_REGEX_OPTIMIZE: ::libc::c_uint = 8192;
pub const G_REGEX_FIRSTLINE: ::libc::c_uint = 262144;
pub const G_REGEX_DUPNAMES: ::libc::c_uint = 524288;
pub const G_REGEX_NEWLINE_CR: ::libc::c_uint = 1048576;
pub const G_REGEX_NEWLINE_LF: ::libc::c_uint = 2097152;
pub const G_REGEX_NEWLINE_CRLF: ::libc::c_uint = 3145728;
pub const G_REGEX_NEWLINE_ANYCRLF: ::libc::c_uint = 5242880;
pub const G_REGEX_BSR_ANYCRLF: ::libc::c_uint = 8388608;
pub const G_REGEX_JAVASCRIPT_COMPAT: ::libc::c_uint = 33554432;
pub type GRegexCompileFlags = Enum_Unnamed75;
pub type Enum_Unnamed76 = ::libc::c_uint;
pub const G_REGEX_MATCH_ANCHORED: ::libc::c_uint = 16;
pub const G_REGEX_MATCH_NOTBOL: ::libc::c_uint = 128;
pub const G_REGEX_MATCH_NOTEOL: ::libc::c_uint = 256;
pub const G_REGEX_MATCH_NOTEMPTY: ::libc::c_uint = 1024;
pub const G_REGEX_MATCH_PARTIAL: ::libc::c_uint = 32768;
pub const G_REGEX_MATCH_NEWLINE_CR: ::libc::c_uint = 1048576;
pub const G_REGEX_MATCH_NEWLINE_LF: ::libc::c_uint = 2097152;
pub const G_REGEX_MATCH_NEWLINE_CRLF: ::libc::c_uint = 3145728;
pub const G_REGEX_MATCH_NEWLINE_ANY: ::libc::c_uint = 4194304;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF: ::libc::c_uint = 5242880;
pub const G_REGEX_MATCH_BSR_ANYCRLF: ::libc::c_uint = 8388608;
pub const G_REGEX_MATCH_BSR_ANY: ::libc::c_uint = 16777216;
pub const G_REGEX_MATCH_PARTIAL_SOFT: ::libc::c_uint = 32768;
pub const G_REGEX_MATCH_PARTIAL_HARD: ::libc::c_uint = 134217728;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART: ::libc::c_uint = 268435456;
pub type GRegexMatchFlags = Enum_Unnamed76;
pub enum Struct__GRegex { }
pub type GRegex = Struct__GRegex;
pub enum Struct__GMatchInfo { }
pub type GMatchInfo = Struct__GMatchInfo;
pub type GRegexEvalCallback =
    ::std::option::Option<extern "C" fn
                              (match_info: *const GMatchInfo,
                               result: *mut GString, user_data: gpointer)
                              -> gboolean>;
pub type GScanner = Struct__GScanner;
pub type GScannerConfig = Struct__GScannerConfig;
pub type GTokenValue = Union__GTokenValue;
pub type GScannerMsgFunc =
    ::std::option::Option<extern "C" fn
                              (scanner: *mut GScanner, message: *mut gchar,
                               error: gboolean)>;
pub type Enum_Unnamed77 = ::libc::c_uint;
pub const G_ERR_UNKNOWN: ::libc::c_uint = 0;
pub const G_ERR_UNEXP_EOF: ::libc::c_uint = 1;
pub const G_ERR_UNEXP_EOF_IN_STRING: ::libc::c_uint = 2;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: ::libc::c_uint = 3;
pub const G_ERR_NON_DIGIT_IN_CONST: ::libc::c_uint = 4;
pub const G_ERR_DIGIT_RADIX: ::libc::c_uint = 5;
pub const G_ERR_FLOAT_RADIX: ::libc::c_uint = 6;
pub const G_ERR_FLOAT_MALFORMED: ::libc::c_uint = 7;
pub type GErrorType = Enum_Unnamed77;
pub type Enum_Unnamed78 = ::libc::c_uint;
pub const G_TOKEN_EOF: ::libc::c_uint = 0;
pub const G_TOKEN_LEFT_PAREN: ::libc::c_uint = 40;
pub const G_TOKEN_RIGHT_PAREN: ::libc::c_uint = 41;
pub const G_TOKEN_LEFT_CURLY: ::libc::c_uint = 123;
pub const G_TOKEN_RIGHT_CURLY: ::libc::c_uint = 125;
pub const G_TOKEN_LEFT_BRACE: ::libc::c_uint = 91;
pub const G_TOKEN_RIGHT_BRACE: ::libc::c_uint = 93;
pub const G_TOKEN_EQUAL_SIGN: ::libc::c_uint = 61;
pub const G_TOKEN_COMMA: ::libc::c_uint = 44;
pub const G_TOKEN_NONE: ::libc::c_uint = 256;
pub const G_TOKEN_ERROR: ::libc::c_uint = 257;
pub const G_TOKEN_CHAR: ::libc::c_uint = 258;
pub const G_TOKEN_BINARY: ::libc::c_uint = 259;
pub const G_TOKEN_OCTAL: ::libc::c_uint = 260;
pub const G_TOKEN_INT: ::libc::c_uint = 261;
pub const G_TOKEN_HEX: ::libc::c_uint = 262;
pub const G_TOKEN_FLOAT: ::libc::c_uint = 263;
pub const G_TOKEN_STRING: ::libc::c_uint = 264;
pub const G_TOKEN_SYMBOL: ::libc::c_uint = 265;
pub const G_TOKEN_IDENTIFIER: ::libc::c_uint = 266;
pub const G_TOKEN_IDENTIFIER_NULL: ::libc::c_uint = 267;
pub const G_TOKEN_COMMENT_SINGLE: ::libc::c_uint = 268;
pub const G_TOKEN_COMMENT_MULTI: ::libc::c_uint = 269;
pub const G_TOKEN_LAST: ::libc::c_uint = 270;
pub type GTokenType = Enum_Unnamed78;
#[repr(C)]
#[derive(Copy)]
pub struct Union__GTokenValue {
    pub _bindgen_data_: [u64; 1u],
}
impl Union__GTokenValue {
    pub unsafe fn v_symbol(&mut self) -> *mut gpointer {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_identifier(&mut self) -> *mut *mut gchar {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_binary(&mut self) -> *mut gulong {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_octal(&mut self) -> *mut gulong {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_int(&mut self) -> *mut gulong {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_int64(&mut self) -> *mut guint64 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_float(&mut self) -> *mut gdouble {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_hex(&mut self) -> *mut gulong {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_string(&mut self) -> *mut *mut gchar {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_comment(&mut self) -> *mut *mut gchar {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_char(&mut self) -> *mut guchar {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_error(&mut self) -> *mut guint {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union__GTokenValue {
    fn default() -> Union__GTokenValue { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
    pub _bindgen_bitfield_7_: guint,
    pub _bindgen_bitfield_8_: guint,
    pub _bindgen_bitfield_9_: guint,
    pub _bindgen_bitfield_10_: guint,
    pub _bindgen_bitfield_11_: guint,
    pub _bindgen_bitfield_12_: guint,
    pub _bindgen_bitfield_13_: guint,
    pub _bindgen_bitfield_14_: guint,
    pub _bindgen_bitfield_15_: guint,
    pub _bindgen_bitfield_16_: guint,
    pub _bindgen_bitfield_17_: guint,
    pub _bindgen_bitfield_18_: guint,
    pub _bindgen_bitfield_19_: guint,
    pub _bindgen_bitfield_20_: guint,
    pub _bindgen_bitfield_21_: guint,
    pub _bindgen_bitfield_22_: guint,
    pub padding_dummy: guint,
}
impl ::std::default::Default for Struct__GScannerConfig {
    fn default() -> Struct__GScannerConfig { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
impl ::std::default::Default for Struct__GScanner {
    fn default() -> Struct__GScanner { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSequence { }
pub type GSequence = Struct__GSequence;
pub enum Struct__GSequenceNode { }
pub type GSequenceIter = Struct__GSequenceNode;
pub type GSequenceIterCompareFunc =
    ::std::option::Option<extern "C" fn
                              (a: *mut GSequenceIter, b: *mut GSequenceIter,
                               data: gpointer) -> gint>;
pub type Enum_Unnamed79 = ::libc::c_uint;
pub const G_SHELL_ERROR_BAD_QUOTING: ::libc::c_uint = 0;
pub const G_SHELL_ERROR_EMPTY_STRING: ::libc::c_uint = 1;
pub const G_SHELL_ERROR_FAILED: ::libc::c_uint = 2;
pub type GShellError = Enum_Unnamed79;
pub type Enum_Unnamed80 = ::libc::c_uint;
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: ::libc::c_uint = 1;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: ::libc::c_uint = 2;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: ::libc::c_uint = 3;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: ::libc::c_uint = 4;
pub const G_SLICE_CONFIG_CHUNK_SIZES: ::libc::c_uint = 5;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: ::libc::c_uint = 6;
pub type GSliceConfig = Enum_Unnamed80;
pub type Enum_Unnamed81 = ::libc::c_uint;
pub const G_SPAWN_ERROR_FORK: ::libc::c_uint = 0;
pub const G_SPAWN_ERROR_READ: ::libc::c_uint = 1;
pub const G_SPAWN_ERROR_CHDIR: ::libc::c_uint = 2;
pub const G_SPAWN_ERROR_ACCES: ::libc::c_uint = 3;
pub const G_SPAWN_ERROR_PERM: ::libc::c_uint = 4;
pub const G_SPAWN_ERROR_TOO_BIG: ::libc::c_uint = 5;
pub const G_SPAWN_ERROR_2BIG: ::libc::c_uint = 5;
pub const G_SPAWN_ERROR_NOEXEC: ::libc::c_uint = 6;
pub const G_SPAWN_ERROR_NAMETOOLONG: ::libc::c_uint = 7;
pub const G_SPAWN_ERROR_NOENT: ::libc::c_uint = 8;
pub const G_SPAWN_ERROR_NOMEM: ::libc::c_uint = 9;
pub const G_SPAWN_ERROR_NOTDIR: ::libc::c_uint = 10;
pub const G_SPAWN_ERROR_LOOP: ::libc::c_uint = 11;
pub const G_SPAWN_ERROR_TXTBUSY: ::libc::c_uint = 12;
pub const G_SPAWN_ERROR_IO: ::libc::c_uint = 13;
pub const G_SPAWN_ERROR_NFILE: ::libc::c_uint = 14;
pub const G_SPAWN_ERROR_MFILE: ::libc::c_uint = 15;
pub const G_SPAWN_ERROR_INVAL: ::libc::c_uint = 16;
pub const G_SPAWN_ERROR_ISDIR: ::libc::c_uint = 17;
pub const G_SPAWN_ERROR_LIBBAD: ::libc::c_uint = 18;
pub const G_SPAWN_ERROR_FAILED: ::libc::c_uint = 19;
pub type GSpawnError = Enum_Unnamed81;
pub type GSpawnChildSetupFunc =
    ::std::option::Option<extern "C" fn(user_data: gpointer)>;
pub type Enum_Unnamed82 = ::libc::c_uint;
pub const G_SPAWN_DEFAULT: ::libc::c_uint = 0;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN: ::libc::c_uint = 1;
pub const G_SPAWN_DO_NOT_REAP_CHILD: ::libc::c_uint = 2;
pub const G_SPAWN_SEARCH_PATH: ::libc::c_uint = 4;
pub const G_SPAWN_STDOUT_TO_DEV_NULL: ::libc::c_uint = 8;
pub const G_SPAWN_STDERR_TO_DEV_NULL: ::libc::c_uint = 16;
pub const G_SPAWN_CHILD_INHERITS_STDIN: ::libc::c_uint = 32;
pub const G_SPAWN_FILE_AND_ARGV_ZERO: ::libc::c_uint = 64;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP: ::libc::c_uint = 128;
pub const G_SPAWN_CLOEXEC_PIPES: ::libc::c_uint = 256;
pub type GSpawnFlags = Enum_Unnamed82;
pub type Enum_Unnamed83 = ::libc::c_uint;
pub const G_ASCII_ALNUM: ::libc::c_uint = 1;
pub const G_ASCII_ALPHA: ::libc::c_uint = 2;
pub const G_ASCII_CNTRL: ::libc::c_uint = 4;
pub const G_ASCII_DIGIT: ::libc::c_uint = 8;
pub const G_ASCII_GRAPH: ::libc::c_uint = 16;
pub const G_ASCII_LOWER: ::libc::c_uint = 32;
pub const G_ASCII_PRINT: ::libc::c_uint = 64;
pub const G_ASCII_PUNCT: ::libc::c_uint = 128;
pub const G_ASCII_SPACE: ::libc::c_uint = 256;
pub const G_ASCII_UPPER: ::libc::c_uint = 512;
pub const G_ASCII_XDIGIT: ::libc::c_uint = 1024;
pub type GAsciiType = Enum_Unnamed83;
pub enum Struct__GStringChunk { }
pub type GStringChunk = Struct__GStringChunk;
pub enum Struct_GTestCase { }
pub type GTestCase = Struct_GTestCase;
pub enum Struct_GTestSuite { }
pub type GTestSuite = Struct_GTestSuite;
pub type GTestFunc = ::std::option::Option<extern "C" fn()>;
pub type GTestDataFunc =
    ::std::option::Option<extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<extern "C" fn
                              (fixture: gpointer, user_data: gconstpointer)>;
pub type Enum_Unnamed84 = ::libc::c_uint;
pub const G_TEST_TRAP_SILENCE_STDOUT: ::libc::c_uint = 128;
pub const G_TEST_TRAP_SILENCE_STDERR: ::libc::c_uint = 256;
pub const G_TEST_TRAP_INHERIT_STDIN: ::libc::c_uint = 512;
pub type GTestTrapFlags = Enum_Unnamed84;
pub type Enum_Unnamed85 = ::libc::c_uint;
pub const G_TEST_SUBPROCESS_INHERIT_STDIN: ::libc::c_uint = 1;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT: ::libc::c_uint = 2;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR: ::libc::c_uint = 4;
pub type GTestSubprocessFlags = Enum_Unnamed85;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed86 {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
impl ::std::default::Default for Struct_Unnamed86 {
    fn default() -> Struct_Unnamed86 { unsafe { ::std::mem::zeroed() } }
}
pub type GTestConfig = Struct_Unnamed86;
pub type Enum_Unnamed87 = ::libc::c_uint;
pub const G_TEST_LOG_NONE: ::libc::c_uint = 0;
pub const G_TEST_LOG_ERROR: ::libc::c_uint = 1;
pub const G_TEST_LOG_START_BINARY: ::libc::c_uint = 2;
pub const G_TEST_LOG_LIST_CASE: ::libc::c_uint = 3;
pub const G_TEST_LOG_SKIP_CASE: ::libc::c_uint = 4;
pub const G_TEST_LOG_START_CASE: ::libc::c_uint = 5;
pub const G_TEST_LOG_STOP_CASE: ::libc::c_uint = 6;
pub const G_TEST_LOG_MIN_RESULT: ::libc::c_uint = 7;
pub const G_TEST_LOG_MAX_RESULT: ::libc::c_uint = 8;
pub const G_TEST_LOG_MESSAGE: ::libc::c_uint = 9;
pub const G_TEST_LOG_START_SUITE: ::libc::c_uint = 10;
pub const G_TEST_LOG_STOP_SUITE: ::libc::c_uint = 11;
pub type GTestLogType = Enum_Unnamed87;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed88 {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut ::libc::c_double,
}
impl ::std::default::Default for Struct_Unnamed88 {
    fn default() -> Struct_Unnamed88 { unsafe { ::std::mem::zeroed() } }
}
pub type GTestLogMsg = Struct_Unnamed88;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed89 {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
impl ::std::default::Default for Struct_Unnamed89 {
    fn default() -> Struct_Unnamed89 { unsafe { ::std::mem::zeroed() } }
}
pub type GTestLogBuffer = Struct_Unnamed89;
pub type GTestLogFatalFunc =
    ::std::option::Option<extern "C" fn
                              (log_domain: *const gchar,
                               log_level: GLogLevelFlags,
                               message: *const gchar, user_data: gpointer)
                              -> gboolean>;
pub type Enum_Unnamed90 = ::libc::c_uint;
pub const G_TEST_DIST: ::libc::c_uint = 0;
pub const G_TEST_BUILT: ::libc::c_uint = 1;
pub type GTestFileType = Enum_Unnamed90;
pub type GThreadPool = Struct__GThreadPool;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
impl ::std::default::Default for Struct__GThreadPool {
    fn default() -> Struct__GThreadPool { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTimer { }
pub type GTimer = Struct__GTimer;
pub type GTrashStack = Struct__GTrashStack;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTrashStack {
    pub next: *mut GTrashStack,
}
impl ::std::default::Default for Struct__GTrashStack {
    fn default() -> Struct__GTrashStack { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTree { }
pub type GTree = Struct__GTree;
pub type GTraverseFunc =
    ::std::option::Option<extern "C" fn
                              (key: gpointer, value: gpointer, data: gpointer)
                              -> gboolean>;
pub enum Struct__GVariantType { }
pub type GVariantType = Struct__GVariantType;
pub enum Struct__GVariant { }
pub type GVariant = Struct__GVariant;
pub type Enum_Unnamed91 = ::libc::c_uint;
pub const G_VARIANT_CLASS_BOOLEAN: ::libc::c_uint = 98;
pub const G_VARIANT_CLASS_BYTE: ::libc::c_uint = 121;
pub const G_VARIANT_CLASS_INT16: ::libc::c_uint = 110;
pub const G_VARIANT_CLASS_UINT16: ::libc::c_uint = 113;
pub const G_VARIANT_CLASS_INT32: ::libc::c_uint = 105;
pub const G_VARIANT_CLASS_UINT32: ::libc::c_uint = 117;
pub const G_VARIANT_CLASS_INT64: ::libc::c_uint = 120;
pub const G_VARIANT_CLASS_UINT64: ::libc::c_uint = 116;
pub const G_VARIANT_CLASS_HANDLE: ::libc::c_uint = 104;
pub const G_VARIANT_CLASS_DOUBLE: ::libc::c_uint = 100;
pub const G_VARIANT_CLASS_STRING: ::libc::c_uint = 115;
pub const G_VARIANT_CLASS_OBJECT_PATH: ::libc::c_uint = 111;
pub const G_VARIANT_CLASS_SIGNATURE: ::libc::c_uint = 103;
pub const G_VARIANT_CLASS_VARIANT: ::libc::c_uint = 118;
pub const G_VARIANT_CLASS_MAYBE: ::libc::c_uint = 109;
pub const G_VARIANT_CLASS_ARRAY: ::libc::c_uint = 97;
pub const G_VARIANT_CLASS_TUPLE: ::libc::c_uint = 40;
pub const G_VARIANT_CLASS_DICT_ENTRY: ::libc::c_uint = 123;
pub type GVariantClass = Enum_Unnamed91;
pub type GVariantIter = Struct__GVariantIter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVariantIter {
    pub x: [gsize; 16u],
}
impl ::std::default::Default for Struct__GVariantIter {
    fn default() -> Struct__GVariantIter { unsafe { ::std::mem::zeroed() } }
}
pub type GVariantBuilder = Struct__GVariantBuilder;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVariantBuilder {
    pub x: [gsize; 16u],
}
impl ::std::default::Default for Struct__GVariantBuilder {
    fn default() -> Struct__GVariantBuilder {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed92 = ::libc::c_uint;
pub const G_VARIANT_PARSE_ERROR_FAILED: ::libc::c_uint = 0;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: ::libc::c_uint = 1;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: ::libc::c_uint = 2;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: ::libc::c_uint = 3;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: ::libc::c_uint = 4;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: ::libc::c_uint = 5;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: ::libc::c_uint = 6;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: ::libc::c_uint = 7;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: ::libc::c_uint = 8;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: ::libc::c_uint = 9;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: ::libc::c_uint = 10;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: ::libc::c_uint = 11;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: ::libc::c_uint = 12;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: ::libc::c_uint = 13;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: ::libc::c_uint = 14;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: ::libc::c_uint = 15;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: ::libc::c_uint =
    16;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: ::libc::c_uint = 17;
pub type GVariantParseError = Enum_Unnamed92;
pub type GVariantDict = Struct__GVariantDict;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVariantDict {
    pub x: [gsize; 16u],
}
impl ::std::default::Default for Struct__GVariantDict {
    fn default() -> Struct__GVariantDict { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GAllocator { }
pub type GAllocator = Struct__GAllocator;
pub enum Struct__GMemChunk { }
pub type GMemChunk = Struct__GMemChunk;
pub enum Struct__GCache { }
pub type GCache = Struct__GCache;
pub type GCacheNewFunc =
    ::std::option::Option<extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc =
    ::std::option::Option<extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc =
    ::std::option::Option<extern "C" fn(value: gpointer)>;
pub type GCompletion = Struct__GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc =
    ::std::option::Option<extern "C" fn
                              (s1: *const gchar, s2: *const gchar, n: gsize)
                              -> gint>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
impl ::std::default::Default for Struct__GCompletion {
    fn default() -> Struct__GCompletion { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GRelation { }
pub type GRelation = Struct__GRelation;
pub type GTuples = Struct__GTuples;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTuples {
    pub len: guint,
}
impl ::std::default::Default for Struct__GTuples {
    fn default() -> Struct__GTuples { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed93 = ::libc::c_uint;
pub const G_THREAD_PRIORITY_LOW: ::libc::c_uint = 0;
pub const G_THREAD_PRIORITY_NORMAL: ::libc::c_uint = 1;
pub const G_THREAD_PRIORITY_HIGH: ::libc::c_uint = 2;
pub const G_THREAD_PRIORITY_URGENT: ::libc::c_uint = 3;
pub type GThreadPriority = Enum_Unnamed93;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
impl ::std::default::Default for Struct__GThread {
    fn default() -> Struct__GThread { unsafe { ::std::mem::zeroed() } }
}
pub type GThreadFunctions = Struct__GThreadFunctions;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThreadFunctions {
    pub mutex_new: ::std::option::Option<extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<extern "C" fn(mutex: *mut GMutex)
                                                 -> gboolean>,
    pub mutex_unlock: ::std::option::Option<extern "C" fn
                                                (mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<extern "C" fn
                                                  (cond: *mut GCond)>,
    pub cond_wait: ::std::option::Option<extern "C" fn
                                             (cond: *mut GCond,
                                              mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<extern "C" fn
                                                   (cond: *mut GCond,
                                                    mutex: *mut GMutex,
                                                    end_time: *mut GTimeVal)
                                                   -> gboolean>,
    pub cond_free: ::std::option::Option<extern "C" fn(cond: *mut GCond)>,
    pub private_new: ::std::option::Option<extern "C" fn
                                               (destructor: GDestroyNotify)
                                               -> *mut GPrivate>,
    pub private_get: ::std::option::Option<extern "C" fn
                                               (private_key: *mut GPrivate)
                                               -> gpointer>,
    pub private_set: ::std::option::Option<extern "C" fn
                                               (private_key: *mut GPrivate,
                                                data: gpointer)>,
    pub thread_create: ::std::option::Option<extern "C" fn
                                                 (func: GThreadFunc,
                                                  data: gpointer,
                                                  stack_size: gulong,
                                                  joinable: gboolean,
                                                  bound: gboolean,
                                                  priority: GThreadPriority,
                                                  thread: gpointer,
                                                  error: *mut *mut GError)>,
    pub thread_yield: ::std::option::Option<extern "C" fn()>,
    pub thread_join: ::std::option::Option<extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<extern "C" fn()>,
    pub thread_set_priority: ::std::option::Option<extern "C" fn
                                                       (thread: gpointer,
                                                        priority:
                                                            GThreadPriority)>,
    pub thread_self: ::std::option::Option<extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<extern "C" fn
                                                (thread1: gpointer,
                                                 thread2: gpointer)
                                                -> gboolean>,
}
impl ::std::default::Default for Struct__GThreadFunctions {
    fn default() -> Struct__GThreadFunctions {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type _uint = ::libc::c_uint;
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_long;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulong;
pub type register_t = ::libc::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::default::Default for Struct_timeval {
    fn default() -> Struct_timeval { unsafe { ::std::mem::zeroed() } }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::libc::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed94 {
    pub __fds_bits: [__fd_mask; 16u],
}
impl ::std::default::Default for Struct_Unnamed94 {
    fn default() -> Struct_Unnamed94 { unsafe { ::std::mem::zeroed() } }
}
pub type fd_set = Struct_Unnamed94;
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sched_param {
    pub __sched_priority: ::libc::c_int,
}
impl ::std::default::Default for Struct_sched_param {
    fn default() -> Struct_sched_param { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sched_param {
    pub __sched_priority: ::libc::c_int,
}
impl ::std::default::Default for Struct___sched_param {
    fn default() -> Struct___sched_param { unsafe { ::std::mem::zeroed() } }
}
pub type __cpu_mask = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed95 {
    pub __bits: [__cpu_mask; 16u],
}
impl ::std::default::Default for Struct_Unnamed95 {
    fn default() -> Struct_Unnamed95 { unsafe { ::std::mem::zeroed() } }
}
pub type cpu_set_t = Struct_Unnamed95;
pub type __jmp_buf = [::libc::c_long; 8u];
pub type Enum_Unnamed96 = ::libc::c_uint;
pub const PTHREAD_CREATE_JOINABLE: ::libc::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: ::libc::c_uint = 1;
pub type Enum_Unnamed97 = ::libc::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: ::libc::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::libc::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::libc::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::libc::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: ::libc::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::libc::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::libc::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::libc::c_uint = 0;
pub type Enum_Unnamed98 = ::libc::c_uint;
pub const PTHREAD_MUTEX_STALLED: ::libc::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: ::libc::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: ::libc::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: ::libc::c_uint = 1;
pub type Enum_Unnamed99 = ::libc::c_uint;
pub const PTHREAD_PRIO_NONE: ::libc::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::libc::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::libc::c_uint = 2;
pub type Enum_Unnamed100 = ::libc::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::libc::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: ::libc::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::libc::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: ::libc::c_uint = 0;
pub type Enum_Unnamed101 = ::libc::c_uint;
pub const PTHREAD_INHERIT_SCHED: ::libc::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::libc::c_uint = 1;
pub type Enum_Unnamed102 = ::libc::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: ::libc::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: ::libc::c_uint = 1;
pub type Enum_Unnamed103 = ::libc::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: ::libc::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: ::libc::c_uint = 1;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<extern "C" fn
                                             (arg1: *mut ::libc::c_void)>,
    pub __arg: *mut ::libc::c_void,
    pub __canceltype: ::libc::c_int,
    pub __prev: *mut Struct__pthread_cleanup_buffer,
}
impl ::std::default::Default for Struct__pthread_cleanup_buffer {
    fn default() -> Struct__pthread_cleanup_buffer {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed104 = ::libc::c_uint;
pub const PTHREAD_CANCEL_ENABLE: ::libc::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: ::libc::c_uint = 1;
pub type Enum_Unnamed105 = ::libc::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: ::libc::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::libc::c_uint = 1;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed106 {
    pub __cancel_jmp_buf: [Struct_Unnamed107; 1u],
    pub __pad: [*mut ::libc::c_void; 4u],
}
impl ::std::default::Default for Struct_Unnamed106 {
    fn default() -> Struct_Unnamed106 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed107 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::libc::c_int,
}
impl ::std::default::Default for Struct_Unnamed107 {
    fn default() -> Struct_Unnamed107 { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_unwind_buf_t = Struct_Unnamed106;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<extern "C" fn
                                                    (arg1:
                                                         *mut ::libc::c_void)>,
    pub __cancel_arg: *mut ::libc::c_void,
    pub __do_it: ::libc::c_int,
    pub __cancel_type: ::libc::c_int,
}
impl ::std::default::Default for Struct___pthread_cleanup_frame {
    fn default() -> Struct___pthread_cleanup_frame {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct___jmp_buf_tag { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed108 {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
impl ::std::default::Default for Struct_Unnamed108 {
    fn default() -> Struct_Unnamed108 { unsafe { ::std::mem::zeroed() } }
}
pub type GStaticMutex = Struct_Unnamed108;
pub type GStaticRecMutex = Struct__GStaticRecMutex;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: Union_Unnamed109,
}
impl ::std::default::Default for Struct__GStaticRecMutex {
    fn default() -> Struct__GStaticRecMutex {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed109 {
    pub _bindgen_data_: [u64; 1u],
}
impl Union_Unnamed109 {
    pub unsafe fn owner(&mut self) -> *mut pthread_t {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn dummy(&mut self) -> *mut gdouble {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed109 {
    fn default() -> Union_Unnamed109 { unsafe { ::std::mem::zeroed() } }
}
pub type GStaticRWLock = Struct__GStaticRWLock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
impl ::std::default::Default for Struct__GStaticRWLock {
    fn default() -> Struct__GStaticRWLock { unsafe { ::std::mem::zeroed() } }
}
pub type GStaticPrivate = Struct__GStaticPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GStaticPrivate {
    pub index: guint,
}
impl ::std::default::Default for Struct__GStaticPrivate {
    fn default() -> Struct__GStaticPrivate { unsafe { ::std::mem::zeroed() } }
}
pub type GType = gsize;
pub type GValue = Struct__GValue;
pub enum Union__GTypeCValue { }
pub type GTypeCValue = Union__GTypeCValue;
pub enum Struct__GTypePlugin { }
pub type GTypePlugin = Struct__GTypePlugin;
pub type GTypeClass = Struct__GTypeClass;
pub type GTypeInterface = Struct__GTypeInterface;
pub type GTypeInstance = Struct__GTypeInstance;
pub type GTypeInfo = Struct__GTypeInfo;
pub type GTypeFundamentalInfo = Struct__GTypeFundamentalInfo;
pub type GInterfaceInfo = Struct__GInterfaceInfo;
pub type GTypeValueTable = Struct__GTypeValueTable;
pub type GTypeQuery = Struct__GTypeQuery;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeClass {
    pub g_type: GType,
}
impl ::std::default::Default for Struct__GTypeClass {
    fn default() -> Struct__GTypeClass { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeInstance {
    pub g_class: *mut GTypeClass,
}
impl ::std::default::Default for Struct__GTypeInstance {
    fn default() -> Struct__GTypeInstance { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
impl ::std::default::Default for Struct__GTypeInterface {
    fn default() -> Struct__GTypeInterface { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeQuery {
    pub _type: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
impl ::std::default::Default for Struct__GTypeQuery {
    fn default() -> Struct__GTypeQuery { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed110 = ::libc::c_uint;
pub const G_TYPE_DEBUG_NONE: ::libc::c_uint = 0;
pub const G_TYPE_DEBUG_OBJECTS: ::libc::c_uint = 1;
pub const G_TYPE_DEBUG_SIGNALS: ::libc::c_uint = 2;
pub const G_TYPE_DEBUG_MASK: ::libc::c_uint = 3;
pub type GTypeDebugFlags = Enum_Unnamed110;
pub type GBaseInitFunc =
    ::std::option::Option<extern "C" fn(g_class: gpointer)>;
pub type GBaseFinalizeFunc =
    ::std::option::Option<extern "C" fn(g_class: gpointer)>;
pub type GClassInitFunc =
    ::std::option::Option<extern "C" fn
                              (g_class: gpointer, class_data: gpointer)>;
pub type GClassFinalizeFunc =
    ::std::option::Option<extern "C" fn
                              (g_class: gpointer, class_data: gpointer)>;
pub type GInstanceInitFunc =
    ::std::option::Option<extern "C" fn
                              (instance: *mut GTypeInstance,
                               g_class: gpointer)>;
pub type GInterfaceInitFunc =
    ::std::option::Option<extern "C" fn
                              (g_iface: gpointer, iface_data: gpointer)>;
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<extern "C" fn
                              (g_iface: gpointer, iface_data: gpointer)>;
pub type GTypeClassCacheFunc =
    ::std::option::Option<extern "C" fn
                              (cache_data: gpointer, g_class: *mut GTypeClass)
                              -> gboolean>;
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<extern "C" fn
                              (check_data: gpointer, g_iface: gpointer)>;
pub type Enum_Unnamed111 = ::libc::c_uint;
pub const G_TYPE_FLAG_CLASSED: ::libc::c_uint = 1;
pub const G_TYPE_FLAG_INSTANTIATABLE: ::libc::c_uint = 2;
pub const G_TYPE_FLAG_DERIVABLE: ::libc::c_uint = 4;
pub const G_TYPE_FLAG_DEEP_DERIVABLE: ::libc::c_uint = 8;
pub type GTypeFundamentalFlags = Enum_Unnamed111;
pub type Enum_Unnamed112 = ::libc::c_uint;
pub const G_TYPE_FLAG_ABSTRACT: ::libc::c_uint = 16;
pub const G_TYPE_FLAG_VALUE_ABSTRACT: ::libc::c_uint = 32;
pub type GTypeFlags = Enum_Unnamed112;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
impl ::std::default::Default for Struct__GTypeInfo {
    fn default() -> Struct__GTypeInfo { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
impl ::std::default::Default for Struct__GTypeFundamentalInfo {
    fn default() -> Struct__GTypeFundamentalInfo {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
impl ::std::default::Default for Struct__GInterfaceInfo {
    fn default() -> Struct__GInterfaceInfo { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeValueTable {
    pub value_init: ::std::option::Option<extern "C" fn(value: *mut GValue)>,
    pub value_free: ::std::option::Option<extern "C" fn(value: *mut GValue)>,
    pub value_copy: ::std::option::Option<extern "C" fn
                                              (src_value: *const GValue,
                                               dest_value: *mut GValue)>,
    pub value_peek_pointer: ::std::option::Option<extern "C" fn
                                                      (value: *const GValue)
                                                      -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: ::std::option::Option<extern "C" fn
                                                 (value: *mut GValue,
                                                  n_collect_values: guint,
                                                  collect_values:
                                                      *mut GTypeCValue,
                                                  collect_flags: guint)
                                                 -> *mut gchar>,
    pub lcopy_format: *const gchar,
    pub lcopy_value: ::std::option::Option<extern "C" fn
                                               (value: *const GValue,
                                                n_collect_values: guint,
                                                collect_values:
                                                    *mut GTypeCValue,
                                                collect_flags: guint)
                                               -> *mut gchar>,
}
impl ::std::default::Default for Struct__GTypeValueTable {
    fn default() -> Struct__GTypeValueTable {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GValueTransform =
    ::std::option::Option<extern "C" fn
                              (src_value: *const GValue,
                               dest_value: *mut GValue)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GValue {
    pub g_type: GType,
    pub data: [Union_Unnamed113; 2u],
}
impl ::std::default::Default for Struct__GValue {
    fn default() -> Struct__GValue { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed113 {
    pub _bindgen_data_: [u64; 1u],
}
impl Union_Unnamed113 {
    pub unsafe fn v_int(&mut self) -> *mut gint {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_uint(&mut self) -> *mut guint {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_long(&mut self) -> *mut glong {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_ulong(&mut self) -> *mut gulong {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_int64(&mut self) -> *mut gint64 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_uint64(&mut self) -> *mut guint64 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_float(&mut self) -> *mut gfloat {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_double(&mut self) -> *mut gdouble {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn v_pointer(&mut self) -> *mut gpointer {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed113 {
    fn default() -> Union_Unnamed113 { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed114 = ::libc::c_int;
pub const G_PARAM_READABLE: ::libc::c_int = 1;
pub const G_PARAM_WRITABLE: ::libc::c_int = 2;
pub const G_PARAM_READWRITE: ::libc::c_int = 3;
pub const G_PARAM_CONSTRUCT: ::libc::c_int = 4;
pub const G_PARAM_CONSTRUCT_ONLY: ::libc::c_int = 8;
pub const G_PARAM_LAX_VALIDATION: ::libc::c_int = 16;
pub const G_PARAM_STATIC_NAME: ::libc::c_int = 32;
pub const G_PARAM_PRIVATE: ::libc::c_int = 32;
pub const G_PARAM_STATIC_NICK: ::libc::c_int = 64;
pub const G_PARAM_STATIC_BLURB: ::libc::c_int = 128;
pub const G_PARAM_EXPLICIT_NOTIFY: ::libc::c_int = 1073741824;
pub const G_PARAM_DEPRECATED: ::libc::c_int = -2147483648;
pub type GParamFlags = Enum_Unnamed114;
pub type GParamSpec = Struct__GParamSpec;
pub type GParamSpecClass = Struct__GParamSpecClass;
pub type GParameter = Struct__GParameter;
pub enum Struct__GParamSpecPool { }
pub type GParamSpecPool = Struct__GParamSpecPool;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
impl ::std::default::Default for Struct__GParamSpec {
    fn default() -> Struct__GParamSpec { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<extern "C" fn
                                            (pspec: *mut GParamSpec)>,
    pub value_set_default: ::std::option::Option<extern "C" fn
                                                     (pspec: *mut GParamSpec,
                                                      value: *mut GValue)>,
    pub value_validate: ::std::option::Option<extern "C" fn
                                                  (pspec: *mut GParamSpec,
                                                   value: *mut GValue)
                                                  -> gboolean>,
    pub values_cmp: ::std::option::Option<extern "C" fn
                                              (pspec: *mut GParamSpec,
                                               value1: *const GValue,
                                               value2: *const GValue)
                                              -> gint>,
    pub dummy: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GParamSpecClass {
    fn default() -> Struct__GParamSpecClass {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
impl ::std::default::Default for Struct__GParameter {
    fn default() -> Struct__GParameter { unsafe { ::std::mem::zeroed() } }
}
pub type GParamSpecTypeInfo = Struct__GParamSpecTypeInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<extern "C" fn
                                                 (pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<extern "C" fn
                                            (pspec: *mut GParamSpec)>,
    pub value_set_default: ::std::option::Option<extern "C" fn
                                                     (pspec: *mut GParamSpec,
                                                      value: *mut GValue)>,
    pub value_validate: ::std::option::Option<extern "C" fn
                                                  (pspec: *mut GParamSpec,
                                                   value: *mut GValue)
                                                  -> gboolean>,
    pub values_cmp: ::std::option::Option<extern "C" fn
                                              (pspec: *mut GParamSpec,
                                               value1: *const GValue,
                                               value2: *const GValue)
                                              -> gint>,
}
impl ::std::default::Default for Struct__GParamSpecTypeInfo {
    fn default() -> Struct__GParamSpecTypeInfo {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GClosure = Struct__GClosure;
pub type GClosureNotifyData = Struct__GClosureNotifyData;
pub type GCallback = ::std::option::Option<extern "C" fn()>;
pub type GClosureNotify =
    ::std::option::Option<extern "C" fn
                              (data: gpointer, closure: *mut GClosure)>;
pub type GClosureMarshal =
    ::std::option::Option<extern "C" fn
                              (closure: *mut GClosure,
                               return_value: *mut GValue,
                               n_param_values: guint,
                               param_values: *const GValue,
                               invocation_hint: gpointer,
                               marshal_data: gpointer)>;
pub type GVaClosureMarshal =
    ::std::option::Option<extern "C" fn
                              (closure: *mut GClosure,
                               return_value: *mut GValue, instance: gpointer,
                               args: va_list, marshal_data: gpointer,
                               n_params: ::libc::c_int,
                               param_types: *mut GType)>;
pub type GCClosure = Struct__GCClosure;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
impl ::std::default::Default for Struct__GClosureNotifyData {
    fn default() -> Struct__GClosureNotifyData {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GClosure {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
    pub _bindgen_bitfield_7_: guint,
    pub _bindgen_bitfield_8_: guint,
    pub _bindgen_bitfield_9_: guint,
    pub _bindgen_bitfield_10_: guint,
    pub marshal: ::std::option::Option<extern "C" fn
                                           (closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            n_param_values: guint,
                                            param_values: *const GValue,
                                            invocation_hint: gpointer,
                                            marshal_data: gpointer)>,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
impl ::std::default::Default for Struct__GClosure {
    fn default() -> Struct__GClosure { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
impl ::std::default::Default for Struct__GCClosure {
    fn default() -> Struct__GCClosure { unsafe { ::std::mem::zeroed() } }
}
pub type GSignalQuery = Struct__GSignalQuery;
pub type GSignalInvocationHint = Struct__GSignalInvocationHint;
pub type GSignalCMarshaller = GClosureMarshal;
pub type GSignalCVaMarshaller = GVaClosureMarshal;
pub type GSignalEmissionHook =
    ::std::option::Option<extern "C" fn
                              (ihint: *mut GSignalInvocationHint,
                               n_param_values: guint,
                               param_values: *const GValue, data: gpointer)
                              -> gboolean>;
pub type GSignalAccumulator =
    ::std::option::Option<extern "C" fn
                              (ihint: *mut GSignalInvocationHint,
                               return_accu: *mut GValue,
                               handler_return: *const GValue, data: gpointer)
                              -> gboolean>;
pub type Enum_Unnamed115 = ::libc::c_uint;
pub const G_SIGNAL_RUN_FIRST: ::libc::c_uint = 1;
pub const G_SIGNAL_RUN_LAST: ::libc::c_uint = 2;
pub const G_SIGNAL_RUN_CLEANUP: ::libc::c_uint = 4;
pub const G_SIGNAL_NO_RECURSE: ::libc::c_uint = 8;
pub const G_SIGNAL_DETAILED: ::libc::c_uint = 16;
pub const G_SIGNAL_ACTION: ::libc::c_uint = 32;
pub const G_SIGNAL_NO_HOOKS: ::libc::c_uint = 64;
pub const G_SIGNAL_MUST_COLLECT: ::libc::c_uint = 128;
pub const G_SIGNAL_DEPRECATED: ::libc::c_uint = 256;
pub type GSignalFlags = Enum_Unnamed115;
pub type Enum_Unnamed116 = ::libc::c_uint;
pub const G_CONNECT_AFTER: ::libc::c_uint = 1;
pub const G_CONNECT_SWAPPED: ::libc::c_uint = 2;
pub type GConnectFlags = Enum_Unnamed116;
pub type Enum_Unnamed117 = ::libc::c_uint;
pub const G_SIGNAL_MATCH_ID: ::libc::c_uint = 1;
pub const G_SIGNAL_MATCH_DETAIL: ::libc::c_uint = 2;
pub const G_SIGNAL_MATCH_CLOSURE: ::libc::c_uint = 4;
pub const G_SIGNAL_MATCH_FUNC: ::libc::c_uint = 8;
pub const G_SIGNAL_MATCH_DATA: ::libc::c_uint = 16;
pub const G_SIGNAL_MATCH_UNBLOCKED: ::libc::c_uint = 32;
pub type GSignalMatchType = Enum_Unnamed117;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
impl ::std::default::Default for Struct__GSignalInvocationHint {
    fn default() -> Struct__GSignalInvocationHint {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
impl ::std::default::Default for Struct__GSignalQuery {
    fn default() -> Struct__GSignalQuery { unsafe { ::std::mem::zeroed() } }
}
pub type GStrv = *mut *mut gchar;
pub type GBoxedCopyFunc =
    ::std::option::Option<extern "C" fn(boxed: gpointer) -> gpointer>;
pub type GBoxedFreeFunc =
    ::std::option::Option<extern "C" fn(boxed: gpointer)>;
pub type GObject = Struct__GObject;
pub type GObjectClass = Struct__GObjectClass;
pub type GInitiallyUnowned = Struct__GObject;
pub type GInitiallyUnownedClass = Struct__GObjectClass;
pub type GObjectConstructParam = Struct__GObjectConstructParam;
pub type GObjectGetPropertyFunc =
    ::std::option::Option<extern "C" fn
                              (object: *mut GObject, property_id: guint,
                               value: *mut GValue, pspec: *mut GParamSpec)>;
pub type GObjectSetPropertyFunc =
    ::std::option::Option<extern "C" fn
                              (object: *mut GObject, property_id: guint,
                               value: *const GValue, pspec: *mut GParamSpec)>;
pub type GObjectFinalizeFunc =
    ::std::option::Option<extern "C" fn(object: *mut GObject)>;
pub type GWeakNotify =
    ::std::option::Option<extern "C" fn
                              (data: gpointer,
                               where_the_object_was: *mut GObject)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
impl ::std::default::Default for Struct__GObject {
    fn default() -> Struct__GObject { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<extern "C" fn
                                               (_type: GType,
                                                n_construct_properties: guint,
                                                construct_properties:
                                                    *mut GObjectConstructParam)
                                               -> *mut GObject>,
    pub set_property: ::std::option::Option<extern "C" fn
                                                (object: *mut GObject,
                                                 property_id: guint,
                                                 value: *const GValue,
                                                 pspec: *mut GParamSpec)>,
    pub get_property: ::std::option::Option<extern "C" fn
                                                (object: *mut GObject,
                                                 property_id: guint,
                                                 value: *mut GValue,
                                                 pspec: *mut GParamSpec)>,
    pub dispose: ::std::option::Option<extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<extern "C" fn
                                                               (object:
                                                                    *mut GObject,
                                                                n_pspecs:
                                                                    guint,
                                                                pspecs:
                                                                    *mut *mut GParamSpec)>,
    pub notify: ::std::option::Option<extern "C" fn
                                          (object: *mut GObject,
                                           pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<extern "C" fn
                                               (object: *mut GObject)>,
    pub flags: gsize,
    pub pdummy: [gpointer; 6u],
}
impl ::std::default::Default for Struct__GObjectClass {
    fn default() -> Struct__GObjectClass { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
impl ::std::default::Default for Struct__GObjectConstructParam {
    fn default() -> Struct__GObjectConstructParam {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GToggleNotify =
    ::std::option::Option<extern "C" fn
                              (data: gpointer, object: *mut GObject,
                               is_last_ref: gboolean)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed118 {
    pub _priv: Union_Unnamed119,
}
impl ::std::default::Default for Struct_Unnamed118 {
    fn default() -> Struct_Unnamed118 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed119 {
    pub _bindgen_data_: [u64; 1u],
}
impl Union_Unnamed119 {
    pub unsafe fn p(&mut self) -> *mut gpointer {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed119 {
    fn default() -> Union_Unnamed119 { unsafe { ::std::mem::zeroed() } }
}
pub type GWeakRef = Struct_Unnamed118;
pub enum Struct__GBinding { }
pub type GBinding = Struct__GBinding;
pub type GBindingTransformFunc =
    ::std::option::Option<extern "C" fn
                              (binding: *mut GBinding,
                               from_value: *const GValue,
                               to_value: *mut GValue, user_data: gpointer)
                              -> gboolean>;
pub type Enum_Unnamed120 = ::libc::c_uint;
pub const G_BINDING_DEFAULT: ::libc::c_uint = 0;
pub const G_BINDING_BIDIRECTIONAL: ::libc::c_uint = 1;
pub const G_BINDING_SYNC_CREATE: ::libc::c_uint = 2;
pub const G_BINDING_INVERT_BOOLEAN: ::libc::c_uint = 4;
pub type GBindingFlags = Enum_Unnamed120;
pub type GEnumClass = Struct__GEnumClass;
pub type GFlagsClass = Struct__GFlagsClass;
pub type GEnumValue = Struct__GEnumValue;
pub type GFlagsValue = Struct__GFlagsValue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
impl ::std::default::Default for Struct__GEnumClass {
    fn default() -> Struct__GEnumClass { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
impl ::std::default::Default for Struct__GFlagsClass {
    fn default() -> Struct__GFlagsClass { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
impl ::std::default::Default for Struct__GEnumValue {
    fn default() -> Struct__GEnumValue { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
impl ::std::default::Default for Struct__GFlagsValue {
    fn default() -> Struct__GFlagsValue { unsafe { ::std::mem::zeroed() } }
}
pub type GParamSpecChar = Struct__GParamSpecChar;
pub type GParamSpecUChar = Struct__GParamSpecUChar;
pub type GParamSpecBoolean = Struct__GParamSpecBoolean;
pub type GParamSpecInt = Struct__GParamSpecInt;
pub type GParamSpecUInt = Struct__GParamSpecUInt;
pub type GParamSpecLong = Struct__GParamSpecLong;
pub type GParamSpecULong = Struct__GParamSpecULong;
pub type GParamSpecInt64 = Struct__GParamSpecInt64;
pub type GParamSpecUInt64 = Struct__GParamSpecUInt64;
pub type GParamSpecUnichar = Struct__GParamSpecUnichar;
pub type GParamSpecEnum = Struct__GParamSpecEnum;
pub type GParamSpecFlags = Struct__GParamSpecFlags;
pub type GParamSpecFloat = Struct__GParamSpecFloat;
pub type GParamSpecDouble = Struct__GParamSpecDouble;
pub type GParamSpecString = Struct__GParamSpecString;
pub type GParamSpecParam = Struct__GParamSpecParam;
pub type GParamSpecBoxed = Struct__GParamSpecBoxed;
pub type GParamSpecPointer = Struct__GParamSpecPointer;
pub type GParamSpecValueArray = Struct__GParamSpecValueArray;
pub type GParamSpecObject = Struct__GParamSpecObject;
pub type GParamSpecOverride = Struct__GParamSpecOverride;
pub type GParamSpecGType = Struct__GParamSpecGType;
pub type GParamSpecVariant = Struct__GParamSpecVariant;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
impl ::std::default::Default for Struct__GParamSpecChar {
    fn default() -> Struct__GParamSpecChar { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
impl ::std::default::Default for Struct__GParamSpecUChar {
    fn default() -> Struct__GParamSpecUChar {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
impl ::std::default::Default for Struct__GParamSpecBoolean {
    fn default() -> Struct__GParamSpecBoolean {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
impl ::std::default::Default for Struct__GParamSpecInt {
    fn default() -> Struct__GParamSpecInt { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
impl ::std::default::Default for Struct__GParamSpecUInt {
    fn default() -> Struct__GParamSpecUInt { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
impl ::std::default::Default for Struct__GParamSpecLong {
    fn default() -> Struct__GParamSpecLong { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
impl ::std::default::Default for Struct__GParamSpecULong {
    fn default() -> Struct__GParamSpecULong {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
impl ::std::default::Default for Struct__GParamSpecInt64 {
    fn default() -> Struct__GParamSpecInt64 {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
impl ::std::default::Default for Struct__GParamSpecUInt64 {
    fn default() -> Struct__GParamSpecUInt64 {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
impl ::std::default::Default for Struct__GParamSpecUnichar {
    fn default() -> Struct__GParamSpecUnichar {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
impl ::std::default::Default for Struct__GParamSpecEnum {
    fn default() -> Struct__GParamSpecEnum { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
impl ::std::default::Default for Struct__GParamSpecFlags {
    fn default() -> Struct__GParamSpecFlags {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
impl ::std::default::Default for Struct__GParamSpecFloat {
    fn default() -> Struct__GParamSpecFloat {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
impl ::std::default::Default for Struct__GParamSpecDouble {
    fn default() -> Struct__GParamSpecDouble {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
}
impl ::std::default::Default for Struct__GParamSpecString {
    fn default() -> Struct__GParamSpecString {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecParam {
    pub parent_instance: GParamSpec,
}
impl ::std::default::Default for Struct__GParamSpecParam {
    fn default() -> Struct__GParamSpecParam {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
impl ::std::default::Default for Struct__GParamSpecBoxed {
    fn default() -> Struct__GParamSpecBoxed {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
impl ::std::default::Default for Struct__GParamSpecPointer {
    fn default() -> Struct__GParamSpecPointer {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
impl ::std::default::Default for Struct__GParamSpecValueArray {
    fn default() -> Struct__GParamSpecValueArray {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecObject {
    pub parent_instance: GParamSpec,
}
impl ::std::default::Default for Struct__GParamSpecObject {
    fn default() -> Struct__GParamSpecObject {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
impl ::std::default::Default for Struct__GParamSpecOverride {
    fn default() -> Struct__GParamSpecOverride {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
impl ::std::default::Default for Struct__GParamSpecGType {
    fn default() -> Struct__GParamSpecGType {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub _type: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GParamSpecVariant {
    fn default() -> Struct__GParamSpecVariant {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GTypeModule = Struct__GTypeModule;
pub type GTypeModuleClass = Struct__GTypeModuleClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
impl ::std::default::Default for Struct__GTypeModule {
    fn default() -> Struct__GTypeModule { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<extern "C" fn(module: *mut GTypeModule)
                                        -> gboolean>,
    pub unload: ::std::option::Option<extern "C" fn
                                          (module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<extern "C" fn()>,
    pub reserved2: ::std::option::Option<extern "C" fn()>,
    pub reserved3: ::std::option::Option<extern "C" fn()>,
    pub reserved4: ::std::option::Option<extern "C" fn()>,
}
impl ::std::default::Default for Struct__GTypeModuleClass {
    fn default() -> Struct__GTypeModuleClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GTypePluginClass = Struct__GTypePluginClass;
pub type GTypePluginUse =
    ::std::option::Option<extern "C" fn(plugin: *mut GTypePlugin)>;
pub type GTypePluginUnuse =
    ::std::option::Option<extern "C" fn(plugin: *mut GTypePlugin)>;
pub type GTypePluginCompleteTypeInfo =
    ::std::option::Option<extern "C" fn
                              (plugin: *mut GTypePlugin, g_type: GType,
                               info: *mut GTypeInfo,
                               value_table: *mut GTypeValueTable)>;
pub type GTypePluginCompleteInterfaceInfo =
    ::std::option::Option<extern "C" fn
                              (plugin: *mut GTypePlugin, instance_type: GType,
                               interface_type: GType,
                               info: *mut GInterfaceInfo)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
impl ::std::default::Default for Struct__GTypePluginClass {
    fn default() -> Struct__GTypePluginClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GValueArray = Struct__GValueArray;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
impl ::std::default::Default for Struct__GValueArray {
    fn default() -> Struct__GValueArray { unsafe { ::std::mem::zeroed() } }
}
pub type gchararray = *mut gchar;
pub enum Struct__GstAtomicQueue { }
pub type GstAtomicQueue = Struct__GstAtomicQueue;
pub type GstElement = Struct__GstElement;
pub type GstElementClass = Struct__GstElementClass;
#[repr(C)]
#[derive(Copy,Debug)]
pub enum GstState{
	GST_STATE_VOID_PENDING = 0,
	GST_STATE_NULL = 1,
	GST_STATE_READY = 2,
	GST_STATE_PAUSED = 3,
	GST_STATE_PLAYING = 4,
}
/*pub type Enum_Unnamed121 = ::libc::c_uint;
pub const GST_STATE_VOID_PENDING: ::libc::c_uint = 0;
pub const GST_STATE_NULL: ::libc::c_uint = 1;
pub const GST_STATE_READY: ::libc::c_uint = 2;
pub const GST_STATE_PAUSED: ::libc::c_uint = 3;
pub const GST_STATE_PLAYING: ::libc::c_uint = 4;
pub type GstState = Enum_Unnamed121;*/
pub type Enum_Unnamed122 = ::libc::c_uint;
pub const GST_OBJECT_FLAG_LAST: ::libc::c_uint = 16;
pub type GstObjectFlags = Enum_Unnamed122;
pub type GstObject = Struct__GstObject;
pub type GstObjectClass = Struct__GstObjectClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstObject {
    pub object: GInitiallyUnowned,
    pub lock: GMutex,
    pub name: *mut gchar,
    pub parent: *mut GstObject,
    pub flags: guint32,
    pub control_bindings: *mut GList,
    pub control_rate: guint64,
    pub last_sync: guint64,
    pub _gst_reserved: gpointer,
}
impl ::std::default::Default for Struct__GstObject {
    fn default() -> Struct__GstObject { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstObjectClass {
    pub parent_class: GInitiallyUnownedClass,
    pub path_string_separator: *const gchar,
    pub deep_notify: ::std::option::Option<extern "C" fn
                                               (object: *mut GstObject,
                                                orig: *mut GstObject,
                                                pspec: *mut GParamSpec)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstObjectClass {
    fn default() -> Struct__GstObjectClass { unsafe { ::std::mem::zeroed() } }
}
pub type GstClockTime = guint64;
pub type GstClockTimeDiff = gint64;
pub type GstClockID = gpointer;
pub type GstClockEntry = Struct__GstClockEntry;
pub type GstClock = Struct__GstClock;
pub type GstClockClass = Struct__GstClockClass;
pub enum Struct__GstClockPrivate { }
pub type GstClockPrivate = Struct__GstClockPrivate;
pub type GstClockCallback =
    ::std::option::Option<extern "C" fn
                              (clock: *mut GstClock, time: GstClockTime,
                               id: GstClockID, user_data: gpointer)
                              -> gboolean>;
pub type Enum_Unnamed123 = ::libc::c_uint;
pub const GST_CLOCK_OK: ::libc::c_uint = 0;
pub const GST_CLOCK_EARLY: ::libc::c_uint = 1;
pub const GST_CLOCK_UNSCHEDULED: ::libc::c_uint = 2;
pub const GST_CLOCK_BUSY: ::libc::c_uint = 3;
pub const GST_CLOCK_BADTIME: ::libc::c_uint = 4;
pub const GST_CLOCK_ERROR: ::libc::c_uint = 5;
pub const GST_CLOCK_UNSUPPORTED: ::libc::c_uint = 6;
pub const GST_CLOCK_DONE: ::libc::c_uint = 7;
pub type GstClockReturn = Enum_Unnamed123;
pub type Enum_Unnamed124 = ::libc::c_uint;
pub const GST_CLOCK_ENTRY_SINGLE: ::libc::c_uint = 0;
pub const GST_CLOCK_ENTRY_PERIODIC: ::libc::c_uint = 1;
pub type GstClockEntryType = Enum_Unnamed124;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstClockEntry {
    pub refcount: gint,
    pub clock: *mut GstClock,
    pub _type: GstClockEntryType,
    pub time: GstClockTime,
    pub interval: GstClockTime,
    pub status: GstClockReturn,
    pub func: GstClockCallback,
    pub user_data: gpointer,
    pub destroy_data: GDestroyNotify,
    pub unscheduled: gboolean,
    pub woken_up: gboolean,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstClockEntry {
    fn default() -> Struct__GstClockEntry { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed125 = ::libc::c_uint;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: ::libc::c_uint = 16;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: ::libc::c_uint = 32;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: ::libc::c_uint = 64;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: ::libc::c_uint = 128;
pub const GST_CLOCK_FLAG_CAN_SET_RESOLUTION: ::libc::c_uint = 256;
pub const GST_CLOCK_FLAG_CAN_SET_MASTER: ::libc::c_uint = 512;
pub const GST_CLOCK_FLAG_LAST: ::libc::c_uint = 4096;
pub type GstClockFlags = Enum_Unnamed125;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstClock {
    pub object: GstObject,
    pub _priv: *mut GstClockPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstClock {
    fn default() -> Struct__GstClock { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstClockClass {
    pub parent_class: GstObjectClass,
    pub change_resolution: ::std::option::Option<extern "C" fn
                                                     (clock: *mut GstClock,
                                                      old_resolution:
                                                          GstClockTime,
                                                      new_resolution:
                                                          GstClockTime)
                                                     -> GstClockTime>,
    pub get_resolution: ::std::option::Option<extern "C" fn
                                                  (clock: *mut GstClock)
                                                  -> GstClockTime>,
    pub get_internal_time: ::std::option::Option<extern "C" fn
                                                     (clock: *mut GstClock)
                                                     -> GstClockTime>,
    pub wait: ::std::option::Option<extern "C" fn
                                        (clock: *mut GstClock,
                                         entry: *mut GstClockEntry,
                                         jitter: *mut GstClockTimeDiff)
                                        -> GstClockReturn>,
    pub wait_async: ::std::option::Option<extern "C" fn
                                              (clock: *mut GstClock,
                                               entry: *mut GstClockEntry)
                                              -> GstClockReturn>,
    pub unschedule: ::std::option::Option<extern "C" fn
                                              (clock: *mut GstClock,
                                               entry: *mut GstClockEntry)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstClockClass {
    fn default() -> Struct__GstClockClass { unsafe { ::std::mem::zeroed() } }
}
pub type GstControlSource = Struct__GstControlSource;
pub type GstControlSourceClass = Struct__GstControlSourceClass;
pub type GstTimedValue = Struct__GstTimedValue;
pub enum Struct__GstValueArray { }
pub type GstValueArray = Struct__GstValueArray;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTimedValue {
    pub timestamp: GstClockTime,
    pub value: gdouble,
}
impl ::std::default::Default for Struct__GstTimedValue {
    fn default() -> Struct__GstTimedValue { unsafe { ::std::mem::zeroed() } }
}
pub type GstControlSourceGetValue =
    ::std::option::Option<extern "C" fn
                              (_self: *mut GstControlSource,
                               timestamp: GstClockTime, value: *mut gdouble)
                              -> gboolean>;
pub type GstControlSourceGetValueArray =
    ::std::option::Option<extern "C" fn
                              (_self: *mut GstControlSource,
                               timestamp: GstClockTime,
                               interval: GstClockTime, n_values: guint,
                               values: *mut gdouble) -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstControlSource {
    pub parent: GstObject,
    pub get_value: GstControlSourceGetValue,
    pub get_value_array: GstControlSourceGetValueArray,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstControlSource {
    fn default() -> Struct__GstControlSource {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstControlSourceClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstControlSourceClass {
    fn default() -> Struct__GstControlSourceClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstControlBinding = Struct__GstControlBinding;
pub type GstControlBindingClass = Struct__GstControlBindingClass;
pub type GstControlBindingConvert =
    ::std::option::Option<extern "C" fn
                              (binding: *mut GstControlBinding,
                               src_value: gdouble, dest_value: *mut GValue)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstControlBinding {
    pub parent: GstObject,
    pub name: *mut gchar,
    pub pspec: *mut GParamSpec,
    pub object: *mut GstObject,
    pub disabled: gboolean,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstControlBinding {
    fn default() -> Struct__GstControlBinding {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstControlBindingClass {
    pub parent_class: GstObjectClass,
    pub sync_values: ::std::option::Option<extern "C" fn
                                               (binding:
                                                    *mut GstControlBinding,
                                                object: *mut GstObject,
                                                timestamp: GstClockTime,
                                                last_sync: GstClockTime)
                                               -> gboolean>,
    pub get_value: ::std::option::Option<extern "C" fn
                                             (binding: *mut GstControlBinding,
                                              timestamp: GstClockTime)
                                             -> *mut GValue>,
    pub get_value_array: ::std::option::Option<extern "C" fn
                                                   (binding:
                                                        *mut GstControlBinding,
                                                    timestamp: GstClockTime,
                                                    interval: GstClockTime,
                                                    n_values: guint,
                                                    values: gpointer)
                                                   -> gboolean>,
    pub get_g_value_array: ::std::option::Option<extern "C" fn
                                                     (binding:
                                                          *mut GstControlBinding,
                                                      timestamp: GstClockTime,
                                                      interval: GstClockTime,
                                                      n_values: guint,
                                                      values: *mut GValue)
                                                     -> gboolean>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstControlBindingClass {
    fn default() -> Struct__GstControlBindingClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstPad = Struct__GstPad;
pub enum Struct__GstPadPrivate { }
pub type GstPadPrivate = Struct__GstPadPrivate;
pub type GstPadClass = Struct__GstPadClass;
pub type GstPadProbeInfo = Struct__GstPadProbeInfo;
pub type Enum_Unnamed126 = ::libc::c_uint;
pub const GST_PAD_UNKNOWN: ::libc::c_uint = 0;
pub const GST_PAD_SRC: ::libc::c_uint = 1;
pub const GST_PAD_SINK: ::libc::c_uint = 2;
pub type GstPadDirection = Enum_Unnamed126;
pub type Enum_Unnamed127 = ::libc::c_uint;
pub const GST_PAD_MODE_NONE: ::libc::c_uint = 0;
pub const GST_PAD_MODE_PUSH: ::libc::c_uint = 1;
pub const GST_PAD_MODE_PULL: ::libc::c_uint = 2;
pub type GstPadMode = Enum_Unnamed127;
pub type GstMiniObject = Struct__GstMiniObject;
pub type GstMiniObjectCopyFunction =
    ::std::option::Option<extern "C" fn(obj: *const GstMiniObject)
                              -> *mut GstMiniObject>;
pub type GstMiniObjectDisposeFunction =
    ::std::option::Option<extern "C" fn(obj: *mut GstMiniObject) -> gboolean>;
pub type GstMiniObjectFreeFunction =
    ::std::option::Option<extern "C" fn(obj: *mut GstMiniObject)>;
pub type GstMiniObjectNotify =
    ::std::option::Option<extern "C" fn
                              (user_data: gpointer, obj: *mut GstMiniObject)>;
pub type Enum_Unnamed128 = ::libc::c_uint;
pub const GST_MINI_OBJECT_FLAG_LOCKABLE: ::libc::c_uint = 1;
pub const GST_MINI_OBJECT_FLAG_LOCK_READONLY: ::libc::c_uint = 2;
pub const GST_MINI_OBJECT_FLAG_LAST: ::libc::c_uint = 16;
pub type GstMiniObjectFlags = Enum_Unnamed128;
pub type Enum_Unnamed129 = ::libc::c_uint;
pub const GST_LOCK_FLAG_READ: ::libc::c_uint = 1;
pub const GST_LOCK_FLAG_WRITE: ::libc::c_uint = 2;
pub const GST_LOCK_FLAG_EXCLUSIVE: ::libc::c_uint = 4;
pub const GST_LOCK_FLAG_LAST: ::libc::c_uint = 256;
pub type GstLockFlags = Enum_Unnamed129;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstMiniObject {
    pub _type: GType,
    pub refcount: gint,
    pub lockstate: gint,
    pub flags: guint,
    pub copy: GstMiniObjectCopyFunction,
    pub dispose: GstMiniObjectDisposeFunction,
    pub free: GstMiniObjectFreeFunction,
    pub n_qdata: guint,
    pub qdata: gpointer,
}
impl ::std::default::Default for Struct__GstMiniObject {
    fn default() -> Struct__GstMiniObject { unsafe { ::std::mem::zeroed() } }
}
pub type GstMemory = Struct__GstMemory;
pub type GstAllocator = Struct__GstAllocator;
pub type Enum_Unnamed130 = ::libc::c_uint;
pub const GST_MEMORY_FLAG_READONLY: ::libc::c_uint = 2;
pub const GST_MEMORY_FLAG_NO_SHARE: ::libc::c_uint = 16;
pub const GST_MEMORY_FLAG_ZERO_PREFIXED: ::libc::c_uint = 32;
pub const GST_MEMORY_FLAG_ZERO_PADDED: ::libc::c_uint = 64;
pub const GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS: ::libc::c_uint = 128;
pub const GST_MEMORY_FLAG_NOT_MAPPABLE: ::libc::c_uint = 256;
pub const GST_MEMORY_FLAG_LAST: ::libc::c_uint = 1048576;
pub type GstMemoryFlags = Enum_Unnamed130;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstMemory {
    pub mini_object: GstMiniObject,
    pub allocator: *mut GstAllocator,
    pub parent: *mut GstMemory,
    pub maxsize: gsize,
    pub align: gsize,
    pub offset: gsize,
    pub size: gsize,
}
impl ::std::default::Default for Struct__GstMemory {
    fn default() -> Struct__GstMemory { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed131 = ::libc::c_uint;
pub const GST_MAP_READ: ::libc::c_uint = 1;
pub const GST_MAP_WRITE: ::libc::c_uint = 2;
pub const GST_MAP_FLAG_LAST: ::libc::c_uint = 65536;
pub type GstMapFlags = Enum_Unnamed131;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed132 {
    pub memory: *mut GstMemory,
    pub flags: GstMapFlags,
    pub data: *mut guint8,
    pub size: gsize,
    pub maxsize: gsize,
    pub user_data: [gpointer; 4u],
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct_Unnamed132 {
    fn default() -> Struct_Unnamed132 { unsafe { ::std::mem::zeroed() } }
}
pub type GstMapInfo = Struct_Unnamed132;
pub type GstMemoryMapFunction =
    ::std::option::Option<extern "C" fn
                              (mem: *mut GstMemory, maxsize: gsize,
                               flags: GstMapFlags) -> gpointer>;
pub type GstMemoryUnmapFunction =
    ::std::option::Option<extern "C" fn(mem: *mut GstMemory)>;
pub type GstMemoryCopyFunction =
    ::std::option::Option<extern "C" fn
                              (mem: *mut GstMemory, offset: gssize,
                               size: gssize) -> *mut GstMemory>;
pub type GstMemoryShareFunction =
    ::std::option::Option<extern "C" fn
                              (mem: *mut GstMemory, offset: gssize,
                               size: gssize) -> *mut GstMemory>;
pub type GstMemoryIsSpanFunction =
    ::std::option::Option<extern "C" fn
                              (mem1: *mut GstMemory, mem2: *mut GstMemory,
                               offset: *mut gsize) -> gboolean>;
pub enum Struct__GstAllocatorPrivate { }
pub type GstAllocatorPrivate = Struct__GstAllocatorPrivate;
pub type GstAllocatorClass = Struct__GstAllocatorClass;
pub type GstAllocationParams = Struct__GstAllocationParams;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstAllocationParams {
    pub flags: GstMemoryFlags,
    pub align: gsize,
    pub prefix: gsize,
    pub padding: gsize,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstAllocationParams {
    fn default() -> Struct__GstAllocationParams {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed133 = ::libc::c_uint;
pub const GST_ALLOCATOR_FLAG_CUSTOM_ALLOC: ::libc::c_uint = 16;
pub const GST_ALLOCATOR_FLAG_LAST: ::libc::c_uint = 1048576;
pub type GstAllocatorFlags = Enum_Unnamed133;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstAllocator {
    pub object: GstObject,
    pub mem_type: *const gchar,
    pub mem_map: GstMemoryMapFunction,
    pub mem_unmap: GstMemoryUnmapFunction,
    pub mem_copy: GstMemoryCopyFunction,
    pub mem_share: GstMemoryShareFunction,
    pub mem_is_span: GstMemoryIsSpanFunction,
    pub _gst_reserved: [gpointer; 4u],
    pub _priv: *mut GstAllocatorPrivate,
}
impl ::std::default::Default for Struct__GstAllocator {
    fn default() -> Struct__GstAllocator { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstAllocatorClass {
    pub object_class: GstObjectClass,
    pub alloc: ::std::option::Option<extern "C" fn
                                         (allocator: *mut GstAllocator,
                                          size: gsize,
                                          params: *mut GstAllocationParams)
                                         -> *mut GstMemory>,
    pub free: ::std::option::Option<extern "C" fn
                                        (allocator: *mut GstAllocator,
                                         memory: *mut GstMemory)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstAllocatorClass {
    fn default() -> Struct__GstAllocatorClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstBuffer = Struct__GstBuffer;
pub type GstBufferPool = Struct__GstBufferPool;
pub type Enum_Unnamed134 = ::libc::c_uint;
pub const GST_BUFFER_FLAG_LIVE: ::libc::c_uint = 16;
pub const GST_BUFFER_FLAG_DECODE_ONLY: ::libc::c_uint = 32;
pub const GST_BUFFER_FLAG_DISCONT: ::libc::c_uint = 64;
pub const GST_BUFFER_FLAG_RESYNC: ::libc::c_uint = 128;
pub const GST_BUFFER_FLAG_CORRUPTED: ::libc::c_uint = 256;
pub const GST_BUFFER_FLAG_MARKER: ::libc::c_uint = 512;
pub const GST_BUFFER_FLAG_HEADER: ::libc::c_uint = 1024;
pub const GST_BUFFER_FLAG_GAP: ::libc::c_uint = 2048;
pub const GST_BUFFER_FLAG_DROPPABLE: ::libc::c_uint = 4096;
pub const GST_BUFFER_FLAG_DELTA_UNIT: ::libc::c_uint = 8192;
pub const GST_BUFFER_FLAG_TAG_MEMORY: ::libc::c_uint = 16384;
pub const GST_BUFFER_FLAG_LAST: ::libc::c_uint = 1048576;
pub type GstBufferFlags = Enum_Unnamed134;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBuffer {
    pub mini_object: GstMiniObject,
    pub pool: *mut GstBufferPool,
    pub pts: GstClockTime,
    pub dts: GstClockTime,
    pub duration: GstClockTime,
    pub offset: guint64,
    pub offset_end: guint64,
}
impl ::std::default::Default for Struct__GstBuffer {
    fn default() -> Struct__GstBuffer { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed135 = ::libc::c_uint;
pub const GST_BUFFER_COPY_NONE: ::libc::c_uint = 0;
pub const GST_BUFFER_COPY_FLAGS: ::libc::c_uint = 1;
pub const GST_BUFFER_COPY_TIMESTAMPS: ::libc::c_uint = 2;
pub const GST_BUFFER_COPY_META: ::libc::c_uint = 4;
pub const GST_BUFFER_COPY_MEMORY: ::libc::c_uint = 8;
pub const GST_BUFFER_COPY_MERGE: ::libc::c_uint = 16;
pub const GST_BUFFER_COPY_DEEP: ::libc::c_uint = 32;
pub type GstBufferCopyFlags = Enum_Unnamed135;
pub type GstMeta = Struct__GstMeta;
pub type GstMetaInfo = Struct__GstMetaInfo;
pub type Enum_Unnamed136 = ::libc::c_uint;
pub const GST_META_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_META_FLAG_READONLY: ::libc::c_uint = 1;
pub const GST_META_FLAG_POOLED: ::libc::c_uint = 2;
pub const GST_META_FLAG_LOCKED: ::libc::c_uint = 4;
pub const GST_META_FLAG_LAST: ::libc::c_uint = 65536;
pub type GstMetaFlags = Enum_Unnamed136;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstMeta {
    pub flags: GstMetaFlags,
    pub info: *const GstMetaInfo,
}
impl ::std::default::Default for Struct__GstMeta {
    fn default() -> Struct__GstMeta { unsafe { ::std::mem::zeroed() } }
}
pub type GstMetaInitFunction =
    ::std::option::Option<extern "C" fn
                              (meta: *mut GstMeta, params: gpointer,
                               buffer: *mut GstBuffer) -> gboolean>;
pub type GstMetaFreeFunction =
    ::std::option::Option<extern "C" fn
                              (meta: *mut GstMeta, buffer: *mut GstBuffer)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed137 {
    pub region: gboolean,
    pub offset: gsize,
    pub size: gsize,
}
impl ::std::default::Default for Struct_Unnamed137 {
    fn default() -> Struct_Unnamed137 { unsafe { ::std::mem::zeroed() } }
}
pub type GstMetaTransformCopy = Struct_Unnamed137;
pub type GstMetaTransformFunction =
    ::std::option::Option<extern "C" fn
                              (transbuf: *mut GstBuffer, meta: *mut GstMeta,
                               buffer: *mut GstBuffer, _type: GQuark,
                               data: gpointer) -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstMetaInfo {
    pub api: GType,
    pub _type: GType,
    pub size: gsize,
    pub init_func: GstMetaInitFunction,
    pub free_func: GstMetaFreeFunction,
    pub transform_func: GstMetaTransformFunction,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstMetaInfo {
    fn default() -> Struct__GstMetaInfo { unsafe { ::std::mem::zeroed() } }
}
pub type GstBufferForeachMetaFunc =
    ::std::option::Option<extern "C" fn
                              (buffer: *mut GstBuffer,
                               meta: *mut *mut GstMeta, user_data: gpointer)
                              -> gboolean>;
pub enum Struct__GstBufferList { }
pub type GstBufferList = Struct__GstBufferList;
pub type GstBufferListFunc =
    ::std::option::Option<extern "C" fn
                              (buffer: *mut *mut GstBuffer, idx: guint,
                               user_data: gpointer) -> gboolean>;
pub enum Struct__GstDateTime { }
pub type GstDateTime = Struct__GstDateTime;
pub type GstStructure = Struct__GstStructure;
pub type GstStructureForeachFunc =
    ::std::option::Option<extern "C" fn
                              (field_id: GQuark, value: *const GValue,
                               user_data: gpointer) -> gboolean>;
pub type GstStructureMapFunc =
    ::std::option::Option<extern "C" fn
                              (field_id: GQuark, value: *mut GValue,
                               user_data: gpointer) -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstStructure {
    pub _type: GType,
    pub name: GQuark,
}
impl ::std::default::Default for Struct__GstStructure {
    fn default() -> Struct__GstStructure { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GstCapsFeatures { }
pub type GstCapsFeatures = Struct__GstCapsFeatures;
pub type Enum_Unnamed138 = ::libc::c_uint;
pub const GST_CAPS_FLAG_ANY: ::libc::c_uint = 16;
pub type GstCapsFlags = Enum_Unnamed138;
pub type Enum_Unnamed139 = ::libc::c_uint;
pub const GST_CAPS_INTERSECT_ZIG_ZAG: ::libc::c_uint = 0;
pub const GST_CAPS_INTERSECT_FIRST: ::libc::c_uint = 1;
pub type GstCapsIntersectMode = Enum_Unnamed139;
pub type GstCaps = Struct__GstCaps;
pub type GstStaticCaps = Struct__GstStaticCaps;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstCaps {
    pub mini_object: GstMiniObject,
}
impl ::std::default::Default for Struct__GstCaps {
    fn default() -> Struct__GstCaps { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstStaticCaps {
    pub caps: *mut GstCaps,
    pub string: *const ::libc::c_char,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstStaticCaps {
    fn default() -> Struct__GstStaticCaps { unsafe { ::std::mem::zeroed() } }
}
pub type GstPadTemplate = Struct__GstPadTemplate;
pub type GstPadTemplateClass = Struct__GstPadTemplateClass;
pub type GstStaticPadTemplate = Struct__GstStaticPadTemplate;
pub type GstEvent = Struct__GstEvent;
pub type Enum_Unnamed140 = ::libc::c_uint;
pub const GST_EVENT_TYPE_UPSTREAM: ::libc::c_uint = 1;
pub const GST_EVENT_TYPE_DOWNSTREAM: ::libc::c_uint = 2;
pub const GST_EVENT_TYPE_SERIALIZED: ::libc::c_uint = 4;
pub const GST_EVENT_TYPE_STICKY: ::libc::c_uint = 8;
pub const GST_EVENT_TYPE_STICKY_MULTI: ::libc::c_uint = 16;
pub type GstEventTypeFlags = Enum_Unnamed140;
pub type Enum_Unnamed141 = ::libc::c_uint;
pub const GST_EVENT_UNKNOWN: ::libc::c_uint = 0;
pub const GST_EVENT_FLUSH_START: ::libc::c_uint = 2563;
pub const GST_EVENT_FLUSH_STOP: ::libc::c_uint = 5127;
pub const GST_EVENT_STREAM_START: ::libc::c_uint = 10254;
pub const GST_EVENT_CAPS: ::libc::c_uint = 12814;
pub const GST_EVENT_SEGMENT: ::libc::c_uint = 17934;
pub const GST_EVENT_TAG: ::libc::c_uint = 20510;
pub const GST_EVENT_BUFFERSIZE: ::libc::c_uint = 23054;
pub const GST_EVENT_SINK_MESSAGE: ::libc::c_uint = 25630;
pub const GST_EVENT_EOS: ::libc::c_uint = 28174;
pub const GST_EVENT_TOC: ::libc::c_uint = 30750;
pub const GST_EVENT_SEGMENT_DONE: ::libc::c_uint = 38406;
pub const GST_EVENT_GAP: ::libc::c_uint = 40966;
pub const GST_EVENT_QOS: ::libc::c_uint = 48641;
pub const GST_EVENT_SEEK: ::libc::c_uint = 51201;
pub const GST_EVENT_NAVIGATION: ::libc::c_uint = 53761;
pub const GST_EVENT_LATENCY: ::libc::c_uint = 56321;
pub const GST_EVENT_STEP: ::libc::c_uint = 58881;
pub const GST_EVENT_RECONFIGURE: ::libc::c_uint = 61441;
pub const GST_EVENT_TOC_SELECT: ::libc::c_uint = 64001;
pub const GST_EVENT_CUSTOM_UPSTREAM: ::libc::c_uint = 69121;
pub const GST_EVENT_CUSTOM_DOWNSTREAM: ::libc::c_uint = 71686;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_OOB: ::libc::c_uint = 74242;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_STICKY: ::libc::c_uint = 76830;
pub const GST_EVENT_CUSTOM_BOTH: ::libc::c_uint = 79367;
pub const GST_EVENT_CUSTOM_BOTH_OOB: ::libc::c_uint = 81923;
pub type GstEventType = Enum_Unnamed141;
pub type Enum_Unnamed142 = ::libc::c_uint;
pub const GST_ITERATOR_DONE: ::libc::c_uint = 0;
pub const GST_ITERATOR_OK: ::libc::c_uint = 1;
pub const GST_ITERATOR_RESYNC: ::libc::c_uint = 2;
pub const GST_ITERATOR_ERROR: ::libc::c_uint = 3;
pub type GstIteratorResult = Enum_Unnamed142;
pub type GstIterator = Struct__GstIterator;
pub type Enum_Unnamed143 = ::libc::c_uint;
pub const GST_ITERATOR_ITEM_SKIP: ::libc::c_uint = 0;
pub const GST_ITERATOR_ITEM_PASS: ::libc::c_uint = 1;
pub const GST_ITERATOR_ITEM_END: ::libc::c_uint = 2;
pub type GstIteratorItem = Enum_Unnamed143;
pub type GstIteratorCopyFunction =
    ::std::option::Option<extern "C" fn
                              (it: *const GstIterator,
                               copy: *mut GstIterator)>;
pub type GstIteratorItemFunction =
    ::std::option::Option<extern "C" fn
                              (it: *mut GstIterator, item: *const GValue)
                              -> GstIteratorItem>;
pub type GstIteratorNextFunction =
    ::std::option::Option<extern "C" fn
                              (it: *mut GstIterator, result: *mut GValue)
                              -> GstIteratorResult>;
pub type GstIteratorResyncFunction =
    ::std::option::Option<extern "C" fn(it: *mut GstIterator)>;
pub type GstIteratorFreeFunction =
    ::std::option::Option<extern "C" fn(it: *mut GstIterator)>;
pub type GstIteratorForeachFunction =
    ::std::option::Option<extern "C" fn
                              (item: *const GValue, user_data: gpointer)>;
pub type GstIteratorFoldFunction =
    ::std::option::Option<extern "C" fn
                              (item: *const GValue, ret: *mut GValue,
                               user_data: gpointer) -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstIterator {
    pub copy: GstIteratorCopyFunction,
    pub next: GstIteratorNextFunction,
    pub item: GstIteratorItemFunction,
    pub resync: GstIteratorResyncFunction,
    pub free: GstIteratorFreeFunction,
    pub pushed: *mut GstIterator,
    pub _type: GType,
    pub lock: *mut GMutex,
    pub cookie: guint32,
    pub master_cookie: *mut guint32,
    pub size: guint,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstIterator {
    fn default() -> Struct__GstIterator { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed144 = ::libc::c_uint;
pub const GST_FORMAT_UNDEFINED: ::libc::c_uint = 0;
pub const GST_FORMAT_DEFAULT: ::libc::c_uint = 1;
pub const GST_FORMAT_BYTES: ::libc::c_uint = 2;
pub const GST_FORMAT_TIME: ::libc::c_uint = 3;
pub const GST_FORMAT_BUFFERS: ::libc::c_uint = 4;
pub const GST_FORMAT_PERCENT: ::libc::c_uint = 5;
pub type GstFormat = Enum_Unnamed144;
pub type GstFormatDefinition = Struct__GstFormatDefinition;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstFormatDefinition {
    pub value: GstFormat,
    pub nick: *const gchar,
    pub description: *const gchar,
    pub quark: GQuark,
}
impl ::std::default::Default for Struct__GstFormatDefinition {
    fn default() -> Struct__GstFormatDefinition {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstSegment = Struct__GstSegment;
pub type Enum_Unnamed145 = ::libc::c_uint;
pub const GST_SEEK_TYPE_NONE: ::libc::c_uint = 0;
pub const GST_SEEK_TYPE_SET: ::libc::c_uint = 1;
pub const GST_SEEK_TYPE_END: ::libc::c_uint = 2;
pub type GstSeekType = Enum_Unnamed145;
pub type Enum_Unnamed146 = ::libc::c_uint;
pub const GST_SEEK_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_SEEK_FLAG_FLUSH: ::libc::c_uint = 1;
pub const GST_SEEK_FLAG_ACCURATE: ::libc::c_uint = 2;
pub const GST_SEEK_FLAG_KEY_UNIT: ::libc::c_uint = 4;
pub const GST_SEEK_FLAG_SEGMENT: ::libc::c_uint = 8;
pub const GST_SEEK_FLAG_SKIP: ::libc::c_uint = 16;
pub const GST_SEEK_FLAG_SNAP_BEFORE: ::libc::c_uint = 32;
pub const GST_SEEK_FLAG_SNAP_AFTER: ::libc::c_uint = 64;
pub const GST_SEEK_FLAG_SNAP_NEAREST: ::libc::c_uint = 96;
pub type GstSeekFlags = Enum_Unnamed146;
pub type Enum_Unnamed147 = ::libc::c_uint;
pub const GST_SEGMENT_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_SEGMENT_FLAG_RESET: ::libc::c_uint = 1;
pub const GST_SEGMENT_FLAG_SKIP: ::libc::c_uint = 16;
pub const GST_SEGMENT_FLAG_SEGMENT: ::libc::c_uint = 8;
pub type GstSegmentFlags = Enum_Unnamed147;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstSegment {
    pub flags: GstSegmentFlags,
    pub rate: gdouble,
    pub applied_rate: gdouble,
    pub format: GstFormat,
    pub base: guint64,
    pub offset: guint64,
    pub start: guint64,
    pub stop: guint64,
    pub time: guint64,
    pub position: guint64,
    pub duration: guint64,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstSegment {
    fn default() -> Struct__GstSegment { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GstSample { }
pub type GstSample = Struct__GstSample;
pub type Enum_Unnamed148 = ::libc::c_uint;
pub const GST_TAG_MERGE_UNDEFINED: ::libc::c_uint = 0;
pub const GST_TAG_MERGE_REPLACE_ALL: ::libc::c_uint = 1;
pub const GST_TAG_MERGE_REPLACE: ::libc::c_uint = 2;
pub const GST_TAG_MERGE_APPEND: ::libc::c_uint = 3;
pub const GST_TAG_MERGE_PREPEND: ::libc::c_uint = 4;
pub const GST_TAG_MERGE_KEEP: ::libc::c_uint = 5;
pub const GST_TAG_MERGE_KEEP_ALL: ::libc::c_uint = 6;
pub const GST_TAG_MERGE_COUNT: ::libc::c_uint = 7;
pub type GstTagMergeMode = Enum_Unnamed148;
pub type Enum_Unnamed149 = ::libc::c_uint;
pub const GST_TAG_FLAG_UNDEFINED: ::libc::c_uint = 0;
pub const GST_TAG_FLAG_META: ::libc::c_uint = 1;
pub const GST_TAG_FLAG_ENCODED: ::libc::c_uint = 2;
pub const GST_TAG_FLAG_DECODED: ::libc::c_uint = 3;
pub const GST_TAG_FLAG_COUNT: ::libc::c_uint = 4;
pub type GstTagFlag = Enum_Unnamed149;
pub type GstTagList = Struct__GstTagList;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTagList {
    pub mini_object: GstMiniObject,
}
impl ::std::default::Default for Struct__GstTagList {
    fn default() -> Struct__GstTagList { unsafe { ::std::mem::zeroed() } }
}
pub type GstTagForeachFunc =
    ::std::option::Option<extern "C" fn
                              (list: *const GstTagList, tag: *const gchar,
                               user_data: gpointer)>;
pub type GstTagMergeFunc =
    ::std::option::Option<extern "C" fn
                              (dest: *mut GValue, src: *const GValue)>;
pub type Enum_Unnamed150 = ::libc::c_uint;
pub const GST_TAG_SCOPE_STREAM: ::libc::c_uint = 0;
pub const GST_TAG_SCOPE_GLOBAL: ::libc::c_uint = 1;
pub type GstTagScope = Enum_Unnamed150;
pub type GstMessage = Struct__GstMessage;
pub type Enum_Unnamed151 = ::libc::c_int;
pub const GST_MESSAGE_UNKNOWN: ::libc::c_int = 0;
pub const GST_MESSAGE_EOS: ::libc::c_int = 1;
pub const GST_MESSAGE_ERROR: ::libc::c_int = 2;
pub const GST_MESSAGE_WARNING: ::libc::c_int = 4;
pub const GST_MESSAGE_INFO: ::libc::c_int = 8;
pub const GST_MESSAGE_TAG: ::libc::c_int = 16;
pub const GST_MESSAGE_BUFFERING: ::libc::c_int = 32;
pub const GST_MESSAGE_STATE_CHANGED: ::libc::c_int = 64;
pub const GST_MESSAGE_STATE_DIRTY: ::libc::c_int = 128;
pub const GST_MESSAGE_STEP_DONE: ::libc::c_int = 256;
pub const GST_MESSAGE_CLOCK_PROVIDE: ::libc::c_int = 512;
pub const GST_MESSAGE_CLOCK_LOST: ::libc::c_int = 1024;
pub const GST_MESSAGE_NEW_CLOCK: ::libc::c_int = 2048;
pub const GST_MESSAGE_STRUCTURE_CHANGE: ::libc::c_int = 4096;
pub const GST_MESSAGE_STREAM_STATUS: ::libc::c_int = 8192;
pub const GST_MESSAGE_APPLICATION: ::libc::c_int = 16384;
pub const GST_MESSAGE_ELEMENT: ::libc::c_int = 32768;
pub const GST_MESSAGE_SEGMENT_START: ::libc::c_int = 65536;
pub const GST_MESSAGE_SEGMENT_DONE: ::libc::c_int = 131072;
pub const GST_MESSAGE_DURATION_CHANGED: ::libc::c_int = 262144;
pub const GST_MESSAGE_LATENCY: ::libc::c_int = 524288;
pub const GST_MESSAGE_ASYNC_START: ::libc::c_int = 1048576;
pub const GST_MESSAGE_ASYNC_DONE: ::libc::c_int = 2097152;
pub const GST_MESSAGE_REQUEST_STATE: ::libc::c_int = 4194304;
pub const GST_MESSAGE_STEP_START: ::libc::c_int = 8388608;
pub const GST_MESSAGE_QOS: ::libc::c_int = 16777216;
pub const GST_MESSAGE_PROGRESS: ::libc::c_int = 33554432;
pub const GST_MESSAGE_TOC: ::libc::c_int = 67108864;
pub const GST_MESSAGE_RESET_TIME: ::libc::c_int = 134217728;
pub const GST_MESSAGE_STREAM_START: ::libc::c_int = 268435456;
pub const GST_MESSAGE_NEED_CONTEXT: ::libc::c_int = 536870912;
pub const GST_MESSAGE_HAVE_CONTEXT: ::libc::c_int = 1073741824;
pub const GST_MESSAGE_EXTENDED: ::libc::c_int = -2147483648;
pub const GST_MESSAGE_DEVICE_ADDED: ::libc::c_int = -2147483647;
pub const GST_MESSAGE_DEVICE_REMOVED: ::libc::c_int = -2147483646;
pub const GST_MESSAGE_ANY: ::libc::c_int = -1;
pub type GstMessageType = Enum_Unnamed151;
pub enum Struct__GstTocEntry { }
pub type GstTocEntry = Struct__GstTocEntry;
pub enum Struct__GstToc { }
pub type GstToc = Struct__GstToc;
pub type Enum_Unnamed152 = ::libc::c_uint;
pub const GST_TOC_SCOPE_GLOBAL: ::libc::c_uint = 1;
pub const GST_TOC_SCOPE_CURRENT: ::libc::c_uint = 2;
pub type GstTocScope = Enum_Unnamed152;
pub type Enum_Unnamed153 = ::libc::c_int;
pub const GST_TOC_ENTRY_TYPE_ANGLE: ::libc::c_int = -3;
pub const GST_TOC_ENTRY_TYPE_VERSION: ::libc::c_int = -2;
pub const GST_TOC_ENTRY_TYPE_EDITION: ::libc::c_int = -1;
pub const GST_TOC_ENTRY_TYPE_INVALID: ::libc::c_int = 0;
pub const GST_TOC_ENTRY_TYPE_TITLE: ::libc::c_int = 1;
pub const GST_TOC_ENTRY_TYPE_TRACK: ::libc::c_int = 2;
pub const GST_TOC_ENTRY_TYPE_CHAPTER: ::libc::c_int = 3;
pub type GstTocEntryType = Enum_Unnamed153;
pub type Enum_Unnamed154 = ::libc::c_uint;
pub const GST_TOC_LOOP_NONE: ::libc::c_uint = 0;
pub const GST_TOC_LOOP_FORWARD: ::libc::c_uint = 1;
pub const GST_TOC_LOOP_REVERSE: ::libc::c_uint = 2;
pub const GST_TOC_LOOP_PING_PONG: ::libc::c_uint = 3;
pub type GstTocLoopType = Enum_Unnamed154;
pub enum Struct__GstContext { }
pub type GstContext = Struct__GstContext;
pub type GstQuery = Struct__GstQuery;
pub type Enum_Unnamed155 = ::libc::c_uint;
pub const GST_QUERY_TYPE_UPSTREAM: ::libc::c_uint = 1;
pub const GST_QUERY_TYPE_DOWNSTREAM: ::libc::c_uint = 2;
pub const GST_QUERY_TYPE_SERIALIZED: ::libc::c_uint = 4;
pub type GstQueryTypeFlags = Enum_Unnamed155;
pub type Enum_Unnamed156 = ::libc::c_uint;
pub const GST_QUERY_UNKNOWN: ::libc::c_uint = 0;
pub const GST_QUERY_POSITION: ::libc::c_uint = 2563;
pub const GST_QUERY_DURATION: ::libc::c_uint = 5123;
pub const GST_QUERY_LATENCY: ::libc::c_uint = 7683;
pub const GST_QUERY_JITTER: ::libc::c_uint = 10243;
pub const GST_QUERY_RATE: ::libc::c_uint = 12803;
pub const GST_QUERY_SEEKING: ::libc::c_uint = 15363;
pub const GST_QUERY_SEGMENT: ::libc::c_uint = 17923;
pub const GST_QUERY_CONVERT: ::libc::c_uint = 20483;
pub const GST_QUERY_FORMATS: ::libc::c_uint = 23043;
pub const GST_QUERY_BUFFERING: ::libc::c_uint = 28163;
pub const GST_QUERY_CUSTOM: ::libc::c_uint = 30723;
pub const GST_QUERY_URI: ::libc::c_uint = 33283;
pub const GST_QUERY_ALLOCATION: ::libc::c_uint = 35846;
pub const GST_QUERY_SCHEDULING: ::libc::c_uint = 38401;
pub const GST_QUERY_ACCEPT_CAPS: ::libc::c_uint = 40963;
pub const GST_QUERY_CAPS: ::libc::c_uint = 43523;
pub const GST_QUERY_DRAIN: ::libc::c_uint = 46086;
pub const GST_QUERY_CONTEXT: ::libc::c_uint = 48643;
pub type GstQueryType = Enum_Unnamed156;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstQuery {
    pub mini_object: GstMiniObject,
    pub _type: GstQueryType,
}
impl ::std::default::Default for Struct__GstQuery {
    fn default() -> Struct__GstQuery { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed157 = ::libc::c_uint;
pub const GST_BUFFERING_STREAM: ::libc::c_uint = 0;
pub const GST_BUFFERING_DOWNLOAD: ::libc::c_uint = 1;
pub const GST_BUFFERING_TIMESHIFT: ::libc::c_uint = 2;
pub const GST_BUFFERING_LIVE: ::libc::c_uint = 3;
pub type GstBufferingMode = Enum_Unnamed157;
pub type Enum_Unnamed158 = ::libc::c_uint;
pub const GST_SCHEDULING_FLAG_SEEKABLE: ::libc::c_uint = 1;
pub const GST_SCHEDULING_FLAG_SEQUENTIAL: ::libc::c_uint = 2;
pub const GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED: ::libc::c_uint = 4;
pub type GstSchedulingFlags = Enum_Unnamed158;
pub type GstDevice = Struct__GstDevice;
pub type GstDeviceClass = Struct__GstDeviceClass;
pub enum Struct__GstDevicePrivate { }
pub type GstDevicePrivate = Struct__GstDevicePrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstDevice {
    pub parent: GstObject,
    pub _priv: *mut GstDevicePrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstDevice {
    fn default() -> Struct__GstDevice { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstDeviceClass {
    pub parent_class: GstObjectClass,
    pub create_element: ::std::option::Option<extern "C" fn
                                                  (device: *mut GstDevice,
                                                   name: *const gchar)
                                                  -> *mut GstElement>,
    pub reconfigure_element: ::std::option::Option<extern "C" fn
                                                       (device:
                                                            *mut GstDevice,
                                                        element:
                                                            *mut GstElement)
                                                       -> gboolean>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstDeviceClass {
    fn default() -> Struct__GstDeviceClass { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed159 = ::libc::c_uint;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: ::libc::c_uint = 0;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: ::libc::c_uint = 1;
pub type GstStructureChangeType = Enum_Unnamed159;
pub type Enum_Unnamed160 = ::libc::c_uint;
pub const GST_STREAM_STATUS_TYPE_CREATE: ::libc::c_uint = 0;
pub const GST_STREAM_STATUS_TYPE_ENTER: ::libc::c_uint = 1;
pub const GST_STREAM_STATUS_TYPE_LEAVE: ::libc::c_uint = 2;
pub const GST_STREAM_STATUS_TYPE_DESTROY: ::libc::c_uint = 3;
pub const GST_STREAM_STATUS_TYPE_START: ::libc::c_uint = 8;
pub const GST_STREAM_STATUS_TYPE_PAUSE: ::libc::c_uint = 9;
pub const GST_STREAM_STATUS_TYPE_STOP: ::libc::c_uint = 10;
pub type GstStreamStatusType = Enum_Unnamed160;
pub type Enum_Unnamed161 = ::libc::c_uint;
pub const GST_PROGRESS_TYPE_START: ::libc::c_uint = 0;
pub const GST_PROGRESS_TYPE_CONTINUE: ::libc::c_uint = 1;
pub const GST_PROGRESS_TYPE_COMPLETE: ::libc::c_uint = 2;
pub const GST_PROGRESS_TYPE_CANCELED: ::libc::c_uint = 3;
pub const GST_PROGRESS_TYPE_ERROR: ::libc::c_uint = 4;
pub type GstProgressType = Enum_Unnamed161;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstMessage {
    pub mini_object: GstMiniObject,
    pub _type: GstMessageType,
    pub timestamp: guint64,
    pub src: *mut GstObject,
    pub seqnum: guint32,
    pub lock: GMutex,
    pub cond: GCond,
}
impl ::std::default::Default for Struct__GstMessage {
    fn default() -> Struct__GstMessage { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed162 = ::libc::c_uint;
pub const GST_QOS_TYPE_OVERFLOW: ::libc::c_uint = 0;
pub const GST_QOS_TYPE_UNDERFLOW: ::libc::c_uint = 1;
pub const GST_QOS_TYPE_THROTTLE: ::libc::c_uint = 2;
pub type GstQOSType = Enum_Unnamed162;
pub type Enum_Unnamed163 = ::libc::c_uint;
pub const GST_STREAM_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_STREAM_FLAG_SPARSE: ::libc::c_uint = 1;
pub const GST_STREAM_FLAG_SELECT: ::libc::c_uint = 2;
pub const GST_STREAM_FLAG_UNSELECT: ::libc::c_uint = 4;
pub type GstStreamFlags = Enum_Unnamed163;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstEvent {
    pub mini_object: GstMiniObject,
    pub _type: GstEventType,
    pub timestamp: guint64,
    pub seqnum: guint32,
}
impl ::std::default::Default for Struct__GstEvent {
    fn default() -> Struct__GstEvent { unsafe { ::std::mem::zeroed() } }
}
pub type GstTaskPool = Struct__GstTaskPool;
pub type GstTaskPoolClass = Struct__GstTaskPoolClass;
pub type GstTaskPoolFunction =
    ::std::option::Option<extern "C" fn(user_data: *mut ::libc::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTaskPool {
    pub object: GstObject,
    pub pool: *mut GThreadPool,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstTaskPool {
    fn default() -> Struct__GstTaskPool { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTaskPoolClass {
    pub parent_class: GstObjectClass,
    pub prepare: ::std::option::Option<extern "C" fn
                                           (pool: *mut GstTaskPool,
                                            error: *mut *mut GError)>,
    pub cleanup: ::std::option::Option<extern "C" fn(pool: *mut GstTaskPool)>,
    pub push: ::std::option::Option<extern "C" fn
                                        (pool: *mut GstTaskPool,
                                         func: GstTaskPoolFunction,
                                         user_data: gpointer,
                                         error: *mut *mut GError)
                                        -> gpointer>,
    pub join: ::std::option::Option<extern "C" fn
                                        (pool: *mut GstTaskPool,
                                         id: gpointer)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstTaskPoolClass {
    fn default() -> Struct__GstTaskPoolClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstTaskFunction =
    ::std::option::Option<extern "C" fn(user_data: gpointer)>;
pub type GstTask = Struct__GstTask;
pub type GstTaskClass = Struct__GstTaskClass;
pub enum Struct__GstTaskPrivate { }
pub type GstTaskPrivate = Struct__GstTaskPrivate;
pub type Enum_Unnamed164 = ::libc::c_uint;
pub const GST_TASK_STARTED: ::libc::c_uint = 0;
pub const GST_TASK_STOPPED: ::libc::c_uint = 1;
pub const GST_TASK_PAUSED: ::libc::c_uint = 2;
pub type GstTaskState = Enum_Unnamed164;
pub type GstTaskThreadFunc =
    ::std::option::Option<extern "C" fn
                              (task: *mut GstTask, thread: *mut GThread,
                               user_data: gpointer)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTask {
    pub object: GstObject,
    pub state: GstTaskState,
    pub cond: GCond,
    pub lock: *mut GRecMutex,
    pub func: GstTaskFunction,
    pub user_data: gpointer,
    pub notify: GDestroyNotify,
    pub running: gboolean,
    pub thread: *mut GThread,
    pub _priv: *mut GstTaskPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstTask {
    fn default() -> Struct__GstTask { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTaskClass {
    pub parent_class: GstObjectClass,
    pub pool: *mut GstTaskPool,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstTaskClass {
    fn default() -> Struct__GstTaskClass { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed165 = ::libc::c_uint;
pub const GST_PAD_ALWAYS: ::libc::c_uint = 0;
pub const GST_PAD_SOMETIMES: ::libc::c_uint = 1;
pub const GST_PAD_REQUEST: ::libc::c_uint = 2;
pub type GstPadPresence = Enum_Unnamed165;
pub type Enum_Unnamed166 = ::libc::c_uint;
pub const GST_PAD_TEMPLATE_FLAG_LAST: ::libc::c_uint = 256;
pub type GstPadTemplateFlags = Enum_Unnamed166;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPadTemplate {
    pub object: GstObject,
    pub name_template: *mut gchar,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub caps: *mut GstCaps,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPadTemplate {
    fn default() -> Struct__GstPadTemplate { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPadTemplateClass {
    pub parent_class: GstObjectClass,
    pub pad_created: ::std::option::Option<extern "C" fn
                                               (templ: *mut GstPadTemplate,
                                                pad: *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPadTemplateClass {
    fn default() -> Struct__GstPadTemplateClass {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstStaticPadTemplate {
    pub name_template: *const gchar,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub static_caps: GstStaticCaps,
}
impl ::std::default::Default for Struct__GstStaticPadTemplate {
    fn default() -> Struct__GstStaticPadTemplate {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed167 = ::libc::c_int;
pub const GST_PAD_LINK_OK: ::libc::c_int = 0;
pub const GST_PAD_LINK_WRONG_HIERARCHY: ::libc::c_int = -1;
pub const GST_PAD_LINK_WAS_LINKED: ::libc::c_int = -2;
pub const GST_PAD_LINK_WRONG_DIRECTION: ::libc::c_int = -3;
pub const GST_PAD_LINK_NOFORMAT: ::libc::c_int = -4;
pub const GST_PAD_LINK_NOSCHED: ::libc::c_int = -5;
pub const GST_PAD_LINK_REFUSED: ::libc::c_int = -6;
pub type GstPadLinkReturn = Enum_Unnamed167;
pub type Enum_Unnamed168 = ::libc::c_int;
pub const GST_FLOW_CUSTOM_SUCCESS_2: ::libc::c_int = 102;
pub const GST_FLOW_CUSTOM_SUCCESS_1: ::libc::c_int = 101;
pub const GST_FLOW_CUSTOM_SUCCESS: ::libc::c_int = 100;
pub const GST_FLOW_OK: ::libc::c_int = 0;
pub const GST_FLOW_NOT_LINKED: ::libc::c_int = -1;
pub const GST_FLOW_FLUSHING: ::libc::c_int = -2;
pub const GST_FLOW_EOS: ::libc::c_int = -3;
pub const GST_FLOW_NOT_NEGOTIATED: ::libc::c_int = -4;
pub const GST_FLOW_ERROR: ::libc::c_int = -5;
pub const GST_FLOW_NOT_SUPPORTED: ::libc::c_int = -6;
pub const GST_FLOW_CUSTOM_ERROR: ::libc::c_int = -100;
pub const GST_FLOW_CUSTOM_ERROR_1: ::libc::c_int = -101;
pub const GST_FLOW_CUSTOM_ERROR_2: ::libc::c_int = -102;
pub type GstFlowReturn = Enum_Unnamed168;
pub type Enum_Unnamed169 = ::libc::c_uint;
pub const GST_PAD_LINK_CHECK_NOTHING: ::libc::c_uint = 0;
pub const GST_PAD_LINK_CHECK_HIERARCHY: ::libc::c_uint = 1;
pub const GST_PAD_LINK_CHECK_TEMPLATE_CAPS: ::libc::c_uint = 2;
pub const GST_PAD_LINK_CHECK_CAPS: ::libc::c_uint = 4;
pub const GST_PAD_LINK_CHECK_DEFAULT: ::libc::c_uint = 5;
pub type GstPadLinkCheck = Enum_Unnamed169;
pub type GstPadActivateFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject)
                              -> gboolean>;
pub type GstPadActivateModeFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject,
                               mode: GstPadMode, active: gboolean)
                              -> gboolean>;
pub type GstPadChainFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject,
                               buffer: *mut GstBuffer) -> GstFlowReturn>;
pub type GstPadChainListFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject,
                               list: *mut GstBufferList) -> GstFlowReturn>;
pub type GstPadGetRangeFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject,
                               offset: guint64, length: guint,
                               buffer: *mut *mut GstBuffer) -> GstFlowReturn>;
pub type GstPadEventFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject,
                               event: *mut GstEvent) -> gboolean>;
pub type GstPadIterIntLinkFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject)
                              -> *mut GstIterator>;
pub type GstPadQueryFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject,
                               query: *mut GstQuery) -> gboolean>;
pub type GstPadLinkFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject,
                               peer: *mut GstPad) -> GstPadLinkReturn>;
pub type GstPadUnlinkFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, parent: *mut GstObject)>;
pub type GstPadForwardFunction =
    ::std::option::Option<extern "C" fn(pad: *mut GstPad, user_data: gpointer)
                              -> gboolean>;
pub type Enum_Unnamed170 = ::libc::c_uint;
pub const GST_PAD_PROBE_TYPE_INVALID: ::libc::c_uint = 0;
pub const GST_PAD_PROBE_TYPE_IDLE: ::libc::c_uint = 1;
pub const GST_PAD_PROBE_TYPE_BLOCK: ::libc::c_uint = 2;
pub const GST_PAD_PROBE_TYPE_BUFFER: ::libc::c_uint = 16;
pub const GST_PAD_PROBE_TYPE_BUFFER_LIST: ::libc::c_uint = 32;
pub const GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM: ::libc::c_uint = 64;
pub const GST_PAD_PROBE_TYPE_EVENT_UPSTREAM: ::libc::c_uint = 128;
pub const GST_PAD_PROBE_TYPE_EVENT_FLUSH: ::libc::c_uint = 256;
pub const GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM: ::libc::c_uint = 512;
pub const GST_PAD_PROBE_TYPE_QUERY_UPSTREAM: ::libc::c_uint = 1024;
pub const GST_PAD_PROBE_TYPE_PUSH: ::libc::c_uint = 4096;
pub const GST_PAD_PROBE_TYPE_PULL: ::libc::c_uint = 8192;
pub const GST_PAD_PROBE_TYPE_BLOCKING: ::libc::c_uint = 3;
pub const GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM: ::libc::c_uint = 112;
pub const GST_PAD_PROBE_TYPE_DATA_UPSTREAM: ::libc::c_uint = 128;
pub const GST_PAD_PROBE_TYPE_DATA_BOTH: ::libc::c_uint = 240;
pub const GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM: ::libc::c_uint = 114;
pub const GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM: ::libc::c_uint = 130;
pub const GST_PAD_PROBE_TYPE_EVENT_BOTH: ::libc::c_uint = 192;
pub const GST_PAD_PROBE_TYPE_QUERY_BOTH: ::libc::c_uint = 1536;
pub const GST_PAD_PROBE_TYPE_ALL_BOTH: ::libc::c_uint = 1776;
pub const GST_PAD_PROBE_TYPE_SCHEDULING: ::libc::c_uint = 12288;
pub type GstPadProbeType = Enum_Unnamed170;
pub type Enum_Unnamed171 = ::libc::c_uint;
pub const GST_PAD_PROBE_DROP: ::libc::c_uint = 0;
pub const GST_PAD_PROBE_OK: ::libc::c_uint = 1;
pub const GST_PAD_PROBE_REMOVE: ::libc::c_uint = 2;
pub const GST_PAD_PROBE_PASS: ::libc::c_uint = 3;
pub type GstPadProbeReturn = Enum_Unnamed171;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPadProbeInfo {
    pub _type: GstPadProbeType,
    pub id: gulong,
    pub data: gpointer,
    pub offset: guint64,
    pub size: guint,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPadProbeInfo {
    fn default() -> Struct__GstPadProbeInfo {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstPadProbeCallback =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, info: *mut GstPadProbeInfo,
                               user_data: gpointer) -> GstPadProbeReturn>;
pub type GstPadStickyEventsForeachFunction =
    ::std::option::Option<extern "C" fn
                              (pad: *mut GstPad, event: *mut *mut GstEvent,
                               user_data: gpointer) -> gboolean>;
pub type Enum_Unnamed172 = ::libc::c_uint;
pub const GST_PAD_FLAG_BLOCKED: ::libc::c_uint = 16;
pub const GST_PAD_FLAG_FLUSHING: ::libc::c_uint = 32;
pub const GST_PAD_FLAG_EOS: ::libc::c_uint = 64;
pub const GST_PAD_FLAG_BLOCKING: ::libc::c_uint = 128;
pub const GST_PAD_FLAG_NEED_PARENT: ::libc::c_uint = 256;
pub const GST_PAD_FLAG_NEED_RECONFIGURE: ::libc::c_uint = 512;
pub const GST_PAD_FLAG_PENDING_EVENTS: ::libc::c_uint = 1024;
pub const GST_PAD_FLAG_FIXED_CAPS: ::libc::c_uint = 2048;
pub const GST_PAD_FLAG_PROXY_CAPS: ::libc::c_uint = 4096;
pub const GST_PAD_FLAG_PROXY_ALLOCATION: ::libc::c_uint = 8192;
pub const GST_PAD_FLAG_PROXY_SCHEDULING: ::libc::c_uint = 16384;
pub const GST_PAD_FLAG_ACCEPT_INTERSECT: ::libc::c_uint = 32768;
pub const GST_PAD_FLAG_LAST: ::libc::c_uint = 1048576;
pub type GstPadFlags = Enum_Unnamed172;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPad {
    pub object: GstObject,
    pub element_private: gpointer,
    pub padtemplate: *mut GstPadTemplate,
    pub direction: GstPadDirection,
    pub stream_rec_lock: GRecMutex,
    pub task: *mut GstTask,
    pub block_cond: GCond,
    pub probes: GHookList,
    pub mode: GstPadMode,
    pub activatefunc: GstPadActivateFunction,
    pub activatedata: gpointer,
    pub activatenotify: GDestroyNotify,
    pub activatemodefunc: GstPadActivateModeFunction,
    pub activatemodedata: gpointer,
    pub activatemodenotify: GDestroyNotify,
    pub peer: *mut GstPad,
    pub linkfunc: GstPadLinkFunction,
    pub linkdata: gpointer,
    pub linknotify: GDestroyNotify,
    pub unlinkfunc: GstPadUnlinkFunction,
    pub unlinkdata: gpointer,
    pub unlinknotify: GDestroyNotify,
    pub chainfunc: GstPadChainFunction,
    pub chaindata: gpointer,
    pub chainnotify: GDestroyNotify,
    pub chainlistfunc: GstPadChainListFunction,
    pub chainlistdata: gpointer,
    pub chainlistnotify: GDestroyNotify,
    pub getrangefunc: GstPadGetRangeFunction,
    pub getrangedata: gpointer,
    pub getrangenotify: GDestroyNotify,
    pub eventfunc: GstPadEventFunction,
    pub eventdata: gpointer,
    pub eventnotify: GDestroyNotify,
    pub offset: gint64,
    pub queryfunc: GstPadQueryFunction,
    pub querydata: gpointer,
    pub querynotify: GDestroyNotify,
    pub iterintlinkfunc: GstPadIterIntLinkFunction,
    pub iterintlinkdata: gpointer,
    pub iterintlinknotify: GDestroyNotify,
    pub num_probes: gint,
    pub num_blocked: gint,
    pub _priv: *mut GstPadPrivate,
    pub ABI: Union_Unnamed173,
}
impl ::std::default::Default for Struct__GstPad {
    fn default() -> Struct__GstPad { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed173 {
    pub _bindgen_data_: [u64; 4u],
}
impl Union_Unnamed173 {
    pub unsafe fn _gst_reserved(&mut self) -> *mut [gpointer; 4u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn abi(&mut self) -> *mut Struct_Unnamed174 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed173 {
    fn default() -> Union_Unnamed173 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed174 {
    pub last_flowret: GstFlowReturn,
}
impl ::std::default::Default for Struct_Unnamed174 {
    fn default() -> Struct_Unnamed174 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPadClass {
    pub parent_class: GstObjectClass,
    pub linked: ::std::option::Option<extern "C" fn
                                          (pad: *mut GstPad,
                                           peer: *mut GstPad)>,
    pub unlinked: ::std::option::Option<extern "C" fn
                                            (pad: *mut GstPad,
                                             peer: *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPadClass {
    fn default() -> Struct__GstPadClass { unsafe { ::std::mem::zeroed() } }
}
pub type GstBus = Struct__GstBus;
pub enum Struct__GstBusPrivate { }
pub type GstBusPrivate = Struct__GstBusPrivate;
pub type GstBusClass = Struct__GstBusClass;
pub type Enum_Unnamed175 = ::libc::c_uint;
pub const GST_BUS_FLUSHING: ::libc::c_uint = 16;
pub const GST_BUS_FLAG_LAST: ::libc::c_uint = 32;
pub type GstBusFlags = Enum_Unnamed175;
pub type Enum_Unnamed176 = ::libc::c_uint;
pub const GST_BUS_DROP: ::libc::c_uint = 0;
pub const GST_BUS_PASS: ::libc::c_uint = 1;
pub const GST_BUS_ASYNC: ::libc::c_uint = 2;
pub type GstBusSyncReply = Enum_Unnamed176;
pub type GstBusSyncHandler =
    ::std::option::Option<extern "C" fn
                              (bus: *mut GstBus, message: *mut GstMessage,
                               user_data: gpointer) -> GstBusSyncReply>;
pub type GstBusFunc =
    ::std::option::Option<extern "C" fn
                              (bus: *mut GstBus, message: *mut GstMessage,
                               user_data: gpointer) -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBus {
    pub object: GstObject,
    pub _priv: *mut GstBusPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstBus {
    fn default() -> Struct__GstBus { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBusClass {
    pub parent_class: GstObjectClass,
    pub message: ::std::option::Option<extern "C" fn
                                           (bus: *mut GstBus,
                                            message: *mut GstMessage)>,
    pub sync_message: ::std::option::Option<extern "C" fn
                                                (bus: *mut GstBus,
                                                 message: *mut GstMessage)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstBusClass {
    fn default() -> Struct__GstBusClass { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GstElementFactory { }
pub type GstElementFactory = Struct__GstElementFactory;
pub enum Struct__GstElementFactoryClass { }
pub type GstElementFactoryClass = Struct__GstElementFactoryClass;
pub enum Struct__GstPlugin { }
pub type GstPlugin = Struct__GstPlugin;
pub enum Struct__GstPluginClass { }
pub type GstPluginClass = Struct__GstPluginClass;
pub type GstPluginDesc = Struct__GstPluginDesc;
pub type Enum_Unnamed177 = ::libc::c_uint;
pub const GST_PLUGIN_ERROR_MODULE: ::libc::c_uint = 0;
pub const GST_PLUGIN_ERROR_DEPENDENCIES: ::libc::c_uint = 1;
pub const GST_PLUGIN_ERROR_NAME_MISMATCH: ::libc::c_uint = 2;
pub type GstPluginError = Enum_Unnamed177;
pub type Enum_Unnamed178 = ::libc::c_uint;
pub const GST_PLUGIN_FLAG_CACHED: ::libc::c_uint = 16;
pub const GST_PLUGIN_FLAG_BLACKLISTED: ::libc::c_uint = 32;
pub type GstPluginFlags = Enum_Unnamed178;
pub type Enum_Unnamed179 = ::libc::c_uint;
pub const GST_PLUGIN_DEPENDENCY_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_PLUGIN_DEPENDENCY_FLAG_RECURSE: ::libc::c_uint = 1;
pub const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY: ::libc::c_uint =
    2;
pub const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX: ::libc::c_uint = 4;
pub type GstPluginDependencyFlags = Enum_Unnamed179;
pub type GstPluginInitFunc =
    ::std::option::Option<extern "C" fn(plugin: *mut GstPlugin) -> gboolean>;
pub type GstPluginInitFullFunc =
    ::std::option::Option<extern "C" fn
                              (plugin: *mut GstPlugin, user_data: gpointer)
                              -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPluginDesc {
    pub major_version: gint,
    pub minor_version: gint,
    pub name: *const gchar,
    pub description: *const gchar,
    pub plugin_init: GstPluginInitFunc,
    pub version: *const gchar,
    pub license: *const gchar,
    pub source: *const gchar,
    pub package: *const gchar,
    pub origin: *const gchar,
    pub release_datetime: *const gchar,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPluginDesc {
    fn default() -> Struct__GstPluginDesc { unsafe { ::std::mem::zeroed() } }
}
pub type GstPluginFilter =
    ::std::option::Option<extern "C" fn
                              (plugin: *mut GstPlugin, user_data: gpointer)
                              -> gboolean>;
pub enum Struct__GstPluginFeature { }
pub type GstPluginFeature = Struct__GstPluginFeature;
pub enum Struct__GstPluginFeatureClass { }
pub type GstPluginFeatureClass = Struct__GstPluginFeatureClass;
pub type Enum_Unnamed180 = ::libc::c_uint;
pub const GST_RANK_NONE: ::libc::c_uint = 0;
pub const GST_RANK_MARGINAL: ::libc::c_uint = 64;
pub const GST_RANK_SECONDARY: ::libc::c_uint = 128;
pub const GST_RANK_PRIMARY: ::libc::c_uint = 256;
pub type GstRank = Enum_Unnamed180;
pub type GstPluginFeatureFilter =
    ::std::option::Option<extern "C" fn
                              (feature: *mut GstPluginFeature,
                               user_data: gpointer) -> gboolean>;
pub type Enum_Unnamed181 = ::libc::c_uint;
pub const GST_URI_ERROR_UNSUPPORTED_PROTOCOL: ::libc::c_uint = 0;
pub const GST_URI_ERROR_BAD_URI: ::libc::c_uint = 1;
pub const GST_URI_ERROR_BAD_STATE: ::libc::c_uint = 2;
pub const GST_URI_ERROR_BAD_REFERENCE: ::libc::c_uint = 3;
pub type GstURIError = Enum_Unnamed181;
pub type Enum_Unnamed182 = ::libc::c_uint;
pub const GST_URI_UNKNOWN: ::libc::c_uint = 0;
pub const GST_URI_SINK: ::libc::c_uint = 1;
pub const GST_URI_SRC: ::libc::c_uint = 2;
pub type GstURIType = Enum_Unnamed182;
pub enum Struct__GstURIHandler { }
pub type GstURIHandler = Struct__GstURIHandler;
pub type GstURIHandlerInterface = Struct__GstURIHandlerInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstURIHandlerInterface {
    pub parent: GTypeInterface,
    pub get_type: ::std::option::Option<extern "C" fn(_type: GType)
                                            -> GstURIType>,
    pub get_protocols: ::std::option::Option<extern "C" fn(_type: GType)
                                                 -> *const *const gchar>,
    pub get_uri: ::std::option::Option<extern "C" fn
                                           (handler: *mut GstURIHandler)
                                           -> *mut gchar>,
    pub set_uri: ::std::option::Option<extern "C" fn
                                           (handler: *mut GstURIHandler,
                                            uri: *const gchar,
                                            error: *mut *mut GError)
                                           -> gboolean>,
}
impl ::std::default::Default for Struct__GstURIHandlerInterface {
    fn default() -> Struct__GstURIHandlerInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstElementFactoryListType = guint64;
pub type Enum_Unnamed183 = ::libc::c_uint;
pub const GST_STATE_CHANGE_FAILURE: ::libc::c_uint = 0;
pub const GST_STATE_CHANGE_SUCCESS: ::libc::c_uint = 1;
pub const GST_STATE_CHANGE_ASYNC: ::libc::c_uint = 2;
pub const GST_STATE_CHANGE_NO_PREROLL: ::libc::c_uint = 3;
pub type GstStateChangeReturn = Enum_Unnamed183;
pub type Enum_Unnamed184 = ::libc::c_uint;
pub const GST_STATE_CHANGE_NULL_TO_READY: ::libc::c_uint = 10;
pub const GST_STATE_CHANGE_READY_TO_PAUSED: ::libc::c_uint = 19;
pub const GST_STATE_CHANGE_PAUSED_TO_PLAYING: ::libc::c_uint = 28;
pub const GST_STATE_CHANGE_PLAYING_TO_PAUSED: ::libc::c_uint = 35;
pub const GST_STATE_CHANGE_PAUSED_TO_READY: ::libc::c_uint = 26;
pub const GST_STATE_CHANGE_READY_TO_NULL: ::libc::c_uint = 17;
pub type GstStateChange = Enum_Unnamed184;
pub type Enum_Unnamed185 = ::libc::c_uint;
pub const GST_ELEMENT_FLAG_LOCKED_STATE: ::libc::c_uint = 16;
pub const GST_ELEMENT_FLAG_SINK: ::libc::c_uint = 32;
pub const GST_ELEMENT_FLAG_SOURCE: ::libc::c_uint = 64;
pub const GST_ELEMENT_FLAG_PROVIDE_CLOCK: ::libc::c_uint = 128;
pub const GST_ELEMENT_FLAG_REQUIRE_CLOCK: ::libc::c_uint = 256;
pub const GST_ELEMENT_FLAG_INDEXABLE: ::libc::c_uint = 512;
pub const GST_ELEMENT_FLAG_LAST: ::libc::c_uint = 16384;
pub type GstElementFlags = Enum_Unnamed185;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstElement {
    pub object: GstObject,
    pub state_lock: GRecMutex,
    pub state_cond: GCond,
    pub state_cookie: guint32,
    pub target_state: GstState,
    pub current_state: GstState,
    pub next_state: GstState,
    pub pending_state: GstState,
    pub last_return: GstStateChangeReturn,
    pub bus: *mut GstBus,
    pub clock: *mut GstClock,
    pub base_time: GstClockTimeDiff,
    pub start_time: GstClockTime,
    pub numpads: guint16,
    pub pads: *mut GList,
    pub numsrcpads: guint16,
    pub srcpads: *mut GList,
    pub numsinkpads: guint16,
    pub sinkpads: *mut GList,
    pub pads_cookie: guint32,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstElement {
    fn default() -> Struct__GstElement { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstElementClass {
    pub parent_class: GstObjectClass,
    pub metadata: gpointer,
    pub elementfactory: *mut GstElementFactory,
    pub padtemplates: *mut GList,
    pub numpadtemplates: gint,
    pub pad_templ_cookie: guint32,
    pub pad_added: ::std::option::Option<extern "C" fn
                                             (element: *mut GstElement,
                                              pad: *mut GstPad)>,
    pub pad_removed: ::std::option::Option<extern "C" fn
                                               (element: *mut GstElement,
                                                pad: *mut GstPad)>,
    pub no_more_pads: ::std::option::Option<extern "C" fn
                                                (element: *mut GstElement)>,
    pub request_new_pad: ::std::option::Option<extern "C" fn
                                                   (element: *mut GstElement,
                                                    templ:
                                                        *mut GstPadTemplate,
                                                    name: *const gchar,
                                                    caps: *const GstCaps)
                                                   -> *mut GstPad>,
    pub release_pad: ::std::option::Option<extern "C" fn
                                               (element: *mut GstElement,
                                                pad: *mut GstPad)>,
    pub get_state: ::std::option::Option<extern "C" fn
                                             (element: *mut GstElement,
                                              state: *mut GstState,
                                              pending: *mut GstState,
                                              timeout: GstClockTime)
                                             -> GstStateChangeReturn>,
    pub set_state: ::std::option::Option<extern "C" fn
                                             (element: *mut GstElement,
                                              state: GstState)
                                             -> GstStateChangeReturn>,
    pub change_state: ::std::option::Option<extern "C" fn
                                                (element: *mut GstElement,
                                                 transition: GstStateChange)
                                                -> GstStateChangeReturn>,
    pub state_changed: ::std::option::Option<extern "C" fn
                                                 (element: *mut GstElement,
                                                  oldstate: GstState,
                                                  newstate: GstState,
                                                  pending: GstState)>,
    pub set_bus: ::std::option::Option<extern "C" fn
                                           (element: *mut GstElement,
                                            bus: *mut GstBus)>,
    pub provide_clock: ::std::option::Option<extern "C" fn
                                                 (element: *mut GstElement)
                                                 -> *mut GstClock>,
    pub set_clock: ::std::option::Option<extern "C" fn
                                             (element: *mut GstElement,
                                              clock: *mut GstClock)
                                             -> gboolean>,
    pub send_event: ::std::option::Option<extern "C" fn
                                              (element: *mut GstElement,
                                               event: *mut GstEvent)
                                              -> gboolean>,
    pub query: ::std::option::Option<extern "C" fn
                                         (element: *mut GstElement,
                                          query: *mut GstQuery) -> gboolean>,
    pub post_message: ::std::option::Option<extern "C" fn
                                                (element: *mut GstElement,
                                                 message: *mut GstMessage)
                                                -> gboolean>,
    pub set_context: ::std::option::Option<extern "C" fn
                                               (element: *mut GstElement,
                                                context: *mut GstContext)>,
    pub _gst_reserved: [gpointer; 18u],
}
impl ::std::default::Default for Struct__GstElementClass {
    fn default() -> Struct__GstElementClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed186 = ::libc::c_uint;
pub const GST_BIN_FLAG_NO_RESYNC: ::libc::c_uint = 16384;
pub const GST_BIN_FLAG_LAST: ::libc::c_uint = 524288;
pub type GstBinFlags = Enum_Unnamed186;
pub type GstBin = Struct__GstBin;
pub type GstBinClass = Struct__GstBinClass;
pub enum Struct__GstBinPrivate { }
pub type GstBinPrivate = Struct__GstBinPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBin {
    pub element: GstElement,
    pub numchildren: gint,
    pub children: *mut GList,
    pub children_cookie: guint32,
    pub child_bus: *mut GstBus,
    pub messages: *mut GList,
    pub polling: gboolean,
    pub state_dirty: gboolean,
    pub clock_dirty: gboolean,
    pub provided_clock: *mut GstClock,
    pub clock_provider: *mut GstElement,
    pub _priv: *mut GstBinPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstBin {
    fn default() -> Struct__GstBin { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBinClass {
    pub parent_class: GstElementClass,
    pub pool: *mut GThreadPool,
    pub element_added: ::std::option::Option<extern "C" fn
                                                 (bin: *mut GstBin,
                                                  child: *mut GstElement)>,
    pub element_removed: ::std::option::Option<extern "C" fn
                                                   (bin: *mut GstBin,
                                                    child: *mut GstElement)>,
    pub add_element: ::std::option::Option<extern "C" fn
                                               (bin: *mut GstBin,
                                                element: *mut GstElement)
                                               -> gboolean>,
    pub remove_element: ::std::option::Option<extern "C" fn
                                                  (bin: *mut GstBin,
                                                   element: *mut GstElement)
                                                  -> gboolean>,
    pub handle_message: ::std::option::Option<extern "C" fn
                                                  (bin: *mut GstBin,
                                                   message: *mut GstMessage)>,
    pub do_latency: ::std::option::Option<extern "C" fn(bin: *mut GstBin)
                                              -> gboolean>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstBinClass {
    fn default() -> Struct__GstBinClass { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GstBufferPoolPrivate { }
pub type GstBufferPoolPrivate = Struct__GstBufferPoolPrivate;
pub type GstBufferPoolClass = Struct__GstBufferPoolClass;
pub type Enum_Unnamed187 = ::libc::c_uint;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT: ::libc::c_uint = 1;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT: ::libc::c_uint = 2;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT: ::libc::c_uint = 4;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_LAST: ::libc::c_uint = 65536;
pub type GstBufferPoolAcquireFlags = Enum_Unnamed187;
pub type GstBufferPoolAcquireParams = Struct__GstBufferPoolAcquireParams;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBufferPoolAcquireParams {
    pub format: GstFormat,
    pub start: gint64,
    pub stop: gint64,
    pub flags: GstBufferPoolAcquireFlags,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstBufferPoolAcquireParams {
    fn default() -> Struct__GstBufferPoolAcquireParams {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBufferPool {
    pub object: GstObject,
    pub flushing: gint,
    pub _priv: *mut GstBufferPoolPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstBufferPool {
    fn default() -> Struct__GstBufferPool { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBufferPoolClass {
    pub object_class: GstObjectClass,
    pub get_options: ::std::option::Option<extern "C" fn
                                               (pool: *mut GstBufferPool)
                                               -> *mut *const gchar>,
    pub set_config: ::std::option::Option<extern "C" fn
                                              (pool: *mut GstBufferPool,
                                               config: *mut GstStructure)
                                              -> gboolean>,
    pub start: ::std::option::Option<extern "C" fn(pool: *mut GstBufferPool)
                                         -> gboolean>,
    pub stop: ::std::option::Option<extern "C" fn(pool: *mut GstBufferPool)
                                        -> gboolean>,
    pub acquire_buffer: ::std::option::Option<extern "C" fn
                                                  (pool: *mut GstBufferPool,
                                                   buffer:
                                                       *mut *mut GstBuffer,
                                                   params:
                                                       *mut GstBufferPoolAcquireParams)
                                                  -> GstFlowReturn>,
    pub alloc_buffer: ::std::option::Option<extern "C" fn
                                                (pool: *mut GstBufferPool,
                                                 buffer: *mut *mut GstBuffer,
                                                 params:
                                                     *mut GstBufferPoolAcquireParams)
                                                -> GstFlowReturn>,
    pub reset_buffer: ::std::option::Option<extern "C" fn
                                                (pool: *mut GstBufferPool,
                                                 buffer: *mut GstBuffer)>,
    pub release_buffer: ::std::option::Option<extern "C" fn
                                                  (pool: *mut GstBufferPool,
                                                   buffer: *mut GstBuffer)>,
    pub free_buffer: ::std::option::Option<extern "C" fn
                                               (pool: *mut GstBufferPool,
                                                buffer: *mut GstBuffer)>,
    pub flush_start: ::std::option::Option<extern "C" fn
                                               (pool: *mut GstBufferPool)>,
    pub flush_stop: ::std::option::Option<extern "C" fn
                                              (pool: *mut GstBufferPool)>,
    pub _gst_reserved: [gpointer; 2u],
}
impl ::std::default::Default for Struct__GstBufferPoolClass {
    fn default() -> Struct__GstBufferPoolClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstChildProxy { }
pub type GstChildProxy = Struct__GstChildProxy;
pub type GstChildProxyInterface = Struct__GstChildProxyInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstChildProxyInterface {
    pub parent: GTypeInterface,
    pub get_child_by_name: ::std::option::Option<extern "C" fn
                                                     (parent:
                                                          *mut GstChildProxy,
                                                      name: *const gchar)
                                                     -> *mut GObject>,
    pub get_child_by_index: ::std::option::Option<extern "C" fn
                                                      (parent:
                                                           *mut GstChildProxy,
                                                       index: guint)
                                                      -> *mut GObject>,
    pub get_children_count: ::std::option::Option<extern "C" fn
                                                      (parent:
                                                           *mut GstChildProxy)
                                                      -> guint>,
    pub child_added: ::std::option::Option<extern "C" fn
                                               (parent: *mut GstChildProxy,
                                                child: *mut GObject,
                                                name: *const gchar)>,
    pub child_removed: ::std::option::Option<extern "C" fn
                                                 (parent: *mut GstChildProxy,
                                                  child: *mut GObject,
                                                  name: *const gchar)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstChildProxyInterface {
    fn default() -> Struct__GstChildProxyInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed188 = ::libc::c_uint;
pub const GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE: ::libc::c_uint = 1;
pub const GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS: ::libc::c_uint = 2;
pub const GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS: ::libc::c_uint = 4;
pub const GST_DEBUG_GRAPH_SHOW_STATES: ::libc::c_uint = 8;
pub const GST_DEBUG_GRAPH_SHOW_ALL: ::libc::c_uint = 15;
pub type GstDebugGraphDetails = Enum_Unnamed188;
pub enum Struct__GstDeviceProviderFactory { }
pub type GstDeviceProviderFactory = Struct__GstDeviceProviderFactory;
pub enum Struct__GstDeviceProviderFactoryClass { }
pub type GstDeviceProviderFactoryClass =
    Struct__GstDeviceProviderFactoryClass;
pub type GstDeviceProvider = Struct__GstDeviceProvider;
pub type GstDeviceProviderClass = Struct__GstDeviceProviderClass;
pub enum Struct__GstDeviceProviderPrivate { }
pub type GstDeviceProviderPrivate = Struct__GstDeviceProviderPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstDeviceProvider {
    pub parent: GstObject,
    pub devices: *mut GList,
    pub _priv: *mut GstDeviceProviderPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstDeviceProvider {
    fn default() -> Struct__GstDeviceProvider {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstDeviceProviderClass {
    pub parent_class: GstObjectClass,
    pub factory: *mut GstDeviceProviderFactory,
    pub probe: ::std::option::Option<extern "C" fn
                                         (provider: *mut GstDeviceProvider)
                                         -> *mut GList>,
    pub start: ::std::option::Option<extern "C" fn
                                         (provider: *mut GstDeviceProvider)
                                         -> gboolean>,
    pub stop: ::std::option::Option<extern "C" fn
                                        (provider: *mut GstDeviceProvider)>,
    pub metadata: gpointer,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstDeviceProviderClass {
    fn default() -> Struct__GstDeviceProviderClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed189 = ::libc::c_uint;
pub const GST_CORE_ERROR_FAILED: ::libc::c_uint = 1;
pub const GST_CORE_ERROR_TOO_LAZY: ::libc::c_uint = 2;
pub const GST_CORE_ERROR_NOT_IMPLEMENTED: ::libc::c_uint = 3;
pub const GST_CORE_ERROR_STATE_CHANGE: ::libc::c_uint = 4;
pub const GST_CORE_ERROR_PAD: ::libc::c_uint = 5;
pub const GST_CORE_ERROR_THREAD: ::libc::c_uint = 6;
pub const GST_CORE_ERROR_NEGOTIATION: ::libc::c_uint = 7;
pub const GST_CORE_ERROR_EVENT: ::libc::c_uint = 8;
pub const GST_CORE_ERROR_SEEK: ::libc::c_uint = 9;
pub const GST_CORE_ERROR_CAPS: ::libc::c_uint = 10;
pub const GST_CORE_ERROR_TAG: ::libc::c_uint = 11;
pub const GST_CORE_ERROR_MISSING_PLUGIN: ::libc::c_uint = 12;
pub const GST_CORE_ERROR_CLOCK: ::libc::c_uint = 13;
pub const GST_CORE_ERROR_DISABLED: ::libc::c_uint = 14;
pub const GST_CORE_ERROR_NUM_ERRORS: ::libc::c_uint = 15;
pub type GstCoreError = Enum_Unnamed189;
pub type Enum_Unnamed190 = ::libc::c_uint;
pub const GST_LIBRARY_ERROR_FAILED: ::libc::c_uint = 1;
pub const GST_LIBRARY_ERROR_TOO_LAZY: ::libc::c_uint = 2;
pub const GST_LIBRARY_ERROR_INIT: ::libc::c_uint = 3;
pub const GST_LIBRARY_ERROR_SHUTDOWN: ::libc::c_uint = 4;
pub const GST_LIBRARY_ERROR_SETTINGS: ::libc::c_uint = 5;
pub const GST_LIBRARY_ERROR_ENCODE: ::libc::c_uint = 6;
pub const GST_LIBRARY_ERROR_NUM_ERRORS: ::libc::c_uint = 7;
pub type GstLibraryError = Enum_Unnamed190;
pub type Enum_Unnamed191 = ::libc::c_uint;
pub const GST_RESOURCE_ERROR_FAILED: ::libc::c_uint = 1;
pub const GST_RESOURCE_ERROR_TOO_LAZY: ::libc::c_uint = 2;
pub const GST_RESOURCE_ERROR_NOT_FOUND: ::libc::c_uint = 3;
pub const GST_RESOURCE_ERROR_BUSY: ::libc::c_uint = 4;
pub const GST_RESOURCE_ERROR_OPEN_READ: ::libc::c_uint = 5;
pub const GST_RESOURCE_ERROR_OPEN_WRITE: ::libc::c_uint = 6;
pub const GST_RESOURCE_ERROR_OPEN_READ_WRITE: ::libc::c_uint = 7;
pub const GST_RESOURCE_ERROR_CLOSE: ::libc::c_uint = 8;
pub const GST_RESOURCE_ERROR_READ: ::libc::c_uint = 9;
pub const GST_RESOURCE_ERROR_WRITE: ::libc::c_uint = 10;
pub const GST_RESOURCE_ERROR_SEEK: ::libc::c_uint = 11;
pub const GST_RESOURCE_ERROR_SYNC: ::libc::c_uint = 12;
pub const GST_RESOURCE_ERROR_SETTINGS: ::libc::c_uint = 13;
pub const GST_RESOURCE_ERROR_NO_SPACE_LEFT: ::libc::c_uint = 14;
pub const GST_RESOURCE_ERROR_NOT_AUTHORIZED: ::libc::c_uint = 15;
pub const GST_RESOURCE_ERROR_NUM_ERRORS: ::libc::c_uint = 16;
pub type GstResourceError = Enum_Unnamed191;
pub type Enum_Unnamed192 = ::libc::c_uint;
pub const GST_STREAM_ERROR_FAILED: ::libc::c_uint = 1;
pub const GST_STREAM_ERROR_TOO_LAZY: ::libc::c_uint = 2;
pub const GST_STREAM_ERROR_NOT_IMPLEMENTED: ::libc::c_uint = 3;
pub const GST_STREAM_ERROR_TYPE_NOT_FOUND: ::libc::c_uint = 4;
pub const GST_STREAM_ERROR_WRONG_TYPE: ::libc::c_uint = 5;
pub const GST_STREAM_ERROR_CODEC_NOT_FOUND: ::libc::c_uint = 6;
pub const GST_STREAM_ERROR_DECODE: ::libc::c_uint = 7;
pub const GST_STREAM_ERROR_ENCODE: ::libc::c_uint = 8;
pub const GST_STREAM_ERROR_DEMUX: ::libc::c_uint = 9;
pub const GST_STREAM_ERROR_MUX: ::libc::c_uint = 10;
pub const GST_STREAM_ERROR_FORMAT: ::libc::c_uint = 11;
pub const GST_STREAM_ERROR_DECRYPT: ::libc::c_uint = 12;
pub const GST_STREAM_ERROR_DECRYPT_NOKEY: ::libc::c_uint = 13;
pub const GST_STREAM_ERROR_NUM_ERRORS: ::libc::c_uint = 14;
pub type GstStreamError = Enum_Unnamed192;
pub type GstProxyPad = Struct__GstProxyPad;
pub enum Struct__GstProxyPadPrivate { }
pub type GstProxyPadPrivate = Struct__GstProxyPadPrivate;
pub type GstProxyPadClass = Struct__GstProxyPadClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstProxyPad {
    pub pad: GstPad,
    pub _priv: *mut GstProxyPadPrivate,
}
impl ::std::default::Default for Struct__GstProxyPad {
    fn default() -> Struct__GstProxyPad { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstProxyPadClass {
    pub parent_class: GstPadClass,
    pub _gst_reserved: [gpointer; 1u],
}
impl ::std::default::Default for Struct__GstProxyPadClass {
    fn default() -> Struct__GstProxyPadClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstGhostPad = Struct__GstGhostPad;
pub enum Struct__GstGhostPadPrivate { }
pub type GstGhostPadPrivate = Struct__GstGhostPadPrivate;
pub type GstGhostPadClass = Struct__GstGhostPadClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstGhostPad {
    pub pad: GstProxyPad,
    pub _priv: *mut GstGhostPadPrivate,
}
impl ::std::default::Default for Struct__GstGhostPad {
    fn default() -> Struct__GstGhostPad { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstGhostPadClass {
    pub parent_class: GstProxyPadClass,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstGhostPadClass {
    fn default() -> Struct__GstGhostPadClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstDeviceMonitor = Struct__GstDeviceMonitor;
pub enum Struct__GstDeviceMonitorPrivate { }
pub type GstDeviceMonitorPrivate = Struct__GstDeviceMonitorPrivate;
pub type GstDeviceMonitorClass = Struct__GstDeviceMonitorClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstDeviceMonitor {
    pub parent: GstObject,
    pub _priv: *mut GstDeviceMonitorPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstDeviceMonitor {
    fn default() -> Struct__GstDeviceMonitor {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstDeviceMonitorClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstDeviceMonitorClass {
    fn default() -> Struct__GstDeviceMonitorClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed193 = ::libc::c_uint;
pub const GST_LEVEL_NONE: ::libc::c_uint = 0;
pub const GST_LEVEL_ERROR: ::libc::c_uint = 1;
pub const GST_LEVEL_WARNING: ::libc::c_uint = 2;
pub const GST_LEVEL_FIXME: ::libc::c_uint = 3;
pub const GST_LEVEL_INFO: ::libc::c_uint = 4;
pub const GST_LEVEL_DEBUG: ::libc::c_uint = 5;
pub const GST_LEVEL_LOG: ::libc::c_uint = 6;
pub const GST_LEVEL_TRACE: ::libc::c_uint = 7;
pub const GST_LEVEL_MEMDUMP: ::libc::c_uint = 9;
pub const GST_LEVEL_COUNT: ::libc::c_uint = 10;
pub type GstDebugLevel = Enum_Unnamed193;
pub type Enum_Unnamed194 = ::libc::c_uint;
pub const GST_DEBUG_FG_BLACK: ::libc::c_uint = 0;
pub const GST_DEBUG_FG_RED: ::libc::c_uint = 1;
pub const GST_DEBUG_FG_GREEN: ::libc::c_uint = 2;
pub const GST_DEBUG_FG_YELLOW: ::libc::c_uint = 3;
pub const GST_DEBUG_FG_BLUE: ::libc::c_uint = 4;
pub const GST_DEBUG_FG_MAGENTA: ::libc::c_uint = 5;
pub const GST_DEBUG_FG_CYAN: ::libc::c_uint = 6;
pub const GST_DEBUG_FG_WHITE: ::libc::c_uint = 7;
pub const GST_DEBUG_BG_BLACK: ::libc::c_uint = 0;
pub const GST_DEBUG_BG_RED: ::libc::c_uint = 16;
pub const GST_DEBUG_BG_GREEN: ::libc::c_uint = 32;
pub const GST_DEBUG_BG_YELLOW: ::libc::c_uint = 48;
pub const GST_DEBUG_BG_BLUE: ::libc::c_uint = 64;
pub const GST_DEBUG_BG_MAGENTA: ::libc::c_uint = 80;
pub const GST_DEBUG_BG_CYAN: ::libc::c_uint = 96;
pub const GST_DEBUG_BG_WHITE: ::libc::c_uint = 112;
pub const GST_DEBUG_BOLD: ::libc::c_uint = 256;
pub const GST_DEBUG_UNDERLINE: ::libc::c_uint = 512;
pub type GstDebugColorFlags = Enum_Unnamed194;
pub type Enum_Unnamed195 = ::libc::c_uint;
pub const GST_DEBUG_COLOR_MODE_OFF: ::libc::c_uint = 0;
pub const GST_DEBUG_COLOR_MODE_ON: ::libc::c_uint = 1;
pub const GST_DEBUG_COLOR_MODE_UNIX: ::libc::c_uint = 2;
pub type GstDebugColorMode = Enum_Unnamed195;
pub type GstDebugCategory = Struct__GstDebugCategory;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstDebugCategory {
    pub threshold: gint,
    pub color: guint,
    pub name: *const gchar,
    pub description: *const gchar,
}
impl ::std::default::Default for Struct__GstDebugCategory {
    fn default() -> Struct__GstDebugCategory {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstDebugMessage { }
pub type GstDebugMessage = Struct__GstDebugMessage;
pub type GstLogFunction =
    ::std::option::Option<extern "C" fn
                              (category: *mut GstDebugCategory,
                               level: GstDebugLevel, file: *const gchar,
                               function: *const gchar, line: gint,
                               object: *mut GObject,
                               message: *mut GstDebugMessage,
                               user_data: gpointer)>;
pub type GstDebugFuncPtr = ::std::option::Option<extern "C" fn()>;
pub type GstValueCompareFunc =
    ::std::option::Option<extern "C" fn
                              (value1: *const GValue, value2: *const GValue)
                              -> gint>;
pub type GstValueSerializeFunc =
    ::std::option::Option<extern "C" fn(value1: *const GValue) -> *mut gchar>;
pub type GstValueDeserializeFunc =
    ::std::option::Option<extern "C" fn(dest: *mut GValue, s: *const gchar)
                              -> gboolean>;
pub type GstValueTable = Struct__GstValueTable;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstValueTable {
    pub _type: GType,
    pub compare: GstValueCompareFunc,
    pub serialize: GstValueSerializeFunc,
    pub deserialize: GstValueDeserializeFunc,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstValueTable {
    fn default() -> Struct__GstValueTable { unsafe { ::std::mem::zeroed() } }
}
pub type GstParamSpecFraction = Struct__GstParamSpecFraction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstParamSpecFraction {
    pub parent_instance: GParamSpec,
    pub min_num: gint,
    pub min_den: gint,
    pub max_num: gint,
    pub max_den: gint,
    pub def_num: gint,
    pub def_den: gint,
}
impl ::std::default::Default for Struct__GstParamSpecFraction {
    fn default() -> Struct__GstParamSpecFraction {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstPipeline = Struct__GstPipeline;
pub type GstPipelineClass = Struct__GstPipelineClass;
pub enum Struct__GstPipelinePrivate { }
pub type GstPipelinePrivate = Struct__GstPipelinePrivate;
pub type Enum_Unnamed196 = ::libc::c_uint;
pub const GST_PIPELINE_FLAG_FIXED_CLOCK: ::libc::c_uint = 524288;
pub const GST_PIPELINE_FLAG_LAST: ::libc::c_uint = 8388608;
pub type GstPipelineFlags = Enum_Unnamed196;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPipeline {
    pub bin: GstBin,
    pub fixed_clock: *mut GstClock,
    pub stream_time: GstClockTime,
    pub delay: GstClockTime,
    pub _priv: *mut GstPipelinePrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPipeline {
    fn default() -> Struct__GstPipeline { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPipelineClass {
    pub parent_class: GstBinClass,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPipelineClass {
    fn default() -> Struct__GstPipelineClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstPoll { }
pub type GstPoll = Struct__GstPoll;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed197 {
    pub fd: ::libc::c_int,
    pub idx: gint,
}
impl ::std::default::Default for Struct_Unnamed197 {
    fn default() -> Struct_Unnamed197 { unsafe { ::std::mem::zeroed() } }
}
pub type GstPollFD = Struct_Unnamed197;
pub enum Struct__GstPreset { }
pub type GstPreset = Struct__GstPreset;
pub type GstPresetInterface = Struct__GstPresetInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPresetInterface {
    pub parent: GTypeInterface,
    pub get_preset_names: ::std::option::Option<extern "C" fn
                                                    (preset: *mut GstPreset)
                                                    -> *mut *mut gchar>,
    pub get_property_names: ::std::option::Option<extern "C" fn
                                                      (preset: *mut GstPreset)
                                                      -> *mut *mut gchar>,
    pub load_preset: ::std::option::Option<extern "C" fn
                                               (preset: *mut GstPreset,
                                                name: *const gchar)
                                               -> gboolean>,
    pub save_preset: ::std::option::Option<extern "C" fn
                                               (preset: *mut GstPreset,
                                                name: *const gchar)
                                               -> gboolean>,
    pub rename_preset: ::std::option::Option<extern "C" fn
                                                 (preset: *mut GstPreset,
                                                  old_name: *const gchar,
                                                  new_name: *const gchar)
                                                 -> gboolean>,
    pub delete_preset: ::std::option::Option<extern "C" fn
                                                 (preset: *mut GstPreset,
                                                  name: *const gchar)
                                                 -> gboolean>,
    pub set_meta: ::std::option::Option<extern "C" fn
                                            (preset: *mut GstPreset,
                                             name: *const gchar,
                                             tag: *const gchar,
                                             value: *const gchar)
                                            -> gboolean>,
    pub get_meta: ::std::option::Option<extern "C" fn
                                            (preset: *mut GstPreset,
                                             name: *const gchar,
                                             tag: *const gchar,
                                             value: *mut *mut gchar)
                                            -> gboolean>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPresetInterface {
    fn default() -> Struct__GstPresetInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstRegistry = Struct__GstRegistry;
pub type GstRegistryClass = Struct__GstRegistryClass;
pub enum Struct__GstRegistryPrivate { }
pub type GstRegistryPrivate = Struct__GstRegistryPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstRegistry {
    pub object: GstObject,
    pub _priv: *mut GstRegistryPrivate,
}
impl ::std::default::Default for Struct__GstRegistry {
    fn default() -> Struct__GstRegistry { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstRegistryClass {
    pub parent_class: GstObjectClass,
}
impl ::std::default::Default for Struct__GstRegistryClass {
    fn default() -> Struct__GstRegistryClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstSystemClock = Struct__GstSystemClock;
pub type GstSystemClockClass = Struct__GstSystemClockClass;
pub enum Struct__GstSystemClockPrivate { }
pub type GstSystemClockPrivate = Struct__GstSystemClockPrivate;
pub type Enum_Unnamed198 = ::libc::c_uint;
pub const GST_CLOCK_TYPE_REALTIME: ::libc::c_uint = 0;
pub const GST_CLOCK_TYPE_MONOTONIC: ::libc::c_uint = 1;
pub const GST_CLOCK_TYPE_OTHER: ::libc::c_uint = 2;
pub type GstClockType = Enum_Unnamed198;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstSystemClock {
    pub clock: GstClock,
    pub _priv: *mut GstSystemClockPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstSystemClock {
    fn default() -> Struct__GstSystemClock { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstSystemClockClass {
    pub parent_class: GstClockClass,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstSystemClockClass {
    fn default() -> Struct__GstSystemClockClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstTagSetter { }
pub type GstTagSetter = Struct__GstTagSetter;
pub type GstTagSetterInterface = Struct__GstTagSetterInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTagSetterInterface {
    pub g_iface: GTypeInterface,
}
impl ::std::default::Default for Struct__GstTagSetterInterface {
    fn default() -> Struct__GstTagSetterInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstTocSetter { }
pub type GstTocSetter = Struct__GstTocSetter;
pub type GstTocSetterInterface = Struct__GstTocSetterInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTocSetterInterface {
    pub g_iface: GTypeInterface,
}
impl ::std::default::Default for Struct__GstTocSetterInterface {
    fn default() -> Struct__GstTocSetterInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstTypeFind = Struct__GstTypeFind;
pub type GstTypeFindFunction =
    ::std::option::Option<extern "C" fn
                              (find: *mut GstTypeFind, user_data: gpointer)>;
pub type Enum_Unnamed199 = ::libc::c_uint;
pub const GST_TYPE_FIND_NONE: ::libc::c_uint = 0;
pub const GST_TYPE_FIND_MINIMUM: ::libc::c_uint = 1;
pub const GST_TYPE_FIND_POSSIBLE: ::libc::c_uint = 50;
pub const GST_TYPE_FIND_LIKELY: ::libc::c_uint = 80;
pub const GST_TYPE_FIND_NEARLY_CERTAIN: ::libc::c_uint = 99;
pub const GST_TYPE_FIND_MAXIMUM: ::libc::c_uint = 100;
pub type GstTypeFindProbability = Enum_Unnamed199;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstTypeFind {
    pub peek: ::std::option::Option<extern "C" fn
                                        (data: gpointer, offset: gint64,
                                         size: guint) -> *const guint8>,
    pub suggest: ::std::option::Option<extern "C" fn
                                           (data: gpointer,
                                            probability: guint,
                                            caps: *mut GstCaps)>,
    pub data: gpointer,
    pub get_length: ::std::option::Option<extern "C" fn(data: gpointer)
                                              -> guint64>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstTypeFind {
    fn default() -> Struct__GstTypeFind { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GstTypeFindFactory { }
pub type GstTypeFindFactory = Struct__GstTypeFindFactory;
pub enum Struct__GstTypeFindFactoryClass { }
pub type GstTypeFindFactoryClass = Struct__GstTypeFindFactoryClass;
pub type Enum_Unnamed200 = ::libc::c_uint;
pub const GST_PARSE_ERROR_SYNTAX: ::libc::c_uint = 0;
pub const GST_PARSE_ERROR_NO_SUCH_ELEMENT: ::libc::c_uint = 1;
pub const GST_PARSE_ERROR_NO_SUCH_PROPERTY: ::libc::c_uint = 2;
pub const GST_PARSE_ERROR_LINK: ::libc::c_uint = 3;
pub const GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY: ::libc::c_uint = 4;
pub const GST_PARSE_ERROR_EMPTY_BIN: ::libc::c_uint = 5;
pub const GST_PARSE_ERROR_EMPTY: ::libc::c_uint = 6;
pub type GstParseError = Enum_Unnamed200;
pub type Enum_Unnamed201 = ::libc::c_uint;
pub const GST_PARSE_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_PARSE_FLAG_FATAL_ERRORS: ::libc::c_uint = 1;
pub const GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS: ::libc::c_uint = 2;
pub type GstParseFlags = Enum_Unnamed201;
pub enum Struct__GstParseContext { }
pub type GstParseContext = Struct__GstParseContext;
pub type Enum_Unnamed202 = ::libc::c_uint;
pub const GST_SEARCH_MODE_EXACT: ::libc::c_uint = 0;
pub const GST_SEARCH_MODE_BEFORE: ::libc::c_uint = 1;
pub const GST_SEARCH_MODE_AFTER: ::libc::c_uint = 2;
pub type GstSearchMode = Enum_Unnamed202;
pub type GstBaseSink = Struct__GstBaseSink;
pub type GstBaseSinkClass = Struct__GstBaseSinkClass;
pub enum Struct__GstBaseSinkPrivate { }
pub type GstBaseSinkPrivate = Struct__GstBaseSinkPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBaseSink {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub pad_mode: GstPadMode,
    pub offset: guint64,
    pub can_activate_pull: gboolean,
    pub can_activate_push: gboolean,
    pub preroll_lock: GMutex,
    pub preroll_cond: GCond,
    pub eos: gboolean,
    pub need_preroll: gboolean,
    pub have_preroll: gboolean,
    pub playing_async: gboolean,
    pub have_newsegment: gboolean,
    pub segment: GstSegment,
    pub clock_id: GstClockID,
    pub sync: gboolean,
    pub flushing: gboolean,
    pub running: gboolean,
    pub max_lateness: gint64,
    pub _priv: *mut GstBaseSinkPrivate,
    pub _gst_reserved: [gpointer; 20u],
}
impl ::std::default::Default for Struct__GstBaseSink {
    fn default() -> Struct__GstBaseSink { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBaseSinkClass {
    pub parent_class: GstElementClass,
    pub get_caps: ::std::option::Option<extern "C" fn
                                            (sink: *mut GstBaseSink,
                                             filter: *mut GstCaps)
                                            -> *mut GstCaps>,
    pub set_caps: ::std::option::Option<extern "C" fn
                                            (sink: *mut GstBaseSink,
                                             caps: *mut GstCaps) -> gboolean>,
    pub fixate: ::std::option::Option<extern "C" fn
                                          (sink: *mut GstBaseSink,
                                           caps: *mut GstCaps)
                                          -> *mut GstCaps>,
    pub activate_pull: ::std::option::Option<extern "C" fn
                                                 (sink: *mut GstBaseSink,
                                                  active: gboolean)
                                                 -> gboolean>,
    pub get_times: ::std::option::Option<extern "C" fn
                                             (sink: *mut GstBaseSink,
                                              buffer: *mut GstBuffer,
                                              start: *mut GstClockTime,
                                              end: *mut GstClockTime)>,
    pub propose_allocation: ::std::option::Option<extern "C" fn
                                                      (sink: *mut GstBaseSink,
                                                       query: *mut GstQuery)
                                                      -> gboolean>,
    pub start: ::std::option::Option<extern "C" fn(sink: *mut GstBaseSink)
                                         -> gboolean>,
    pub stop: ::std::option::Option<extern "C" fn(sink: *mut GstBaseSink)
                                        -> gboolean>,
    pub unlock: ::std::option::Option<extern "C" fn(sink: *mut GstBaseSink)
                                          -> gboolean>,
    pub unlock_stop: ::std::option::Option<extern "C" fn
                                               (sink: *mut GstBaseSink)
                                               -> gboolean>,
    pub query: ::std::option::Option<extern "C" fn
                                         (sink: *mut GstBaseSink,
                                          query: *mut GstQuery) -> gboolean>,
    pub event: ::std::option::Option<extern "C" fn
                                         (sink: *mut GstBaseSink,
                                          event: *mut GstEvent) -> gboolean>,
    pub wait_event: ::std::option::Option<extern "C" fn
                                              (sink: *mut GstBaseSink,
                                               event: *mut GstEvent)
                                              -> GstFlowReturn>,
    pub prepare: ::std::option::Option<extern "C" fn
                                           (sink: *mut GstBaseSink,
                                            buffer: *mut GstBuffer)
                                           -> GstFlowReturn>,
    pub prepare_list: ::std::option::Option<extern "C" fn
                                                (sink: *mut GstBaseSink,
                                                 buffer_list:
                                                     *mut GstBufferList)
                                                -> GstFlowReturn>,
    pub preroll: ::std::option::Option<extern "C" fn
                                           (sink: *mut GstBaseSink,
                                            buffer: *mut GstBuffer)
                                           -> GstFlowReturn>,
    pub render: ::std::option::Option<extern "C" fn
                                          (sink: *mut GstBaseSink,
                                           buffer: *mut GstBuffer)
                                          -> GstFlowReturn>,
    pub render_list: ::std::option::Option<extern "C" fn
                                               (sink: *mut GstBaseSink,
                                                buffer_list:
                                                    *mut GstBufferList)
                                               -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 20u],
}
impl ::std::default::Default for Struct__GstBaseSinkClass {
    fn default() -> Struct__GstBaseSinkClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstAppSink = Struct__GstAppSink;
pub type GstAppSinkClass = Struct__GstAppSinkClass;
pub enum Struct__GstAppSinkPrivate { }
pub type GstAppSinkPrivate = Struct__GstAppSinkPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed203 {
    pub eos: ::std::option::Option<extern "C" fn
                                       (appsink: *mut GstAppSink,
                                        user_data: gpointer)>,
    pub new_preroll: ::std::option::Option<extern "C" fn
                                               (appsink: *mut GstAppSink,
                                                user_data: gpointer)
                                               -> GstFlowReturn>,
    pub new_sample: ::std::option::Option<extern "C" fn
                                              (appsink: *mut GstAppSink,
                                               user_data: gpointer)
                                              -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct_Unnamed203 {
    fn default() -> Struct_Unnamed203 { unsafe { ::std::mem::zeroed() } }
}
pub type GstAppSinkCallbacks = Struct_Unnamed203;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstAppSink {
    pub basesink: GstBaseSink,
    pub _priv: *mut GstAppSinkPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstAppSink {
    fn default() -> Struct__GstAppSink { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstAppSinkClass {
    pub basesink_class: GstBaseSinkClass,
    pub eos: ::std::option::Option<extern "C" fn(appsink: *mut GstAppSink)>,
    pub new_preroll: ::std::option::Option<extern "C" fn
                                               (appsink: *mut GstAppSink)
                                               -> GstFlowReturn>,
    pub new_sample: ::std::option::Option<extern "C" fn
                                              (appsink: *mut GstAppSink)
                                              -> GstFlowReturn>,
    pub pull_preroll: ::std::option::Option<extern "C" fn
                                                (appsink: *mut GstAppSink)
                                                -> *mut GstSample>,
    pub pull_sample: ::std::option::Option<extern "C" fn
                                               (appsink: *mut GstAppSink)
                                               -> *mut GstSample>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstAppSinkClass {
    fn default() -> Struct__GstAppSinkClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed204 = ::libc::c_uint;
pub const GST_BASE_SRC_FLAG_STARTING: ::libc::c_uint = 16384;
pub const GST_BASE_SRC_FLAG_STARTED: ::libc::c_uint = 32768;
pub const GST_BASE_SRC_FLAG_LAST: ::libc::c_uint = 1048576;
pub type GstBaseSrcFlags = Enum_Unnamed204;
pub type GstBaseSrc = Struct__GstBaseSrc;
pub type GstBaseSrcClass = Struct__GstBaseSrcClass;
pub enum Struct__GstBaseSrcPrivate { }
pub type GstBaseSrcPrivate = Struct__GstBaseSrcPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBaseSrc {
    pub element: GstElement,
    pub srcpad: *mut GstPad,
    pub live_lock: GMutex,
    pub live_cond: GCond,
    pub is_live: gboolean,
    pub live_running: gboolean,
    pub blocksize: guint,
    pub can_activate_push: gboolean,
    pub random_access: gboolean,
    pub clock_id: GstClockID,
    pub segment: GstSegment,
    pub need_newsegment: gboolean,
    pub num_buffers: gint,
    pub num_buffers_left: gint,
    pub typefind: gboolean,
    pub running: gboolean,
    pub pending_seek: *mut GstEvent,
    pub _priv: *mut GstBaseSrcPrivate,
    pub _gst_reserved: [gpointer; 20u],
}
impl ::std::default::Default for Struct__GstBaseSrc {
    fn default() -> Struct__GstBaseSrc { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBaseSrcClass {
    pub parent_class: GstElementClass,
    pub get_caps: ::std::option::Option<extern "C" fn
                                            (src: *mut GstBaseSrc,
                                             filter: *mut GstCaps)
                                            -> *mut GstCaps>,
    pub negotiate: ::std::option::Option<extern "C" fn(src: *mut GstBaseSrc)
                                             -> gboolean>,
    pub fixate: ::std::option::Option<extern "C" fn
                                          (src: *mut GstBaseSrc,
                                           caps: *mut GstCaps)
                                          -> *mut GstCaps>,
    pub set_caps: ::std::option::Option<extern "C" fn
                                            (src: *mut GstBaseSrc,
                                             caps: *mut GstCaps) -> gboolean>,
    pub decide_allocation: ::std::option::Option<extern "C" fn
                                                     (src: *mut GstBaseSrc,
                                                      query: *mut GstQuery)
                                                     -> gboolean>,
    pub start: ::std::option::Option<extern "C" fn(src: *mut GstBaseSrc)
                                         -> gboolean>,
    pub stop: ::std::option::Option<extern "C" fn(src: *mut GstBaseSrc)
                                        -> gboolean>,
    pub get_times: ::std::option::Option<extern "C" fn
                                             (src: *mut GstBaseSrc,
                                              buffer: *mut GstBuffer,
                                              start: *mut GstClockTime,
                                              end: *mut GstClockTime)>,
    pub get_size: ::std::option::Option<extern "C" fn
                                            (src: *mut GstBaseSrc,
                                             size: *mut guint64) -> gboolean>,
    pub is_seekable: ::std::option::Option<extern "C" fn(src: *mut GstBaseSrc)
                                               -> gboolean>,
    pub prepare_seek_segment: ::std::option::Option<extern "C" fn
                                                        (src: *mut GstBaseSrc,
                                                         seek: *mut GstEvent,
                                                         segment:
                                                             *mut GstSegment)
                                                        -> gboolean>,
    pub do_seek: ::std::option::Option<extern "C" fn
                                           (src: *mut GstBaseSrc,
                                            segment: *mut GstSegment)
                                           -> gboolean>,
    pub unlock: ::std::option::Option<extern "C" fn(src: *mut GstBaseSrc)
                                          -> gboolean>,
    pub unlock_stop: ::std::option::Option<extern "C" fn(src: *mut GstBaseSrc)
                                               -> gboolean>,
    pub query: ::std::option::Option<extern "C" fn
                                         (src: *mut GstBaseSrc,
                                          query: *mut GstQuery) -> gboolean>,
    pub event: ::std::option::Option<extern "C" fn
                                         (src: *mut GstBaseSrc,
                                          event: *mut GstEvent) -> gboolean>,
    pub create: ::std::option::Option<extern "C" fn
                                          (src: *mut GstBaseSrc,
                                           offset: guint64, size: guint,
                                           buf: *mut *mut GstBuffer)
                                          -> GstFlowReturn>,
    pub alloc: ::std::option::Option<extern "C" fn
                                         (src: *mut GstBaseSrc,
                                          offset: guint64, size: guint,
                                          buf: *mut *mut GstBuffer)
                                         -> GstFlowReturn>,
    pub fill: ::std::option::Option<extern "C" fn
                                        (src: *mut GstBaseSrc,
                                         offset: guint64, size: guint,
                                         buf: *mut GstBuffer)
                                        -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 20u],
}
impl ::std::default::Default for Struct__GstBaseSrcClass {
    fn default() -> Struct__GstBaseSrcClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstPushSrc = Struct__GstPushSrc;
pub type GstPushSrcClass = Struct__GstPushSrcClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPushSrc {
    pub parent: GstBaseSrc,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPushSrc {
    fn default() -> Struct__GstPushSrc { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstPushSrcClass {
    pub parent_class: GstBaseSrcClass,
    pub create: ::std::option::Option<extern "C" fn
                                          (src: *mut GstPushSrc,
                                           buf: *mut *mut GstBuffer)
                                          -> GstFlowReturn>,
    pub alloc: ::std::option::Option<extern "C" fn
                                         (src: *mut GstPushSrc,
                                          buf: *mut *mut GstBuffer)
                                         -> GstFlowReturn>,
    pub fill: ::std::option::Option<extern "C" fn
                                        (src: *mut GstPushSrc,
                                         buf: *mut GstBuffer)
                                        -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstPushSrcClass {
    fn default() -> Struct__GstPushSrcClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstAppSrc = Struct__GstAppSrc;
pub type GstAppSrcClass = Struct__GstAppSrcClass;
pub enum Struct__GstAppSrcPrivate { }
pub type GstAppSrcPrivate = Struct__GstAppSrcPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed205 {
    pub need_data: ::std::option::Option<extern "C" fn
                                             (src: *mut GstAppSrc,
                                              length: guint,
                                              user_data: gpointer)>,
    pub enough_data: ::std::option::Option<extern "C" fn
                                               (src: *mut GstAppSrc,
                                                user_data: gpointer)>,
    pub seek_data: ::std::option::Option<extern "C" fn
                                             (src: *mut GstAppSrc,
                                              offset: guint64,
                                              user_data: gpointer)
                                             -> gboolean>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct_Unnamed205 {
    fn default() -> Struct_Unnamed205 { unsafe { ::std::mem::zeroed() } }
}
pub type GstAppSrcCallbacks = Struct_Unnamed205;
pub type Enum_Unnamed206 = ::libc::c_uint;
pub const GST_APP_STREAM_TYPE_STREAM: ::libc::c_uint = 0;
pub const GST_APP_STREAM_TYPE_SEEKABLE: ::libc::c_uint = 1;
pub const GST_APP_STREAM_TYPE_RANDOM_ACCESS: ::libc::c_uint = 2;
pub type GstAppStreamType = Enum_Unnamed206;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstAppSrc {
    pub basesrc: GstBaseSrc,
    pub _priv: *mut GstAppSrcPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstAppSrc {
    fn default() -> Struct__GstAppSrc { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstAppSrcClass {
    pub basesrc_class: GstBaseSrcClass,
    pub need_data: ::std::option::Option<extern "C" fn
                                             (appsrc: *mut GstAppSrc,
                                              length: guint)>,
    pub enough_data: ::std::option::Option<extern "C" fn
                                               (appsrc: *mut GstAppSrc)>,
    pub seek_data: ::std::option::Option<extern "C" fn
                                             (appsrc: *mut GstAppSrc,
                                              offset: guint64) -> gboolean>,
    pub push_buffer: ::std::option::Option<extern "C" fn
                                               (appsrc: *mut GstAppSrc,
                                                buffer: *mut GstBuffer)
                                               -> GstFlowReturn>,
    pub end_of_stream: ::std::option::Option<extern "C" fn
                                                 (appsrc: *mut GstAppSrc)
                                                 -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstAppSrcClass {
    fn default() -> Struct__GstAppSrcClass { unsafe { ::std::mem::zeroed() } }
}
pub type GstVideoAlignment = Struct__GstVideoAlignment;
pub type Enum_Unnamed207 = ::libc::c_uint;
pub const GST_VIDEO_TILE_TYPE_INDEXED: ::libc::c_uint = 0;
pub type GstVideoTileType = Enum_Unnamed207;
pub type Enum_Unnamed208 = ::libc::c_uint;
pub const GST_VIDEO_TILE_MODE_UNKNOWN: ::libc::c_uint = 0;
pub const GST_VIDEO_TILE_MODE_ZFLIPZ_2X2: ::libc::c_uint = 65536;
pub type GstVideoTileMode = Enum_Unnamed208;
pub type Enum_Unnamed209 = ::libc::c_uint;
pub const GST_VIDEO_FORMAT_UNKNOWN: ::libc::c_uint = 0;
pub const GST_VIDEO_FORMAT_ENCODED: ::libc::c_uint = 1;
pub const GST_VIDEO_FORMAT_I420: ::libc::c_uint = 2;
pub const GST_VIDEO_FORMAT_YV12: ::libc::c_uint = 3;
pub const GST_VIDEO_FORMAT_YUY2: ::libc::c_uint = 4;
pub const GST_VIDEO_FORMAT_UYVY: ::libc::c_uint = 5;
pub const GST_VIDEO_FORMAT_AYUV: ::libc::c_uint = 6;
pub const GST_VIDEO_FORMAT_RGBx: ::libc::c_uint = 7;
pub const GST_VIDEO_FORMAT_BGRx: ::libc::c_uint = 8;
pub const GST_VIDEO_FORMAT_xRGB: ::libc::c_uint = 9;
pub const GST_VIDEO_FORMAT_xBGR: ::libc::c_uint = 10;
pub const GST_VIDEO_FORMAT_RGBA: ::libc::c_uint = 11;
pub const GST_VIDEO_FORMAT_BGRA: ::libc::c_uint = 12;
pub const GST_VIDEO_FORMAT_ARGB: ::libc::c_uint = 13;
pub const GST_VIDEO_FORMAT_ABGR: ::libc::c_uint = 14;
pub const GST_VIDEO_FORMAT_RGB: ::libc::c_uint = 15;
pub const GST_VIDEO_FORMAT_BGR: ::libc::c_uint = 16;
pub const GST_VIDEO_FORMAT_Y41B: ::libc::c_uint = 17;
pub const GST_VIDEO_FORMAT_Y42B: ::libc::c_uint = 18;
pub const GST_VIDEO_FORMAT_YVYU: ::libc::c_uint = 19;
pub const GST_VIDEO_FORMAT_Y444: ::libc::c_uint = 20;
pub const GST_VIDEO_FORMAT_v210: ::libc::c_uint = 21;
pub const GST_VIDEO_FORMAT_v216: ::libc::c_uint = 22;
pub const GST_VIDEO_FORMAT_NV12: ::libc::c_uint = 23;
pub const GST_VIDEO_FORMAT_NV21: ::libc::c_uint = 24;
pub const GST_VIDEO_FORMAT_GRAY8: ::libc::c_uint = 25;
pub const GST_VIDEO_FORMAT_GRAY16_BE: ::libc::c_uint = 26;
pub const GST_VIDEO_FORMAT_GRAY16_LE: ::libc::c_uint = 27;
pub const GST_VIDEO_FORMAT_v308: ::libc::c_uint = 28;
pub const GST_VIDEO_FORMAT_RGB16: ::libc::c_uint = 29;
pub const GST_VIDEO_FORMAT_BGR16: ::libc::c_uint = 30;
pub const GST_VIDEO_FORMAT_RGB15: ::libc::c_uint = 31;
pub const GST_VIDEO_FORMAT_BGR15: ::libc::c_uint = 32;
pub const GST_VIDEO_FORMAT_UYVP: ::libc::c_uint = 33;
pub const GST_VIDEO_FORMAT_A420: ::libc::c_uint = 34;
pub const GST_VIDEO_FORMAT_RGB8P: ::libc::c_uint = 35;
pub const GST_VIDEO_FORMAT_YUV9: ::libc::c_uint = 36;
pub const GST_VIDEO_FORMAT_YVU9: ::libc::c_uint = 37;
pub const GST_VIDEO_FORMAT_IYU1: ::libc::c_uint = 38;
pub const GST_VIDEO_FORMAT_ARGB64: ::libc::c_uint = 39;
pub const GST_VIDEO_FORMAT_AYUV64: ::libc::c_uint = 40;
pub const GST_VIDEO_FORMAT_r210: ::libc::c_uint = 41;
pub const GST_VIDEO_FORMAT_I420_10BE: ::libc::c_uint = 42;
pub const GST_VIDEO_FORMAT_I420_10LE: ::libc::c_uint = 43;
pub const GST_VIDEO_FORMAT_I422_10BE: ::libc::c_uint = 44;
pub const GST_VIDEO_FORMAT_I422_10LE: ::libc::c_uint = 45;
pub const GST_VIDEO_FORMAT_Y444_10BE: ::libc::c_uint = 46;
pub const GST_VIDEO_FORMAT_Y444_10LE: ::libc::c_uint = 47;
pub const GST_VIDEO_FORMAT_GBR: ::libc::c_uint = 48;
pub const GST_VIDEO_FORMAT_GBR_10BE: ::libc::c_uint = 49;
pub const GST_VIDEO_FORMAT_GBR_10LE: ::libc::c_uint = 50;
pub const GST_VIDEO_FORMAT_NV16: ::libc::c_uint = 51;
pub const GST_VIDEO_FORMAT_NV24: ::libc::c_uint = 52;
pub const GST_VIDEO_FORMAT_NV12_64Z32: ::libc::c_uint = 53;
pub type GstVideoFormat = Enum_Unnamed209;
pub type GstVideoFormatInfo = Struct__GstVideoFormatInfo;
pub type Enum_Unnamed210 = ::libc::c_uint;
pub const GST_VIDEO_FORMAT_FLAG_YUV: ::libc::c_uint = 1;
pub const GST_VIDEO_FORMAT_FLAG_RGB: ::libc::c_uint = 2;
pub const GST_VIDEO_FORMAT_FLAG_GRAY: ::libc::c_uint = 4;
pub const GST_VIDEO_FORMAT_FLAG_ALPHA: ::libc::c_uint = 8;
pub const GST_VIDEO_FORMAT_FLAG_LE: ::libc::c_uint = 16;
pub const GST_VIDEO_FORMAT_FLAG_PALETTE: ::libc::c_uint = 32;
pub const GST_VIDEO_FORMAT_FLAG_COMPLEX: ::libc::c_uint = 64;
pub const GST_VIDEO_FORMAT_FLAG_UNPACK: ::libc::c_uint = 128;
pub const GST_VIDEO_FORMAT_FLAG_TILED: ::libc::c_uint = 256;
pub type GstVideoFormatFlags = Enum_Unnamed210;
pub type Enum_Unnamed211 = ::libc::c_uint;
pub const GST_VIDEO_CHROMA_SITE_UNKNOWN: ::libc::c_uint = 0;
pub const GST_VIDEO_CHROMA_SITE_NONE: ::libc::c_uint = 1;
pub const GST_VIDEO_CHROMA_SITE_H_COSITED: ::libc::c_uint = 2;
pub const GST_VIDEO_CHROMA_SITE_V_COSITED: ::libc::c_uint = 4;
pub const GST_VIDEO_CHROMA_SITE_ALT_LINE: ::libc::c_uint = 8;
pub const GST_VIDEO_CHROMA_SITE_COSITED: ::libc::c_uint = 6;
pub const GST_VIDEO_CHROMA_SITE_JPEG: ::libc::c_uint = 1;
pub const GST_VIDEO_CHROMA_SITE_MPEG2: ::libc::c_uint = 2;
pub const GST_VIDEO_CHROMA_SITE_DV: ::libc::c_uint = 14;
pub type GstVideoChromaSite = Enum_Unnamed211;
pub type Enum_Unnamed212 = ::libc::c_uint;
pub const GST_VIDEO_CHROMA_METHOD_NEAREST: ::libc::c_uint = 0;
pub const GST_VIDEO_CHROMA_METHOD_LINEAR: ::libc::c_uint = 1;
pub type GstVideoChromaMethod = Enum_Unnamed212;
pub type Enum_Unnamed213 = ::libc::c_uint;
pub const GST_VIDEO_CHROMA_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_VIDEO_CHROMA_FLAG_INTERLACED: ::libc::c_uint = 1;
pub type GstVideoChromaFlags = Enum_Unnamed213;
pub enum Struct__GstVideoChromaResample { }
pub type GstVideoChromaResample = Struct__GstVideoChromaResample;
pub type Enum_Unnamed214 = ::libc::c_uint;
pub const GST_VIDEO_PACK_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE: ::libc::c_uint = 1;
pub const GST_VIDEO_PACK_FLAG_INTERLACED: ::libc::c_uint = 2;
pub type GstVideoPackFlags = Enum_Unnamed214;
pub type GstVideoFormatUnpack =
    ::std::option::Option<extern "C" fn
                              (info: *const GstVideoFormatInfo,
                               flags: GstVideoPackFlags, dest: gpointer,
                               data: *mut gpointer, stride: *mut gint,
                               x: gint, y: gint, width: gint)>;
pub type GstVideoFormatPack =
    ::std::option::Option<extern "C" fn
                              (info: *const GstVideoFormatInfo,
                               flags: GstVideoPackFlags, src: gpointer,
                               sstride: gint, data: *mut gpointer,
                               stride: *mut gint,
                               chroma_site: GstVideoChromaSite, y: gint,
                               width: gint)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoFormatInfo {
    pub format: GstVideoFormat,
    pub name: *const gchar,
    pub description: *const gchar,
    pub flags: GstVideoFormatFlags,
    pub bits: guint,
    pub n_components: guint,
    pub shift: [guint; 4u],
    pub depth: [guint; 4u],
    pub pixel_stride: [gint; 4u],
    pub n_planes: guint,
    pub plane: [guint; 4u],
    pub poffset: [guint; 4u],
    pub w_sub: [guint; 4u],
    pub h_sub: [guint; 4u],
    pub unpack_format: GstVideoFormat,
    pub unpack_func: GstVideoFormatUnpack,
    pub pack_lines: gint,
    pub pack_func: GstVideoFormatPack,
    pub tile_mode: GstVideoTileMode,
    pub tile_ws: guint,
    pub tile_hs: guint,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstVideoFormatInfo {
    fn default() -> Struct__GstVideoFormatInfo {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed215 = ::libc::c_uint;
pub const GST_VIDEO_COLOR_RANGE_UNKNOWN: ::libc::c_uint = 0;
pub const GST_VIDEO_COLOR_RANGE_0_255: ::libc::c_uint = 1;
pub const GST_VIDEO_COLOR_RANGE_16_235: ::libc::c_uint = 2;
pub type GstVideoColorRange = Enum_Unnamed215;
pub type Enum_Unnamed216 = ::libc::c_uint;
pub const GST_VIDEO_COLOR_MATRIX_UNKNOWN: ::libc::c_uint = 0;
pub const GST_VIDEO_COLOR_MATRIX_RGB: ::libc::c_uint = 1;
pub const GST_VIDEO_COLOR_MATRIX_FCC: ::libc::c_uint = 2;
pub const GST_VIDEO_COLOR_MATRIX_BT709: ::libc::c_uint = 3;
pub const GST_VIDEO_COLOR_MATRIX_BT601: ::libc::c_uint = 4;
pub const GST_VIDEO_COLOR_MATRIX_SMPTE240M: ::libc::c_uint = 5;
pub type GstVideoColorMatrix = Enum_Unnamed216;
pub type Enum_Unnamed217 = ::libc::c_uint;
pub const GST_VIDEO_TRANSFER_UNKNOWN: ::libc::c_uint = 0;
pub const GST_VIDEO_TRANSFER_GAMMA10: ::libc::c_uint = 1;
pub const GST_VIDEO_TRANSFER_GAMMA18: ::libc::c_uint = 2;
pub const GST_VIDEO_TRANSFER_GAMMA20: ::libc::c_uint = 3;
pub const GST_VIDEO_TRANSFER_GAMMA22: ::libc::c_uint = 4;
pub const GST_VIDEO_TRANSFER_BT709: ::libc::c_uint = 5;
pub const GST_VIDEO_TRANSFER_SMPTE240M: ::libc::c_uint = 6;
pub const GST_VIDEO_TRANSFER_SRGB: ::libc::c_uint = 7;
pub const GST_VIDEO_TRANSFER_GAMMA28: ::libc::c_uint = 8;
pub const GST_VIDEO_TRANSFER_LOG100: ::libc::c_uint = 9;
pub const GST_VIDEO_TRANSFER_LOG316: ::libc::c_uint = 10;
pub type GstVideoTransferFunction = Enum_Unnamed217;
pub type Enum_Unnamed218 = ::libc::c_uint;
pub const GST_VIDEO_COLOR_PRIMARIES_UNKNOWN: ::libc::c_uint = 0;
pub const GST_VIDEO_COLOR_PRIMARIES_BT709: ::libc::c_uint = 1;
pub const GST_VIDEO_COLOR_PRIMARIES_BT470M: ::libc::c_uint = 2;
pub const GST_VIDEO_COLOR_PRIMARIES_BT470BG: ::libc::c_uint = 3;
pub const GST_VIDEO_COLOR_PRIMARIES_SMPTE170M: ::libc::c_uint = 4;
pub const GST_VIDEO_COLOR_PRIMARIES_SMPTE240M: ::libc::c_uint = 5;
pub const GST_VIDEO_COLOR_PRIMARIES_FILM: ::libc::c_uint = 6;
pub type GstVideoColorPrimaries = Enum_Unnamed218;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed219 {
    pub range: GstVideoColorRange,
    pub matrix: GstVideoColorMatrix,
    pub transfer: GstVideoTransferFunction,
    pub primaries: GstVideoColorPrimaries,
}
impl ::std::default::Default for Struct_Unnamed219 {
    fn default() -> Struct_Unnamed219 { unsafe { ::std::mem::zeroed() } }
}
pub type GstVideoColorimetry = Struct_Unnamed219;
pub type GstVideoInfo = Struct__GstVideoInfo;
pub type Enum_Unnamed220 = ::libc::c_uint;
pub const GST_VIDEO_INTERLACE_MODE_PROGRESSIVE: ::libc::c_uint = 0;
pub const GST_VIDEO_INTERLACE_MODE_INTERLEAVED: ::libc::c_uint = 1;
pub const GST_VIDEO_INTERLACE_MODE_MIXED: ::libc::c_uint = 2;
pub const GST_VIDEO_INTERLACE_MODE_FIELDS: ::libc::c_uint = 3;
pub type GstVideoInterlaceMode = Enum_Unnamed220;
pub type Enum_Unnamed221 = ::libc::c_uint;
pub const GST_VIDEO_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_VIDEO_FLAG_VARIABLE_FPS: ::libc::c_uint = 1;
pub const GST_VIDEO_FLAG_PREMULTIPLIED_ALPHA: ::libc::c_uint = 2;
pub type GstVideoFlags = Enum_Unnamed221;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoInfo {
    pub finfo: *const GstVideoFormatInfo,
    pub interlace_mode: GstVideoInterlaceMode,
    pub flags: GstVideoFlags,
    pub width: gint,
    pub height: gint,
    pub size: gsize,
    pub views: gint,
    pub chroma_site: GstVideoChromaSite,
    pub colorimetry: GstVideoColorimetry,
    pub par_n: gint,
    pub par_d: gint,
    pub fps_n: gint,
    pub fps_d: gint,
    pub offset: [gsize; 4u],
    pub stride: [gint; 4u],
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstVideoInfo {
    fn default() -> Struct__GstVideoInfo { unsafe { ::std::mem::zeroed() } }
}
pub type GstVideoFrame = Struct__GstVideoFrame;
pub type Enum_Unnamed222 = ::libc::c_uint;
pub const GST_VIDEO_FRAME_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_VIDEO_FRAME_FLAG_INTERLACED: ::libc::c_uint = 1;
pub const GST_VIDEO_FRAME_FLAG_TFF: ::libc::c_uint = 2;
pub const GST_VIDEO_FRAME_FLAG_RFF: ::libc::c_uint = 4;
pub const GST_VIDEO_FRAME_FLAG_ONEFIELD: ::libc::c_uint = 8;
pub type GstVideoFrameFlags = Enum_Unnamed222;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoFrame {
    pub info: GstVideoInfo,
    pub flags: GstVideoFrameFlags,
    pub buffer: *mut GstBuffer,
    pub meta: gpointer,
    pub id: gint,
    pub data: [gpointer; 4u],
    pub map: [GstMapInfo; 4u],
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstVideoFrame {
    fn default() -> Struct__GstVideoFrame { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_Unnamed223 = ::libc::c_uint;
pub const GST_VIDEO_BUFFER_FLAG_INTERLACED: ::libc::c_uint = 1048576;
pub const GST_VIDEO_BUFFER_FLAG_TFF: ::libc::c_uint = 2097152;
pub const GST_VIDEO_BUFFER_FLAG_RFF: ::libc::c_uint = 4194304;
pub const GST_VIDEO_BUFFER_FLAG_ONEFIELD: ::libc::c_uint = 8388608;
pub const GST_VIDEO_BUFFER_FLAG_LAST: ::libc::c_uint = 268435456;
pub type GstVideoBufferFlags = Enum_Unnamed223;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoAlignment {
    pub padding_top: guint,
    pub padding_bottom: guint,
    pub padding_left: guint,
    pub padding_right: guint,
    pub stride_align: [guint; 4u],
}
impl ::std::default::Default for Struct__GstVideoAlignment {
    fn default() -> Struct__GstVideoAlignment {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstVideoConvertSampleCallback =
    ::std::option::Option<extern "C" fn
                              (sample: *mut GstSample, error: *mut GError,
                               user_data: gpointer)>;
pub type GstColorBalanceChannel = Struct__GstColorBalanceChannel;
pub type GstColorBalanceChannelClass = Struct__GstColorBalanceChannelClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstColorBalanceChannel {
    pub parent: GObject,
    pub label: *mut gchar,
    pub min_value: gint,
    pub max_value: gint,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstColorBalanceChannel {
    fn default() -> Struct__GstColorBalanceChannel {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstColorBalanceChannelClass {
    pub parent: GObjectClass,
    pub value_changed: ::std::option::Option<extern "C" fn
                                                 (channel:
                                                      *mut GstColorBalanceChannel,
                                                  value: gint)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstColorBalanceChannelClass {
    fn default() -> Struct__GstColorBalanceChannelClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstColorBalance { }
pub type GstColorBalance = Struct__GstColorBalance;
pub type GstColorBalanceInterface = Struct__GstColorBalanceInterface;
pub type Enum_Unnamed224 = ::libc::c_uint;
pub const GST_COLOR_BALANCE_HARDWARE: ::libc::c_uint = 0;
pub const GST_COLOR_BALANCE_SOFTWARE: ::libc::c_uint = 1;
pub type GstColorBalanceType = Enum_Unnamed224;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstColorBalanceInterface {
    pub iface: GTypeInterface,
    pub list_channels: ::std::option::Option<extern "C" fn
                                                 (balance:
                                                      *mut GstColorBalance)
                                                 -> *const GList>,
    pub set_value: ::std::option::Option<extern "C" fn
                                             (balance: *mut GstColorBalance,
                                              channel:
                                                  *mut GstColorBalanceChannel,
                                              value: gint)>,
    pub get_value: ::std::option::Option<extern "C" fn
                                             (balance: *mut GstColorBalance,
                                              channel:
                                                  *mut GstColorBalanceChannel)
                                             -> gint>,
    pub get_balance_type: ::std::option::Option<extern "C" fn
                                                    (balance:
                                                         *mut GstColorBalance)
                                                    -> GstColorBalanceType>,
    pub value_changed: ::std::option::Option<extern "C" fn
                                                 (balance:
                                                      *mut GstColorBalance,
                                                  channel:
                                                      *mut GstColorBalanceChannel,
                                                  value: gint)>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstColorBalanceInterface {
    fn default() -> Struct__GstColorBalanceInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstAdapter { }
pub type GstAdapter = Struct__GstAdapter;
pub enum Struct__GstAdapterClass { }
pub type GstAdapterClass = Struct__GstAdapterClass;
pub type GstVideoCodecState = Struct__GstVideoCodecState;
pub type GstVideoCodecFrame = Struct__GstVideoCodecFrame;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoCodecState {
    pub ref_count: gint,
    pub info: GstVideoInfo,
    pub caps: *mut GstCaps,
    pub codec_data: *mut GstBuffer,
    pub padding: [*mut ::libc::c_void; 20u],
}
impl ::std::default::Default for Struct__GstVideoCodecState {
    fn default() -> Struct__GstVideoCodecState {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed225 = ::libc::c_uint;
pub const GST_VIDEO_CODEC_FRAME_FLAG_DECODE_ONLY: ::libc::c_uint = 1;
pub const GST_VIDEO_CODEC_FRAME_FLAG_SYNC_POINT: ::libc::c_uint = 2;
pub const GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME: ::libc::c_uint = 4;
pub const GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME_HEADERS: ::libc::c_uint =
    8;
pub type GstVideoCodecFrameFlags = Enum_Unnamed225;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoCodecFrame {
    pub ref_count: gint,
    pub flags: guint32,
    pub system_frame_number: guint32,
    pub decode_frame_number: guint32,
    pub presentation_frame_number: guint32,
    pub dts: GstClockTime,
    pub pts: GstClockTime,
    pub duration: GstClockTime,
    pub distance_from_sync: ::libc::c_int,
    pub input_buffer: *mut GstBuffer,
    pub output_buffer: *mut GstBuffer,
    pub deadline: GstClockTime,
    pub events: *mut GList,
    pub user_data: gpointer,
    pub user_data_destroy_notify: GDestroyNotify,
    pub abidata: Union_Unnamed226,
}
impl ::std::default::Default for Struct__GstVideoCodecFrame {
    fn default() -> Struct__GstVideoCodecFrame {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed226 {
    pub _bindgen_data_: [u64; 20u],
}
impl Union_Unnamed226 {
    pub unsafe fn ABI(&mut self) -> *mut Struct_Unnamed227 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn padding(&mut self) -> *mut [*mut ::libc::c_void; 20u] {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed226 {
    fn default() -> Union_Unnamed226 { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed227 {
    pub ts: GstClockTime,
    pub ts2: GstClockTime,
}
impl ::std::default::Default for Struct_Unnamed227 {
    fn default() -> Struct_Unnamed227 { unsafe { ::std::mem::zeroed() } }
}
pub type GstVideoDecoder = Struct__GstVideoDecoder;
pub type GstVideoDecoderClass = Struct__GstVideoDecoderClass;
pub enum Struct__GstVideoDecoderPrivate { }
pub type GstVideoDecoderPrivate = Struct__GstVideoDecoderPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoDecoder {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub srcpad: *mut GstPad,
    pub stream_lock: GRecMutex,
    pub input_segment: GstSegment,
    pub output_segment: GstSegment,
    pub _priv: *mut GstVideoDecoderPrivate,
    pub padding: [*mut ::libc::c_void; 20u],
}
impl ::std::default::Default for Struct__GstVideoDecoder {
    fn default() -> Struct__GstVideoDecoder {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoDecoderClass {
    pub element_class: GstElementClass,
    pub open: ::std::option::Option<extern "C" fn
                                        (decoder: *mut GstVideoDecoder)
                                        -> gboolean>,
    pub close: ::std::option::Option<extern "C" fn
                                         (decoder: *mut GstVideoDecoder)
                                         -> gboolean>,
    pub start: ::std::option::Option<extern "C" fn
                                         (decoder: *mut GstVideoDecoder)
                                         -> gboolean>,
    pub stop: ::std::option::Option<extern "C" fn
                                        (decoder: *mut GstVideoDecoder)
                                        -> gboolean>,
    pub parse: ::std::option::Option<extern "C" fn
                                         (decoder: *mut GstVideoDecoder,
                                          frame: *mut GstVideoCodecFrame,
                                          adapter: *mut GstAdapter,
                                          at_eos: gboolean) -> GstFlowReturn>,
    pub set_format: ::std::option::Option<extern "C" fn
                                              (decoder: *mut GstVideoDecoder,
                                               state: *mut GstVideoCodecState)
                                              -> gboolean>,
    pub reset: ::std::option::Option<extern "C" fn
                                         (decoder: *mut GstVideoDecoder,
                                          hard: gboolean) -> gboolean>,
    pub finish: ::std::option::Option<extern "C" fn
                                          (decoder: *mut GstVideoDecoder)
                                          -> GstFlowReturn>,
    pub handle_frame: ::std::option::Option<extern "C" fn
                                                (decoder:
                                                     *mut GstVideoDecoder,
                                                 frame:
                                                     *mut GstVideoCodecFrame)
                                                -> GstFlowReturn>,
    pub sink_event: ::std::option::Option<extern "C" fn
                                              (decoder: *mut GstVideoDecoder,
                                               event: *mut GstEvent)
                                              -> gboolean>,
    pub src_event: ::std::option::Option<extern "C" fn
                                             (decoder: *mut GstVideoDecoder,
                                              event: *mut GstEvent)
                                             -> gboolean>,
    pub negotiate: ::std::option::Option<extern "C" fn
                                             (decoder: *mut GstVideoDecoder)
                                             -> gboolean>,
    pub decide_allocation: ::std::option::Option<extern "C" fn
                                                     (decoder:
                                                          *mut GstVideoDecoder,
                                                      query: *mut GstQuery)
                                                     -> gboolean>,
    pub propose_allocation: ::std::option::Option<extern "C" fn
                                                      (decoder:
                                                           *mut GstVideoDecoder,
                                                       query: *mut GstQuery)
                                                      -> gboolean>,
    pub flush: ::std::option::Option<extern "C" fn
                                         (decoder: *mut GstVideoDecoder)
                                         -> gboolean>,
    pub sink_query: ::std::option::Option<extern "C" fn
                                              (decoder: *mut GstVideoDecoder,
                                               query: *mut GstQuery)
                                              -> gboolean>,
    pub src_query: ::std::option::Option<extern "C" fn
                                             (decoder: *mut GstVideoDecoder,
                                              query: *mut GstQuery)
                                             -> gboolean>,
    pub padding: [*mut ::libc::c_void; 17u],
}
impl ::std::default::Default for Struct__GstVideoDecoderClass {
    fn default() -> Struct__GstVideoDecoderClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstVideoEncoder = Struct__GstVideoEncoder;
pub enum Struct__GstVideoEncoderPrivate { }
pub type GstVideoEncoderPrivate = Struct__GstVideoEncoderPrivate;
pub type GstVideoEncoderClass = Struct__GstVideoEncoderClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoEncoder {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub srcpad: *mut GstPad,
    pub stream_lock: GRecMutex,
    pub input_segment: GstSegment,
    pub output_segment: GstSegment,
    pub _priv: *mut GstVideoEncoderPrivate,
    pub padding: [*mut ::libc::c_void; 20u],
}
impl ::std::default::Default for Struct__GstVideoEncoder {
    fn default() -> Struct__GstVideoEncoder {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoEncoderClass {
    pub element_class: GstElementClass,
    pub open: ::std::option::Option<extern "C" fn
                                        (encoder: *mut GstVideoEncoder)
                                        -> gboolean>,
    pub close: ::std::option::Option<extern "C" fn
                                         (encoder: *mut GstVideoEncoder)
                                         -> gboolean>,
    pub start: ::std::option::Option<extern "C" fn
                                         (encoder: *mut GstVideoEncoder)
                                         -> gboolean>,
    pub stop: ::std::option::Option<extern "C" fn
                                        (encoder: *mut GstVideoEncoder)
                                        -> gboolean>,
    pub set_format: ::std::option::Option<extern "C" fn
                                              (encoder: *mut GstVideoEncoder,
                                               state: *mut GstVideoCodecState)
                                              -> gboolean>,
    pub handle_frame: ::std::option::Option<extern "C" fn
                                                (encoder:
                                                     *mut GstVideoEncoder,
                                                 frame:
                                                     *mut GstVideoCodecFrame)
                                                -> GstFlowReturn>,
    pub reset: ::std::option::Option<extern "C" fn
                                         (encoder: *mut GstVideoEncoder,
                                          hard: gboolean) -> gboolean>,
    pub finish: ::std::option::Option<extern "C" fn
                                          (encoder: *mut GstVideoEncoder)
                                          -> GstFlowReturn>,
    pub pre_push: ::std::option::Option<extern "C" fn
                                            (encoder: *mut GstVideoEncoder,
                                             frame: *mut GstVideoCodecFrame)
                                            -> GstFlowReturn>,
    pub getcaps: ::std::option::Option<extern "C" fn
                                           (enc: *mut GstVideoEncoder,
                                            filter: *mut GstCaps)
                                           -> *mut GstCaps>,
    pub sink_event: ::std::option::Option<extern "C" fn
                                              (encoder: *mut GstVideoEncoder,
                                               event: *mut GstEvent)
                                              -> gboolean>,
    pub src_event: ::std::option::Option<extern "C" fn
                                             (encoder: *mut GstVideoEncoder,
                                              event: *mut GstEvent)
                                             -> gboolean>,
    pub negotiate: ::std::option::Option<extern "C" fn
                                             (encoder: *mut GstVideoEncoder)
                                             -> gboolean>,
    pub decide_allocation: ::std::option::Option<extern "C" fn
                                                     (encoder:
                                                          *mut GstVideoEncoder,
                                                      query: *mut GstQuery)
                                                     -> gboolean>,
    pub propose_allocation: ::std::option::Option<extern "C" fn
                                                      (encoder:
                                                           *mut GstVideoEncoder,
                                                       query: *mut GstQuery)
                                                      -> gboolean>,
    pub flush: ::std::option::Option<extern "C" fn
                                         (encoder: *mut GstVideoEncoder)
                                         -> gboolean>,
    pub sink_query: ::std::option::Option<extern "C" fn
                                              (encoder: *mut GstVideoEncoder,
                                               query: *mut GstQuery)
                                              -> gboolean>,
    pub src_query: ::std::option::Option<extern "C" fn
                                             (encoder: *mut GstVideoEncoder,
                                              query: *mut GstQuery)
                                             -> gboolean>,
    pub _gst_reserved: [gpointer; 17u],
}
impl ::std::default::Default for Struct__GstVideoEncoderClass {
    fn default() -> Struct__GstVideoEncoderClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstBaseTransform = Struct__GstBaseTransform;
pub type GstBaseTransformClass = Struct__GstBaseTransformClass;
pub enum Struct__GstBaseTransformPrivate { }
pub type GstBaseTransformPrivate = Struct__GstBaseTransformPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBaseTransform {
    pub element: GstElement,
    pub sinkpad: *mut GstPad,
    pub srcpad: *mut GstPad,
    pub have_segment: gboolean,
    pub segment: GstSegment,
    pub _priv: *mut GstBaseTransformPrivate,
    pub _gst_reserved: [gpointer; 20u],
}
impl ::std::default::Default for Struct__GstBaseTransform {
    fn default() -> Struct__GstBaseTransform {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstBaseTransformClass {
    pub parent_class: GstElementClass,
    pub passthrough_on_same_caps: gboolean,
    pub transform_ip_on_passthrough: gboolean,
    pub transform_caps: ::std::option::Option<extern "C" fn
                                                  (trans:
                                                       *mut GstBaseTransform,
                                                   direction: GstPadDirection,
                                                   caps: *mut GstCaps,
                                                   filter: *mut GstCaps)
                                                  -> *mut GstCaps>,
    pub fixate_caps: ::std::option::Option<extern "C" fn
                                               (trans: *mut GstBaseTransform,
                                                direction: GstPadDirection,
                                                caps: *mut GstCaps,
                                                othercaps: *mut GstCaps)
                                               -> *mut GstCaps>,
    pub accept_caps: ::std::option::Option<extern "C" fn
                                               (trans: *mut GstBaseTransform,
                                                direction: GstPadDirection,
                                                caps: *mut GstCaps)
                                               -> gboolean>,
    pub set_caps: ::std::option::Option<extern "C" fn
                                            (trans: *mut GstBaseTransform,
                                             incaps: *mut GstCaps,
                                             outcaps: *mut GstCaps)
                                            -> gboolean>,
    pub query: ::std::option::Option<extern "C" fn
                                         (trans: *mut GstBaseTransform,
                                          direction: GstPadDirection,
                                          query: *mut GstQuery) -> gboolean>,
    pub decide_allocation: ::std::option::Option<extern "C" fn
                                                     (trans:
                                                          *mut GstBaseTransform,
                                                      query: *mut GstQuery)
                                                     -> gboolean>,
    pub filter_meta: ::std::option::Option<extern "C" fn
                                               (trans: *mut GstBaseTransform,
                                                query: *mut GstQuery,
                                                api: GType,
                                                params: *const GstStructure)
                                               -> gboolean>,
    pub propose_allocation: ::std::option::Option<extern "C" fn
                                                      (trans:
                                                           *mut GstBaseTransform,
                                                       decide_query:
                                                           *mut GstQuery,
                                                       query: *mut GstQuery)
                                                      -> gboolean>,
    pub transform_size: ::std::option::Option<extern "C" fn
                                                  (trans:
                                                       *mut GstBaseTransform,
                                                   direction: GstPadDirection,
                                                   caps: *mut GstCaps,
                                                   size: gsize,
                                                   othercaps: *mut GstCaps,
                                                   othersize: *mut gsize)
                                                  -> gboolean>,
    pub get_unit_size: ::std::option::Option<extern "C" fn
                                                 (trans:
                                                      *mut GstBaseTransform,
                                                  caps: *mut GstCaps,
                                                  size: *mut gsize)
                                                 -> gboolean>,
    pub start: ::std::option::Option<extern "C" fn
                                         (trans: *mut GstBaseTransform)
                                         -> gboolean>,
    pub stop: ::std::option::Option<extern "C" fn
                                        (trans: *mut GstBaseTransform)
                                        -> gboolean>,
    pub sink_event: ::std::option::Option<extern "C" fn
                                              (trans: *mut GstBaseTransform,
                                               event: *mut GstEvent)
                                              -> gboolean>,
    pub src_event: ::std::option::Option<extern "C" fn
                                             (trans: *mut GstBaseTransform,
                                              event: *mut GstEvent)
                                             -> gboolean>,
    pub prepare_output_buffer: ::std::option::Option<extern "C" fn
                                                         (trans:
                                                              *mut GstBaseTransform,
                                                          input:
                                                              *mut GstBuffer,
                                                          outbuf:
                                                              *mut *mut GstBuffer)
                                                         -> GstFlowReturn>,
    pub copy_metadata: ::std::option::Option<extern "C" fn
                                                 (trans:
                                                      *mut GstBaseTransform,
                                                  input: *mut GstBuffer,
                                                  outbuf: *mut GstBuffer)
                                                 -> gboolean>,
    pub transform_meta: ::std::option::Option<extern "C" fn
                                                  (trans:
                                                       *mut GstBaseTransform,
                                                   outbuf: *mut GstBuffer,
                                                   meta: *mut GstMeta,
                                                   inbuf: *mut GstBuffer)
                                                  -> gboolean>,
    pub before_transform: ::std::option::Option<extern "C" fn
                                                    (trans:
                                                         *mut GstBaseTransform,
                                                     buffer: *mut GstBuffer)>,
    pub transform: ::std::option::Option<extern "C" fn
                                             (trans: *mut GstBaseTransform,
                                              inbuf: *mut GstBuffer,
                                              outbuf: *mut GstBuffer)
                                             -> GstFlowReturn>,
    pub transform_ip: ::std::option::Option<extern "C" fn
                                                (trans: *mut GstBaseTransform,
                                                 buf: *mut GstBuffer)
                                                -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 20u],
}
impl ::std::default::Default for Struct__GstBaseTransformClass {
    fn default() -> Struct__GstBaseTransformClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstVideoFilter = Struct__GstVideoFilter;
pub type GstVideoFilterClass = Struct__GstVideoFilterClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoFilter {
    pub element: GstBaseTransform,
    pub negotiated: gboolean,
    pub in_info: GstVideoInfo,
    pub out_info: GstVideoInfo,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstVideoFilter {
    fn default() -> Struct__GstVideoFilter { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoFilterClass {
    pub parent_class: GstBaseTransformClass,
    pub set_info: ::std::option::Option<extern "C" fn
                                            (filter: *mut GstVideoFilter,
                                             incaps: *mut GstCaps,
                                             in_info: *mut GstVideoInfo,
                                             outcaps: *mut GstCaps,
                                             out_info: *mut GstVideoInfo)
                                            -> gboolean>,
    pub transform_frame: ::std::option::Option<extern "C" fn
                                                   (filter:
                                                        *mut GstVideoFilter,
                                                    inframe:
                                                        *mut GstVideoFrame,
                                                    outframe:
                                                        *mut GstVideoFrame)
                                                   -> GstFlowReturn>,
    pub transform_frame_ip: ::std::option::Option<extern "C" fn
                                                      (trans:
                                                           *mut GstVideoFilter,
                                                       frame:
                                                           *mut GstVideoFrame)
                                                      -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstVideoFilterClass {
    fn default() -> Struct__GstVideoFilterClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstVideoMeta = Struct__GstVideoMeta;
pub type GstVideoCropMeta = Struct__GstVideoCropMeta;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoMeta {
    pub meta: GstMeta,
    pub buffer: *mut GstBuffer,
    pub flags: GstVideoFrameFlags,
    pub format: GstVideoFormat,
    pub id: gint,
    pub width: guint,
    pub height: guint,
    pub n_planes: guint,
    pub offset: [gsize; 4u],
    pub stride: [gint; 4u],
    pub map: ::std::option::Option<extern "C" fn
                                       (meta: *mut GstVideoMeta, plane: guint,
                                        info: *mut GstMapInfo,
                                        data: *mut gpointer,
                                        stride: *mut gint, flags: GstMapFlags)
                                       -> gboolean>,
    pub unmap: ::std::option::Option<extern "C" fn
                                         (meta: *mut GstVideoMeta,
                                          plane: guint, info: *mut GstMapInfo)
                                         -> gboolean>,
}
impl ::std::default::Default for Struct__GstVideoMeta {
    fn default() -> Struct__GstVideoMeta { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoCropMeta {
    pub meta: GstMeta,
    pub x: guint,
    pub y: guint,
    pub width: guint,
    pub height: guint,
}
impl ::std::default::Default for Struct__GstVideoCropMeta {
    fn default() -> Struct__GstVideoCropMeta {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed228 {
    pub in_info: *mut GstVideoInfo,
    pub out_info: *mut GstVideoInfo,
}
impl ::std::default::Default for Struct_Unnamed228 {
    fn default() -> Struct_Unnamed228 { unsafe { ::std::mem::zeroed() } }
}
pub type GstVideoMetaTransform = Struct_Unnamed228;
pub type Enum_Unnamed229 = ::libc::c_uint;
pub const GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE: ::libc::c_uint = 0;
pub const GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE_ALPHA: ::libc::c_uint = 1;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RGB16: ::libc::c_uint = 2;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RGB: ::libc::c_uint = 3;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RGBA: ::libc::c_uint = 4;
pub const GST_VIDEO_GL_TEXTURE_TYPE_R: ::libc::c_uint = 5;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RG: ::libc::c_uint = 6;
pub type GstVideoGLTextureType = Enum_Unnamed229;
pub type Enum_Unnamed230 = ::libc::c_uint;
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_NORMAL: ::libc::c_uint =
    0;
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_FLIP: ::libc::c_uint =
    1;
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_NORMAL: ::libc::c_uint =
    2;
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_FLIP: ::libc::c_uint = 3;
pub type GstVideoGLTextureOrientation = Enum_Unnamed230;
pub type GstVideoGLTextureUploadMeta = Struct__GstVideoGLTextureUploadMeta;
pub type GstVideoGLTextureUpload =
    ::std::option::Option<extern "C" fn
                              (meta: *mut GstVideoGLTextureUploadMeta,
                               texture_id: *mut guint) -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoGLTextureUploadMeta {
    pub meta: GstMeta,
    pub texture_orientation: GstVideoGLTextureOrientation,
    pub n_textures: guint,
    pub texture_type: [GstVideoGLTextureType; 4u],
    pub buffer: *mut GstBuffer,
    pub upload: GstVideoGLTextureUpload,
    pub user_data: gpointer,
    pub user_data_copy: GBoxedCopyFunc,
    pub user_data_free: GBoxedFreeFunc,
}
impl ::std::default::Default for Struct__GstVideoGLTextureUploadMeta {
    fn default() -> Struct__GstVideoGLTextureUploadMeta {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed231 {
    pub meta: GstMeta,
    pub roi_type: GQuark,
    pub id: gint,
    pub parent_id: gint,
    pub x: guint,
    pub y: guint,
    pub w: guint,
    pub h: guint,
}
impl ::std::default::Default for Struct_Unnamed231 {
    fn default() -> Struct_Unnamed231 { unsafe { ::std::mem::zeroed() } }
}
pub type GstVideoRegionOfInterestMeta = Struct_Unnamed231;
pub type GstVideoBufferPool = Struct__GstVideoBufferPool;
pub type GstVideoBufferPoolClass = Struct__GstVideoBufferPoolClass;
pub enum Struct__GstVideoBufferPoolPrivate { }
pub type GstVideoBufferPoolPrivate = Struct__GstVideoBufferPoolPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoBufferPool {
    pub bufferpool: GstBufferPool,
    pub _priv: *mut GstVideoBufferPoolPrivate,
}
impl ::std::default::Default for Struct__GstVideoBufferPool {
    fn default() -> Struct__GstVideoBufferPool {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoBufferPoolClass {
    pub parent_class: GstBufferPoolClass,
}
impl ::std::default::Default for Struct__GstVideoBufferPoolClass {
    fn default() -> Struct__GstVideoBufferPoolClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type GstVideoSink = Struct__GstVideoSink;
pub type GstVideoSinkClass = Struct__GstVideoSinkClass;
pub type GstVideoRectangle = Struct__GstVideoRectangle;
pub enum Struct__GstVideoSinkPrivate { }
pub type GstVideoSinkPrivate = Struct__GstVideoSinkPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoRectangle {
    pub x: gint,
    pub y: gint,
    pub w: gint,
    pub h: gint,
}
impl ::std::default::Default for Struct__GstVideoRectangle {
    fn default() -> Struct__GstVideoRectangle {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoSink {
    pub element: GstBaseSink,
    pub width: gint,
    pub height: gint,
    pub _priv: *mut GstVideoSinkPrivate,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstVideoSink {
    fn default() -> Struct__GstVideoSink { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoSinkClass {
    pub parent_class: GstBaseSinkClass,
    pub show_frame: ::std::option::Option<extern "C" fn
                                              (video_sink: *mut GstVideoSink,
                                               buf: *mut GstBuffer)
                                              -> GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4u],
}
impl ::std::default::Default for Struct__GstVideoSinkClass {
    fn default() -> Struct__GstVideoSinkClass {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstNavigation { }
pub type GstNavigation = Struct__GstNavigation;
pub type GstNavigationInterface = Struct__GstNavigationInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstNavigationInterface {
    pub iface: GTypeInterface,
    pub send_event: ::std::option::Option<extern "C" fn
                                              (navigation: *mut GstNavigation,
                                               structure: *mut GstStructure)>,
}
impl ::std::default::Default for Struct__GstNavigationInterface {
    fn default() -> Struct__GstNavigationInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Enum_Unnamed232 = ::libc::c_uint;
pub const GST_NAVIGATION_COMMAND_INVALID: ::libc::c_uint = 0;
pub const GST_NAVIGATION_COMMAND_MENU1: ::libc::c_uint = 1;
pub const GST_NAVIGATION_COMMAND_MENU2: ::libc::c_uint = 2;
pub const GST_NAVIGATION_COMMAND_MENU3: ::libc::c_uint = 3;
pub const GST_NAVIGATION_COMMAND_MENU4: ::libc::c_uint = 4;
pub const GST_NAVIGATION_COMMAND_MENU5: ::libc::c_uint = 5;
pub const GST_NAVIGATION_COMMAND_MENU6: ::libc::c_uint = 6;
pub const GST_NAVIGATION_COMMAND_MENU7: ::libc::c_uint = 7;
pub const GST_NAVIGATION_COMMAND_LEFT: ::libc::c_uint = 20;
pub const GST_NAVIGATION_COMMAND_RIGHT: ::libc::c_uint = 21;
pub const GST_NAVIGATION_COMMAND_UP: ::libc::c_uint = 22;
pub const GST_NAVIGATION_COMMAND_DOWN: ::libc::c_uint = 23;
pub const GST_NAVIGATION_COMMAND_ACTIVATE: ::libc::c_uint = 24;
pub const GST_NAVIGATION_COMMAND_PREV_ANGLE: ::libc::c_uint = 30;
pub const GST_NAVIGATION_COMMAND_NEXT_ANGLE: ::libc::c_uint = 31;
pub type GstNavigationCommand = Enum_Unnamed232;
pub type Enum_Unnamed233 = ::libc::c_uint;
pub const GST_NAVIGATION_QUERY_INVALID: ::libc::c_uint = 0;
pub const GST_NAVIGATION_QUERY_COMMANDS: ::libc::c_uint = 1;
pub const GST_NAVIGATION_QUERY_ANGLES: ::libc::c_uint = 2;
pub type GstNavigationQueryType = Enum_Unnamed233;
pub type Enum_Unnamed234 = ::libc::c_uint;
pub const GST_NAVIGATION_MESSAGE_INVALID: ::libc::c_uint = 0;
pub const GST_NAVIGATION_MESSAGE_MOUSE_OVER: ::libc::c_uint = 1;
pub const GST_NAVIGATION_MESSAGE_COMMANDS_CHANGED: ::libc::c_uint = 2;
pub const GST_NAVIGATION_MESSAGE_ANGLES_CHANGED: ::libc::c_uint = 3;
pub type GstNavigationMessageType = Enum_Unnamed234;
pub type Enum_Unnamed235 = ::libc::c_uint;
pub const GST_NAVIGATION_EVENT_INVALID: ::libc::c_uint = 0;
pub const GST_NAVIGATION_EVENT_KEY_PRESS: ::libc::c_uint = 1;
pub const GST_NAVIGATION_EVENT_KEY_RELEASE: ::libc::c_uint = 2;
pub const GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS: ::libc::c_uint = 3;
pub const GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE: ::libc::c_uint = 4;
pub const GST_NAVIGATION_EVENT_MOUSE_MOVE: ::libc::c_uint = 5;
pub const GST_NAVIGATION_EVENT_COMMAND: ::libc::c_uint = 6;
pub type GstNavigationEventType = Enum_Unnamed235;
pub enum Struct__GstVideoOrientation { }
pub type GstVideoOrientation = Struct__GstVideoOrientation;
pub type GstVideoOrientationInterface = Struct__GstVideoOrientationInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoOrientationInterface {
    pub iface: GTypeInterface,
    pub get_hflip: ::std::option::Option<extern "C" fn
                                             (video_orientation:
                                                  *mut GstVideoOrientation,
                                              flip: *mut gboolean)
                                             -> gboolean>,
    pub get_vflip: ::std::option::Option<extern "C" fn
                                             (video_orientation:
                                                  *mut GstVideoOrientation,
                                              flip: *mut gboolean)
                                             -> gboolean>,
    pub get_hcenter: ::std::option::Option<extern "C" fn
                                               (video_orientation:
                                                    *mut GstVideoOrientation,
                                                center: *mut gint)
                                               -> gboolean>,
    pub get_vcenter: ::std::option::Option<extern "C" fn
                                               (video_orientation:
                                                    *mut GstVideoOrientation,
                                                center: *mut gint)
                                               -> gboolean>,
    pub set_hflip: ::std::option::Option<extern "C" fn
                                             (video_orientation:
                                                  *mut GstVideoOrientation,
                                              flip: gboolean) -> gboolean>,
    pub set_vflip: ::std::option::Option<extern "C" fn
                                             (video_orientation:
                                                  *mut GstVideoOrientation,
                                              flip: gboolean) -> gboolean>,
    pub set_hcenter: ::std::option::Option<extern "C" fn
                                               (video_orientation:
                                                    *mut GstVideoOrientation,
                                                center: gint) -> gboolean>,
    pub set_vcenter: ::std::option::Option<extern "C" fn
                                               (video_orientation:
                                                    *mut GstVideoOrientation,
                                                center: gint) -> gboolean>,
}
impl ::std::default::Default for Struct__GstVideoOrientationInterface {
    fn default() -> Struct__GstVideoOrientationInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstVideoOverlayRectangle { }
pub type GstVideoOverlayRectangle = Struct__GstVideoOverlayRectangle;
pub type Enum_Unnamed236 = ::libc::c_uint;
pub const GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE: ::libc::c_uint = 0;
pub const GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA: ::libc::c_uint =
    1;
pub const GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA: ::libc::c_uint = 2;
pub type GstVideoOverlayFormatFlags = Enum_Unnamed236;
pub enum Struct__GstVideoOverlayComposition { }
pub type GstVideoOverlayComposition = Struct__GstVideoOverlayComposition;
pub type GstVideoOverlayCompositionMeta =
    Struct__GstVideoOverlayCompositionMeta;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoOverlayCompositionMeta {
    pub meta: GstMeta,
    pub overlay: *mut GstVideoOverlayComposition,
}
impl ::std::default::Default for Struct__GstVideoOverlayCompositionMeta {
    fn default() -> Struct__GstVideoOverlayCompositionMeta {
        unsafe { ::std::mem::zeroed() }
    }
}
pub enum Struct__GstVideoOverlay { }
pub type GstVideoOverlay = Struct__GstVideoOverlay;
pub type GstVideoOverlayInterface = Struct__GstVideoOverlayInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GstVideoOverlayInterface {
    pub iface: GTypeInterface,
    pub expose: ::std::option::Option<extern "C" fn
                                          (overlay: *mut GstVideoOverlay)>,
    pub handle_events: ::std::option::Option<extern "C" fn
                                                 (overlay:
                                                      *mut GstVideoOverlay,
                                                  handle_events: gboolean)>,
    pub set_render_rectangle: ::std::option::Option<extern "C" fn
                                                        (overlay:
                                                             *mut GstVideoOverlay,
                                                         x: gint, y: gint,
                                                         width: gint,
                                                         height: gint)>,
    pub set_window_handle: ::std::option::Option<extern "C" fn
                                                     (overlay:
                                                          *mut GstVideoOverlay,
                                                      handle: guintptr)>,
}
impl ::std::default::Default for Struct__GstVideoOverlayInterface {
    fn default() -> Struct__GstVideoOverlayInterface {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut __tzname: [*mut ::libc::c_char; 2u];
    pub static mut __daylight: ::libc::c_int;
    pub static mut __timezone: ::libc::c_long;
    pub static mut tzname: [*mut ::libc::c_char; 2u];
    pub static mut daylight: ::libc::c_int;
    pub static mut timezone: ::libc::c_long;
    pub static mut _sys_siglist: [*const ::libc::c_char; 65u];
    pub static mut sys_siglist: [*const ::libc::c_char; 65u];
    pub static mut g_mem_gc_friendly: gboolean;
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
    pub static mut g_timeout_funcs: GSourceFuncs;
    pub static mut g_child_watch_funcs: GSourceFuncs;
    pub static mut g_idle_funcs: GSourceFuncs;
    pub static mut g_unix_signal_funcs: GSourceFuncs;
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
    pub static g_utf8_skip: *const gchar;
    pub static mut g_io_watch_funcs: GSourceFuncs;
    pub static g_ascii_table: *const guint16;
    pub static g_test_config_vars: *const GTestConfig;
    pub static glib_major_version: guint;
    pub static glib_minor_version: guint;
    pub static glib_micro_version: guint;
    pub static glib_interface_age: guint;
    pub static glib_binary_age: guint;
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
    pub static mut g_thread_use_default_impl: gboolean;
    pub static mut g_thread_gettime:
               ::std::option::Option<extern "C" fn() -> guint64>;
    pub static mut g_threads_got_initialized: gboolean;
    pub static mut g_param_spec_types: *mut GType;
    pub static mut _gst_memory_type: GType;
    pub static mut gst_memory_alignment: gsize;
    pub static mut _gst_buffer_type: GType;
    pub static mut _gst_meta_transform_copy: GQuark;
    pub static mut _gst_meta_tag_memory: GQuark;
    pub static mut _gst_buffer_list_type: GType;
    pub static mut _gst_date_time_type: GType;
    pub static mut _gst_structure_type: GType;
    pub static mut _gst_caps_features_type: GType;
    pub static mut _gst_caps_features_any: *mut GstCapsFeatures;
    pub static mut _gst_caps_features_memory_system_memory:
               *mut GstCapsFeatures;
    pub static mut _gst_caps_type: GType;
    pub static mut _gst_caps_any: *mut GstCaps;
    pub static mut _gst_caps_none: *mut GstCaps;
    pub static mut _gst_sample_type: GType;
    pub static mut _gst_tag_list_type: GType;
    pub static mut _gst_toc_type: GType;
    pub static mut _gst_toc_entry_type: GType;
    pub static mut _gst_context_type: GType;
    pub static mut _gst_query_type: GType;
    pub static mut _gst_message_type: GType;
    pub static mut _gst_event_type: GType;
    pub static mut GST_CAT_DEFAULT: *mut GstDebugCategory;
    pub static mut _gst_debug_enabled: gboolean;
    pub static mut _gst_debug_min: GstDebugLevel;
    pub static mut _gst_int_range_type: GType;
    pub static mut _gst_int64_range_type: GType;
    pub static mut _gst_double_range_type: GType;
    pub static mut _gst_fraction_range_type: GType;
    pub static mut _gst_value_list_type: GType;
    pub static mut _gst_value_array_type: GType;
    pub static mut _gst_fraction_type: GType;
    pub static mut _gst_bitmask_type: GType;
}
extern "C" {
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t) -> ::libc::c_double;
    pub fn mktime(__tp: *mut Struct_tm) -> time_t;
    pub fn strftime(__s: *mut ::libc::c_char, __maxsize: size_t,
                    __format: *const ::libc::c_char, __tp: *const Struct_tm)
     -> size_t;
    pub fn strftime_l(__s: *mut ::libc::c_char, __maxsize: size_t,
                      __format: *const ::libc::c_char, __tp: *const Struct_tm,
                      __loc: __locale_t) -> size_t;
    pub fn gmtime(__timer: *const time_t) -> *mut Struct_tm;
    pub fn localtime(__timer: *const time_t) -> *mut Struct_tm;
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut Struct_tm)
     -> *mut Struct_tm;
    pub fn localtime_r(__timer: *const time_t, __tp: *mut Struct_tm)
     -> *mut Struct_tm;
    pub fn asctime(__tp: *const Struct_tm) -> *mut ::libc::c_char;
    pub fn ctime(__timer: *const time_t) -> *mut ::libc::c_char;
    pub fn asctime_r(__tp: *const Struct_tm, __buf: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn tzset();
    pub fn stime(__when: *const time_t) -> ::libc::c_int;
    pub fn timegm(__tp: *mut Struct_tm) -> time_t;
    pub fn timelocal(__tp: *mut Struct_tm) -> time_t;
    pub fn dysize(__year: ::libc::c_int) -> ::libc::c_int;
    pub fn nanosleep(__requested_time: *const Struct_timespec,
                     __remaining: *mut Struct_timespec) -> ::libc::c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut Struct_timespec)
     -> ::libc::c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut Struct_timespec)
     -> ::libc::c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const Struct_timespec)
     -> ::libc::c_int;
    pub fn clock_nanosleep(__clock_id: clockid_t, __flags: ::libc::c_int,
                           __req: *const Struct_timespec,
                           __rem: *mut Struct_timespec) -> ::libc::c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::libc::c_int;
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut Struct_sigevent,
                        __timerid: *mut timer_t) -> ::libc::c_int;
    pub fn timer_delete(__timerid: timer_t) -> ::libc::c_int;
    pub fn timer_settime(__timerid: timer_t, __flags: ::libc::c_int,
                         __value: *const Struct_itimerspec,
                         __ovalue: *mut Struct_itimerspec) -> ::libc::c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut Struct_itimerspec)
     -> ::libc::c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> ::libc::c_int;
    pub fn g_array_new(zero_terminated: gboolean, clear_: gboolean,
                       element_size: guint) -> *mut GArray;
    pub fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean,
                             element_size: guint, reserved_size: guint)
     -> *mut GArray;
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean)
     -> *mut gchar;
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
    pub fn g_array_unref(array: *mut GArray);
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer,
                               len: guint) -> *mut GArray;
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer,
                                len: guint) -> *mut GArray;
    pub fn g_array_insert_vals(array: *mut GArray, index_: guint,
                               data: gconstpointer, len: guint)
     -> *mut GArray;
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
    pub fn g_array_remove_index(array: *mut GArray, index_: guint)
     -> *mut GArray;
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint)
     -> *mut GArray;
    pub fn g_array_remove_range(array: *mut GArray, index_: guint,
                                length: guint) -> *mut GArray;
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
    pub fn g_array_sort_with_data(array: *mut GArray,
                                  compare_func: GCompareDataFunc,
                                  user_data: gpointer);
    pub fn g_array_set_clear_func(array: *mut GArray,
                                  clear_func: GDestroyNotify);
    pub fn g_ptr_array_new() -> *mut GPtrArray;
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify)
     -> *mut GPtrArray;
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
    pub fn g_ptr_array_new_full(reserved_size: guint,
                                element_free_func: GDestroyNotify)
     -> *mut GPtrArray;
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean)
     -> *mut gpointer;
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray,
                                     element_free_func: GDestroyNotify);
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint)
     -> gpointer;
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint)
     -> gpointer;
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer)
     -> gboolean;
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer)
     -> gboolean;
    pub fn g_ptr_array_remove_range(array: *mut GPtrArray, index_: guint,
                                    length: guint) -> *mut GPtrArray;
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint,
                              data: gpointer);
    pub fn g_ptr_array_sort(array: *mut GPtrArray,
                            compare_func: GCompareFunc);
    pub fn g_ptr_array_sort_with_data(array: *mut GPtrArray,
                                      compare_func: GCompareDataFunc,
                                      user_data: gpointer);
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc,
                               user_data: gpointer);
    pub fn g_byte_array_new() -> *mut GByteArray;
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize)
     -> *mut GByteArray;
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean)
     -> *mut guint8;
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
    pub fn g_byte_array_unref(array: *mut GByteArray);
    pub fn g_byte_array_append(array: *mut GByteArray, data: *const guint8,
                               len: guint) -> *mut GByteArray;
    pub fn g_byte_array_prepend(array: *mut GByteArray, data: *const guint8,
                                len: guint) -> *mut GByteArray;
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint)
     -> *mut GByteArray;
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint)
     -> *mut GByteArray;
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray,
                                          index_: guint) -> *mut GByteArray;
    pub fn g_byte_array_remove_range(array: *mut GByteArray, index_: guint,
                                     length: guint) -> *mut GByteArray;
    pub fn g_byte_array_sort(array: *mut GByteArray,
                             compare_func: GCompareFunc);
    pub fn g_byte_array_sort_with_data(array: *mut GByteArray,
                                       compare_func: GCompareDataFunc,
                                       user_data: gpointer);
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
    pub fn g_atomic_int_inc(atomic: *mut gint);
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
    pub fn g_atomic_int_compare_and_exchange(atomic: *mut gint, oldval: gint,
                                             newval: gint) -> gboolean;
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_pointer_get(atomic: *const ::libc::c_void) -> gpointer;
    pub fn g_atomic_pointer_set(atomic: *mut ::libc::c_void,
                                newval: gpointer);
    pub fn g_atomic_pointer_compare_and_exchange(atomic: *mut ::libc::c_void,
                                                 oldval: gpointer,
                                                 newval: gpointer)
     -> gboolean;
    pub fn g_atomic_pointer_add(atomic: *mut ::libc::c_void, val: gssize)
     -> gssize;
    pub fn g_atomic_pointer_and(atomic: *mut ::libc::c_void, val: gsize)
     -> gsize;
    pub fn g_atomic_pointer_or(atomic: *mut ::libc::c_void, val: gsize)
     -> gsize;
    pub fn g_atomic_pointer_xor(atomic: *mut ::libc::c_void, val: gsize)
     -> gsize;
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint)
     -> gint;
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...)
     -> *mut GError;
    pub fn g_error_new_literal(domain: GQuark, code: gint,
                               message: *const gchar) -> *mut GError;
    pub fn g_error_new_valist(domain: GQuark, code: gint,
                              format: *const gchar, args: va_list)
     -> *mut GError;
    pub fn g_error_free(error: *mut GError);
    pub fn g_error_copy(error: *const GError) -> *mut GError;
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint)
     -> gboolean;
    pub fn g_set_error(err: *mut *mut GError, domain: GQuark, code: gint,
                       format: *const gchar, ...);
    pub fn g_set_error_literal(err: *mut *mut GError, domain: GQuark,
                               code: gint, message: *const gchar);
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
    pub fn g_clear_error(err: *mut *mut GError);
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
    pub fn g_propagate_prefixed_error(dest: *mut *mut GError,
                                      src: *mut GError,
                                      format: *const gchar, ...);
    pub fn g_thread_error_quark() -> GQuark;
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
    pub fn g_thread_unref(thread: *mut GThread);
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer)
     -> *mut GThread;
    pub fn g_thread_try_new(name: *const gchar, func: GThreadFunc,
                            data: gpointer, error: *mut *mut GError)
     -> *mut GThread;
    pub fn g_thread_self() -> *mut GThread;
    pub fn g_thread_exit(retval: gpointer);
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
    pub fn g_thread_yield();
    pub fn g_mutex_init(mutex: *mut GMutex);
    pub fn g_mutex_clear(mutex: *mut GMutex);
    pub fn g_mutex_lock(mutex: *mut GMutex);
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
    pub fn g_mutex_unlock(mutex: *mut GMutex);
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
    pub fn g_cond_init(cond: *mut GCond);
    pub fn g_cond_clear(cond: *mut GCond);
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
    pub fn g_cond_signal(cond: *mut GCond);
    pub fn g_cond_broadcast(cond: *mut GCond);
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex,
                             end_time: gint64) -> gboolean;
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer)
     -> gpointer;
    pub fn g_once_init_enter(location: *mut ::libc::c_void) -> gboolean;
    pub fn g_once_init_leave(location: *mut ::libc::c_void, result: gsize);
    pub fn g_get_num_processors() -> guint;
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify)
     -> *mut GAsyncQueue;
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue,
                                       data: gpointer);
    pub fn g_async_queue_push_sorted(queue: *mut GAsyncQueue, data: gpointer,
                                     func: GCompareDataFunc,
                                     user_data: gpointer);
    pub fn g_async_queue_push_sorted_unlocked(queue: *mut GAsyncQueue,
                                              data: gpointer,
                                              func: GCompareDataFunc,
                                              user_data: gpointer);
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue)
     -> gpointer;
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue,
                                     timeout: guint64) -> gpointer;
    pub fn g_async_queue_timeout_pop_unlocked(queue: *mut GAsyncQueue,
                                              timeout: guint64) -> gpointer;
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc,
                              user_data: gpointer);
    pub fn g_async_queue_sort_unlocked(queue: *mut GAsyncQueue,
                                       func: GCompareDataFunc,
                                       user_data: gpointer);
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue,
                                   end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timed_pop_unlocked(queue: *mut GAsyncQueue,
                                            end_time: *mut GTimeVal)
     -> gpointer;
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn __sysv_signal(__sig: ::libc::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn signal(__sig: ::libc::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn kill(__pid: __pid_t, __sig: ::libc::c_int) -> ::libc::c_int;
    pub fn killpg(__pgrp: __pid_t, __sig: ::libc::c_int) -> ::libc::c_int;
    pub fn raise(__sig: ::libc::c_int) -> ::libc::c_int;
    pub fn ssignal(__sig: ::libc::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn gsignal(__sig: ::libc::c_int) -> ::libc::c_int;
    pub fn psignal(__sig: ::libc::c_int, __s: *const ::libc::c_char);
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::libc::c_char);
    pub fn __sigpause(__sig_or_mask: ::libc::c_int, __is_sig: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sigblock(__mask: ::libc::c_int) -> ::libc::c_int;
    pub fn sigsetmask(__mask: ::libc::c_int) -> ::libc::c_int;
    pub fn siggetmask() -> ::libc::c_int;
    pub fn sigemptyset(__set: *mut sigset_t) -> ::libc::c_int;
    pub fn sigfillset(__set: *mut sigset_t) -> ::libc::c_int;
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sigismember(__set: *const sigset_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sigprocmask(__how: ::libc::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::libc::c_int;
    pub fn sigsuspend(__set: *const sigset_t) -> ::libc::c_int;
    pub fn sigaction(__sig: ::libc::c_int, __act: *const Struct_sigaction,
                     __oact: *mut Struct_sigaction) -> ::libc::c_int;
    pub fn sigpending(__set: *mut sigset_t) -> ::libc::c_int;
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::libc::c_int;
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const Struct_timespec) -> ::libc::c_int;
    pub fn sigqueue(__pid: __pid_t, __sig: ::libc::c_int, __val: Union_sigval)
     -> ::libc::c_int;
    pub fn sigvec(__sig: ::libc::c_int, __vec: *const Struct_sigvec,
                  __ovec: *mut Struct_sigvec) -> ::libc::c_int;
    pub fn sigreturn(__scp: *mut Struct_sigcontext) -> ::libc::c_int;
    pub fn siginterrupt(__sig: ::libc::c_int, __interrupt: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sigstack(__ss: *mut Struct_sigstack, __oss: *mut Struct_sigstack)
     -> ::libc::c_int;
    pub fn sigaltstack(__ss: *const Struct_sigaltstack,
                       __oss: *mut Struct_sigaltstack) -> ::libc::c_int;
    pub fn pthread_sigmask(__how: ::libc::c_int, __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t) -> ::libc::c_int;
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
    pub fn __libc_current_sigrtmin() -> ::libc::c_int;
    pub fn __libc_current_sigrtmax() -> ::libc::c_int;
    pub fn g_on_error_query(prg_name: *const gchar);
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
    pub fn g_base64_encode_step(_in: *const guchar, len: gsize,
                                break_lines: gboolean, out: *mut gchar,
                                state: *mut gint, save: *mut gint) -> gsize;
    pub fn g_base64_encode_close(break_lines: gboolean, out: *mut gchar,
                                 state: *mut gint, save: *mut gint) -> gsize;
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
    pub fn g_base64_decode_step(_in: *const gchar, len: gsize,
                                out: *mut guchar, state: *mut gint,
                                save: *mut guint) -> gsize;
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize)
     -> *mut guchar;
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize)
     -> *mut guchar;
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
    pub fn g_pointer_bit_lock(address: *mut ::libc::c_void, lock_bit: gint);
    pub fn g_pointer_bit_trylock(address: *mut ::libc::c_void, lock_bit: gint)
     -> gboolean;
    pub fn g_pointer_bit_unlock(address: *mut ::libc::c_void, lock_bit: gint);
    pub fn g_bookmark_file_error_quark() -> GQuark;
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
    pub fn g_bookmark_file_load_from_file(bookmark: *mut GBookmarkFile,
                                          filename: *const gchar,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_load_from_data(bookmark: *mut GBookmarkFile,
                                          data: *const gchar, length: gsize,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_load_from_data_dirs(bookmark: *mut GBookmarkFile,
                                               file: *const gchar,
                                               full_path: *mut *mut gchar,
                                               error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_to_data(bookmark: *mut GBookmarkFile,
                                   length: *mut gsize,
                                   error: *mut *mut GError) -> *mut gchar;
    pub fn g_bookmark_file_to_file(bookmark: *mut GBookmarkFile,
                                   filename: *const gchar,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_title(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, title: *const gchar);
    pub fn g_bookmark_file_get_title(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar,
                                     error: *mut *mut GError) -> *mut gchar;
    pub fn g_bookmark_file_set_description(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           description: *const gchar);
    pub fn g_bookmark_file_get_description(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_bookmark_file_set_mime_type(bookmark: *mut GBookmarkFile,
                                         uri: *const gchar,
                                         mime_type: *const gchar);
    pub fn g_bookmark_file_get_mime_type(bookmark: *mut GBookmarkFile,
                                         uri: *const gchar,
                                         error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_bookmark_file_set_groups(bookmark: *mut GBookmarkFile,
                                      uri: *const gchar,
                                      groups: *mut *const gchar,
                                      length: gsize);
    pub fn g_bookmark_file_add_group(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, group: *const gchar);
    pub fn g_bookmark_file_has_group(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, group: *const gchar,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_groups(bookmark: *mut GBookmarkFile,
                                      uri: *const gchar, length: *mut gsize,
                                      error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_bookmark_file_add_application(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           name: *const gchar,
                                           exec: *const gchar);
    pub fn g_bookmark_file_has_application(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           name: *const gchar,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_get_applications(bookmark: *mut GBookmarkFile,
                                            uri: *const gchar,
                                            length: *mut gsize,
                                            error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_bookmark_file_set_app_info(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar, name: *const gchar,
                                        exec: *const gchar, count: gint,
                                        stamp: time_t,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_app_info(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar, name: *const gchar,
                                        exec: *mut *mut gchar,
                                        count: *mut guint, stamp: *mut time_t,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_is_private(bookmark: *mut GBookmarkFile,
                                          uri: *const gchar,
                                          is_private: gboolean);
    pub fn g_bookmark_file_get_is_private(bookmark: *mut GBookmarkFile,
                                          uri: *const gchar,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_set_icon(bookmark: *mut GBookmarkFile,
                                    uri: *const gchar, href: *const gchar,
                                    mime_type: *const gchar);
    pub fn g_bookmark_file_get_icon(bookmark: *mut GBookmarkFile,
                                    uri: *const gchar, href: *mut *mut gchar,
                                    mime_type: *mut *mut gchar,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_added(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, added: time_t);
    pub fn g_bookmark_file_get_added(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar,
                                     error: *mut *mut GError) -> time_t;
    pub fn g_bookmark_file_set_modified(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar, modified: time_t);
    pub fn g_bookmark_file_get_modified(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar,
                                        error: *mut *mut GError) -> time_t;
    pub fn g_bookmark_file_set_visited(bookmark: *mut GBookmarkFile,
                                       uri: *const gchar, visited: time_t);
    pub fn g_bookmark_file_get_visited(bookmark: *mut GBookmarkFile,
                                       uri: *const gchar,
                                       error: *mut *mut GError) -> time_t;
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile,
                                    uri: *const gchar) -> gboolean;
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
    pub fn g_bookmark_file_get_uris(bookmark: *mut GBookmarkFile,
                                    length: *mut gsize) -> *mut *mut gchar;
    pub fn g_bookmark_file_remove_group(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar,
                                        group: *const gchar,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_application(bookmark: *mut GBookmarkFile,
                                              uri: *const gchar,
                                              name: *const gchar,
                                              error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_remove_item(bookmark: *mut GBookmarkFile,
                                       uri: *const gchar,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_move_item(bookmark: *mut GBookmarkFile,
                                     old_uri: *const gchar,
                                     new_uri: *const gchar,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize)
     -> *mut GBytes;
    pub fn g_bytes_new_with_free_func(data: gconstpointer, size: gsize,
                                      free_func: GDestroyNotify,
                                      user_data: gpointer) -> *mut GBytes;
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize,
                                  length: gsize) -> *mut GBytes;
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize)
     -> gconstpointer;
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
    pub fn g_bytes_unref(bytes: *mut GBytes);
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize)
     -> gpointer;
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer)
     -> gboolean;
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer)
     -> gint;
    pub fn g_get_charset(charset: *mut *const ::libc::c_char) -> gboolean;
    pub fn g_get_codeset() -> *mut gchar;
    pub fn g_get_language_names() -> *const *const gchar;
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
    pub fn g_checksum_reset(checksum: *mut GChecksum);
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
    pub fn g_checksum_free(checksum: *mut GChecksum);
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar,
                             length: gssize);
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
    pub fn g_checksum_get_digest(checksum: *mut GChecksum,
                                 buffer: *mut guint8, digest_len: *mut gsize);
    pub fn g_compute_checksum_for_data(checksum_type: GChecksumType,
                                       data: *const guchar, length: gsize)
     -> *mut gchar;
    pub fn g_compute_checksum_for_string(checksum_type: GChecksumType,
                                         str: *const gchar, length: gssize)
     -> *mut gchar;
    pub fn g_compute_checksum_for_bytes(checksum_type: GChecksumType,
                                        data: *mut GBytes) -> *mut gchar;
    pub fn g_convert_error_quark() -> GQuark;
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar)
     -> GIConv;
    pub fn g_iconv(converter: GIConv, inbuf: *mut *mut gchar,
                   inbytes_left: *mut gsize, outbuf: *mut *mut gchar,
                   outbytes_left: *mut gsize) -> gsize;
    pub fn g_iconv_close(converter: GIConv) -> gint;
    pub fn g_convert(str: *const gchar, len: gssize, to_codeset: *const gchar,
                     from_codeset: *const gchar, bytes_read: *mut gsize,
                     bytes_written: *mut gsize, error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_convert_with_iconv(str: *const gchar, len: gssize,
                                converter: GIConv, bytes_read: *mut gsize,
                                bytes_written: *mut gsize,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_convert_with_fallback(str: *const gchar, len: gssize,
                                   to_codeset: *const gchar,
                                   from_codeset: *const gchar,
                                   fallback: *const gchar,
                                   bytes_read: *mut gsize,
                                   bytes_written: *mut gsize,
                                   error: *mut *mut GError) -> *mut gchar;
    pub fn g_locale_to_utf8(opsysstring: *const gchar, len: gssize,
                            bytes_read: *mut gsize, bytes_written: *mut gsize,
                            error: *mut *mut GError) -> *mut gchar;
    pub fn g_locale_from_utf8(utf8string: *const gchar, len: gssize,
                              bytes_read: *mut gsize,
                              bytes_written: *mut gsize,
                              error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_to_utf8(opsysstring: *const gchar, len: gssize,
                              bytes_read: *mut gsize,
                              bytes_written: *mut gsize,
                              error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_from_utf8(utf8string: *const gchar, len: gssize,
                                bytes_read: *mut gsize,
                                bytes_written: *mut gsize,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_from_uri(uri: *const gchar, hostname: *mut *mut gchar,
                               error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_to_uri(filename: *const gchar, hostname: *const gchar,
                             error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
    pub fn g_get_filename_charsets(charsets: *mut *mut *const gchar)
     -> gboolean;
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
    pub fn g_datalist_init(datalist: *mut *mut GData);
    pub fn g_datalist_clear(datalist: *mut *mut GData);
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark)
     -> gpointer;
    pub fn g_datalist_id_set_data_full(datalist: *mut *mut GData,
                                       key_id: GQuark, data: gpointer,
                                       destroy_func: GDestroyNotify);
    pub fn g_datalist_id_dup_data(datalist: *mut *mut GData, key_id: GQuark,
                                  dup_func: GDuplicateFunc,
                                  user_data: gpointer) -> gpointer;
    pub fn g_datalist_id_replace_data(datalist: *mut *mut GData,
                                      key_id: GQuark, oldval: gpointer,
                                      newval: gpointer,
                                      destroy: GDestroyNotify,
                                      old_destroy: *mut GDestroyNotify)
     -> gboolean;
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData,
                                          key_id: GQuark) -> gpointer;
    pub fn g_datalist_foreach(datalist: *mut *mut GData,
                              func: GDataForeachFunc, user_data: gpointer);
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer,
                                 key_id: GQuark) -> gpointer;
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar)
     -> gpointer;
    pub fn g_dataset_id_set_data_full(dataset_location: gconstpointer,
                                      key_id: GQuark, data: gpointer,
                                      destroy_func: GDestroyNotify);
    pub fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer,
                                         key_id: GQuark) -> gpointer;
    pub fn g_dataset_foreach(dataset_location: gconstpointer,
                             func: GDataForeachFunc, user_data: gpointer);
    pub fn g_date_new() -> *mut GDate;
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear)
     -> *mut GDate;
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
    pub fn g_date_free(date: *mut GDate);
    pub fn g_date_valid(date: *const GDate) -> gboolean;
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear)
     -> gboolean;
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
    pub fn g_date_set_parse(date: *mut GDate, str: *const gchar);
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth,
                          y: GDateYear);
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear)
     -> guint8;
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate)
     -> gint;
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut Struct_tm);
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate,
                        max_date: *const GDate);
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
    pub fn g_date_strftime(s: *mut gchar, slen: gsize, format: *const gchar,
                           date: *const GDate) -> gsize;
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, _type: GTimeType,
                                     time_: gint64) -> gint;
    pub fn g_time_zone_adjust_time(tz: *mut GTimeZone, _type: GTimeType,
                                   time_: *mut gint64) -> gint;
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint)
     -> *const gchar;
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint)
     -> gint32;
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
    pub fn g_date_time_unref(datetime: *mut GDateTime);
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal)
     -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal)
     -> *mut GDateTime;
    pub fn g_date_time_new(tz: *mut GTimeZone, year: gint, month: gint,
                           day: gint, hour: gint, minute: gint,
                           seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_new_local(year: gint, month: gint, day: gint,
                                 hour: gint, minute: gint, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_new_utc(year: gint, month: gint, day: gint, hour: gint,
                               minute: gint, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan)
     -> *mut GDateTime;
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_add_full(datetime: *mut GDateTime, years: gint,
                                months: gint, days: gint, hours: gint,
                                minutes: gint, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer)
     -> gint;
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime)
     -> GTimeSpan;
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer)
     -> gboolean;
    pub fn g_date_time_get_ymd(datetime: *mut GDateTime, year: *mut gint,
                               month: *mut gint, day: *mut gint);
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime)
     -> gint;
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal)
     -> gboolean;
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime)
     -> *const gchar;
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime)
     -> gboolean;
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime,
                                   tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar)
     -> *mut gchar;
    pub fn opendir(__name: *const ::libc::c_char) -> *mut DIR;
    pub fn fdopendir(__fd: ::libc::c_int) -> *mut DIR;
    pub fn closedir(__dirp: *mut DIR) -> ::libc::c_int;
    pub fn readdir(__dirp: *mut DIR) -> *mut Struct_dirent;
    pub fn readdir_r(__dirp: *mut DIR, __entry: *mut Struct_dirent,
                     __result: *mut *mut Struct_dirent) -> ::libc::c_int;
    pub fn rewinddir(__dirp: *mut DIR);
    pub fn seekdir(__dirp: *mut DIR, __pos: ::libc::c_long);
    pub fn telldir(__dirp: *mut DIR) -> ::libc::c_long;
    pub fn dirfd(__dirp: *mut DIR) -> ::libc::c_int;
    pub fn scandir(__dir: *const ::libc::c_char,
                   __namelist: *mut *mut *mut Struct_dirent,
                   __selector:
                       ::std::option::Option<extern "C" fn
                                                 (arg1: *const Struct_dirent)
                                                 -> ::libc::c_int>,
                   __cmp:
                       ::std::option::Option<extern "C" fn
                                                 (arg1:
                                                      *mut *const Struct_dirent,
                                                  arg2:
                                                      *mut *const Struct_dirent)
                                                 -> ::libc::c_int>)
     -> ::libc::c_int;
    pub fn alphasort(__e1: *mut *const Struct_dirent,
                     __e2: *mut *const Struct_dirent) -> ::libc::c_int;
    pub fn getdirentries(__fd: ::libc::c_int, __buf: *mut ::libc::c_char,
                         __nbytes: size_t, __basep: *mut __off_t)
     -> __ssize_t;
    pub fn g_dir_open(path: *const gchar, flags: guint,
                      error: *mut *mut GError) -> *mut GDir;
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
    pub fn g_dir_rewind(dir: *mut GDir);
    pub fn g_dir_close(dir: *mut GDir);
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
    pub fn g_setenv(variable: *const gchar, value: *const gchar,
                    overwrite: gboolean) -> gboolean;
    pub fn g_unsetenv(variable: *const gchar);
    pub fn g_listenv() -> *mut *mut gchar;
    pub fn g_get_environ() -> *mut *mut gchar;
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar)
     -> *const gchar;
    pub fn g_environ_setenv(envp: *mut *mut gchar, variable: *const gchar,
                            value: *const gchar, overwrite: gboolean)
     -> *mut *mut gchar;
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar)
     -> *mut *mut gchar;
    pub fn g_file_error_quark() -> GQuark;
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
    pub fn g_file_get_contents(filename: *const gchar,
                               contents: *mut *mut gchar, length: *mut gsize,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_contents(filename: *const gchar, contents: *const gchar,
                               length: gssize, error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
    pub fn g_file_open_tmp(tmpl: *const gchar, name_used: *mut *mut gchar,
                           error: *mut *mut GError) -> gint;
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_build_path(separator: *const gchar,
                        first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar)
     -> *mut gchar;
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
    pub fn g_get_current_dir() -> *mut gchar;
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar)
     -> *const gchar;
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar)
     -> *const gchar;
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar,
                       category: gint) -> *const gchar;
    pub fn g_dngettext(domain: *const gchar, msgid: *const gchar,
                       msgid_plural: *const gchar, n: gulong) -> *const gchar;
    pub fn g_dpgettext(domain: *const gchar, msgctxtid: *const gchar,
                       msgidoffset: gsize) -> *const gchar;
    pub fn g_dpgettext2(domain: *const gchar, context: *const gchar,
                        msgid: *const gchar) -> *const gchar;
    pub fn g_free(mem: gpointer);
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize)
     -> gpointer;
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize,
                           n_block_bytes: gsize) -> gpointer;
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
    pub fn g_mem_is_system_malloc() -> gboolean;
    pub fn g_mem_profile();
    pub fn g_node_new(data: gpointer) -> *mut GNode;
    pub fn g_node_destroy(root: *mut GNode);
    pub fn g_node_unlink(node: *mut GNode);
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc,
                            data: gpointer) -> *mut GNode;
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode)
     -> *mut GNode;
    pub fn g_node_insert_before(parent: *mut GNode, sibling: *mut GNode,
                                node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_after(parent: *mut GNode, sibling: *mut GNode,
                               node: *mut GNode) -> *mut GNode;
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode)
     -> gboolean;
    pub fn g_node_depth(node: *mut GNode) -> guint;
    pub fn g_node_find(root: *mut GNode, order: GTraverseType,
                       flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_traverse(root: *mut GNode, order: GTraverseType,
                           flags: GTraverseFlags, max_depth: gint,
                           func: GNodeTraverseFunc, data: gpointer);
    pub fn g_node_max_height(root: *mut GNode) -> guint;
    pub fn g_node_children_foreach(node: *mut GNode, flags: GTraverseFlags,
                                   func: GNodeForeachFunc, data: gpointer);
    pub fn g_node_reverse_children(node: *mut GNode);
    pub fn g_node_n_children(node: *mut GNode) -> guint;
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags,
                             data: gpointer) -> *mut GNode;
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_list_alloc() -> *mut GList;
    pub fn g_list_free(list: *mut GList);
    pub fn g_list_free_1(list: *mut GList);
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint)
     -> *mut GList;
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer,
                                func: GCompareFunc) -> *mut GList;
    pub fn g_list_insert_sorted_with_data(list: *mut GList, data: gpointer,
                                          func: GCompareDataFunc,
                                          user_data: gpointer) -> *mut GList;
    pub fn g_list_insert_before(list: *mut GList, sibling: *mut GList,
                                data: gpointer) -> *mut GList;
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer)
     -> *mut GList;
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList)
     -> *mut GList;
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList)
     -> *mut GList;
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc,
                            user_data: gpointer) -> *mut GList;
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_find_custom(list: *mut GList, data: gconstpointer,
                              func: GCompareFunc) -> *mut GList;
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
    pub fn g_list_last(list: *mut GList) -> *mut GList;
    pub fn g_list_first(list: *mut GList) -> *mut GList;
    pub fn g_list_length(list: *mut GList) -> guint;
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc)
     -> *mut GList;
    pub fn g_list_sort_with_data(list: *mut GList,
                                 compare_func: GCompareDataFunc,
                                 user_data: gpointer) -> *mut GList;
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc)
     -> *mut GHashTable;
    pub fn g_hash_table_new_full(hash_func: GHashFunc,
                                 key_equal_func: GEqualFunc,
                                 key_destroy_func: GDestroyNotify,
                                 value_destroy_func: GDestroyNotify)
     -> *mut GHashTable;
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
    pub fn g_hash_table_insert(hash_table: *mut GHashTable, key: gpointer,
                               value: gpointer) -> gboolean;
    pub fn g_hash_table_replace(hash_table: *mut GHashTable, key: gpointer,
                                value: gpointer) -> gboolean;
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer)
     -> gboolean;
    pub fn g_hash_table_remove(hash_table: *mut GHashTable,
                               key: gconstpointer) -> gboolean;
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer)
     -> gboolean;
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable,
                               key: gconstpointer) -> gpointer;
    pub fn g_hash_table_contains(hash_table: *mut GHashTable,
                                 key: gconstpointer) -> gboolean;
    pub fn g_hash_table_lookup_extended(hash_table: *mut GHashTable,
                                        lookup_key: gconstpointer,
                                        orig_key: *mut gpointer,
                                        value: *mut gpointer) -> gboolean;
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc,
                                user_data: gpointer);
    pub fn g_hash_table_find(hash_table: *mut GHashTable, predicate: GHRFunc,
                             user_data: gpointer) -> gpointer;
    pub fn g_hash_table_foreach_remove(hash_table: *mut GHashTable,
                                       func: GHRFunc, user_data: gpointer)
     -> guint;
    pub fn g_hash_table_foreach_steal(hash_table: *mut GHashTable,
                                      func: GHRFunc, user_data: gpointer)
     -> guint;
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_keys_as_array(hash_table: *mut GHashTable,
                                          length: *mut guint)
     -> *mut gpointer;
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter,
                                  hash_table: *mut GHashTable);
    pub fn g_hash_table_iter_next(iter: *mut GHashTableIter,
                                  key: *mut gpointer, value: *mut gpointer)
     -> gboolean;
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter)
     -> *mut GHashTable;
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter,
                                     value: gpointer);
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_str_hash(v: gconstpointer) -> guint;
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int_hash(v: gconstpointer) -> guint;
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int64_hash(v: gconstpointer) -> guint;
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_double_hash(v: gconstpointer) -> guint;
    pub fn g_direct_hash(v: gconstpointer) -> guint;
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar,
                      key_len: gsize) -> *mut GHmac;
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
    pub fn g_hmac_unref(hmac: *mut GHmac);
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar,
                         length: gssize);
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8,
                             digest_len: *mut gsize);
    pub fn g_compute_hmac_for_data(digest_type: GChecksumType,
                                   key: *const guchar, key_len: gsize,
                                   data: *const guchar, length: gsize)
     -> *mut gchar;
    pub fn g_compute_hmac_for_string(digest_type: GChecksumType,
                                     key: *const guchar, key_len: gsize,
                                     str: *const gchar, length: gssize)
     -> *mut gchar;
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook)
     -> *mut GHook;
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong)
     -> gboolean;
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_insert_before(hook_list: *mut GHookList,
                                sibling: *mut GHook, hook: *mut GHook);
    pub fn g_hook_insert_sorted(hook_list: *mut GHookList, hook: *mut GHook,
                                func: GHookCompareFunc);
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong)
     -> *mut GHook;
    pub fn g_hook_find(hook_list: *mut GHookList, need_valids: gboolean,
                       func: GHookFindFunc, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_data(hook_list: *mut GHookList, need_valids: gboolean,
                            data: gpointer) -> *mut GHook;
    pub fn g_hook_find_func(hook_list: *mut GHookList, need_valids: gboolean,
                            func: gpointer) -> *mut GHook;
    pub fn g_hook_find_func_data(hook_list: *mut GHookList,
                                 need_valids: gboolean, func: gpointer,
                                 data: gpointer) -> *mut GHook;
    pub fn g_hook_first_valid(hook_list: *mut GHookList,
                              may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_next_valid(hook_list: *mut GHookList, hook: *mut GHook,
                             may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook)
     -> gint;
    pub fn g_hook_list_invoke(hook_list: *mut GHookList,
                              may_recurse: gboolean);
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList,
                                    may_recurse: gboolean);
    pub fn g_hook_list_marshal(hook_list: *mut GHookList,
                               may_recurse: gboolean,
                               marshaller: GHookMarshaller,
                               marshal_data: gpointer);
    pub fn g_hook_list_marshal_check(hook_list: *mut GHookList,
                                     may_recurse: gboolean,
                                     marshaller: GHookCheckMarshaller,
                                     marshal_data: gpointer);
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
    pub fn g_slist_alloc() -> *mut GSList;
    pub fn g_slist_free(list: *mut GSList);
    pub fn g_slist_free_1(list: *mut GSList);
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint)
     -> *mut GSList;
    pub fn g_slist_insert_sorted(list: *mut GSList, data: gpointer,
                                 func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_insert_sorted_with_data(list: *mut GSList, data: gpointer,
                                           func: GCompareDataFunc,
                                           user_data: gpointer)
     -> *mut GSList;
    pub fn g_slist_insert_before(slist: *mut GSList, sibling: *mut GSList,
                                 data: gpointer) -> *mut GSList;
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList)
     -> *mut GSList;
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer)
     -> *mut GSList;
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer)
     -> *mut GSList;
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList)
     -> *mut GSList;
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList)
     -> *mut GSList;
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy_deep(list: *mut GSList, func: GCopyFunc,
                             user_data: gpointer) -> *mut GSList;
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer)
     -> *mut GSList;
    pub fn g_slist_find_custom(list: *mut GSList, data: gconstpointer,
                               func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_length(list: *mut GSList) -> guint;
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc,
                           user_data: gpointer);
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc)
     -> *mut GSList;
    pub fn g_slist_sort_with_data(list: *mut GSList,
                                  compare_func: GCompareDataFunc,
                                  user_data: gpointer) -> *mut GSList;
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
    pub fn g_main_context_new() -> *mut GMainContext;
    pub fn g_main_context_ref(context: *mut GMainContext)
     -> *mut GMainContext;
    pub fn g_main_context_unref(context: *mut GMainContext);
    pub fn g_main_context_default() -> *mut GMainContext;
    pub fn g_main_context_iteration(context: *mut GMainContext,
                                    may_block: gboolean) -> gboolean;
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_find_source_by_id(context: *mut GMainContext,
                                            source_id: guint) -> *mut GSource;
    pub fn g_main_context_find_source_by_user_data(context: *mut GMainContext,
                                                   user_data: gpointer)
     -> *mut GSource;
    pub fn g_main_context_find_source_by_funcs_user_data(context:
                                                             *mut GMainContext,
                                                         funcs:
                                                             *mut GSourceFuncs,
                                                         user_data: gpointer)
     -> *mut GSource;
    pub fn g_main_context_wakeup(context: *mut GMainContext);
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_release(context: *mut GMainContext);
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_wait(context: *mut GMainContext, cond: *mut GCond,
                               mutex: *mut GMutex) -> gboolean;
    pub fn g_main_context_prepare(context: *mut GMainContext,
                                  priority: *mut gint) -> gboolean;
    pub fn g_main_context_query(context: *mut GMainContext,
                                max_priority: gint, timeout_: *mut gint,
                                fds: *mut GPollFD, n_fds: gint) -> gint;
    pub fn g_main_context_check(context: *mut GMainContext,
                                max_priority: gint, fds: *mut GPollFD,
                                n_fds: gint) -> gint;
    pub fn g_main_context_dispatch(context: *mut GMainContext);
    pub fn g_main_context_set_poll_func(context: *mut GMainContext,
                                        func: GPollFunc);
    pub fn g_main_context_get_poll_func(context: *mut GMainContext)
     -> GPollFunc;
    pub fn g_main_context_add_poll(context: *mut GMainContext,
                                   fd: *mut GPollFD, priority: gint);
    pub fn g_main_context_remove_poll(context: *mut GMainContext,
                                      fd: *mut GPollFD);
    pub fn g_main_depth() -> gint;
    pub fn g_main_current_source() -> *mut GSource;
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean)
     -> *mut GMainLoop;
    pub fn g_main_loop_run(_loop: *mut GMainLoop);
    pub fn g_main_loop_quit(_loop: *mut GMainLoop);
    pub fn g_main_loop_ref(_loop: *mut GMainLoop) -> *mut GMainLoop;
    pub fn g_main_loop_unref(_loop: *mut GMainLoop);
    pub fn g_main_loop_is_running(_loop: *mut GMainLoop) -> gboolean;
    pub fn g_main_loop_get_context(_loop: *mut GMainLoop)
     -> *mut GMainContext;
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint)
     -> *mut GSource;
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
    pub fn g_source_unref(source: *mut GSource);
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext)
     -> guint;
    pub fn g_source_destroy(source: *mut GSource);
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
    pub fn g_source_set_can_recurse(source: *mut GSource,
                                    can_recurse: gboolean);
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
    pub fn g_source_get_id(source: *mut GSource) -> guint;
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_set_callback(source: *mut GSource, func: GSourceFunc,
                                 data: gpointer, notify: GDestroyNotify);
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
    pub fn g_source_set_name(source: *mut GSource,
                             name: *const ::libc::c_char);
    pub fn g_source_get_name(source: *mut GSource) -> *const ::libc::c_char;
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::libc::c_char);
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint,
                                events: GIOCondition) -> gpointer;
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer,
                                   new_events: GIOCondition);
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer)
     -> GIOCondition;
    pub fn g_source_set_callback_indirect(source: *mut GSource,
                                          callback_data: gpointer,
                                          callback_funcs:
                                              *mut GSourceCallbackFuncs);
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_add_child_source(source: *mut GSource,
                                     child_source: *mut GSource);
    pub fn g_source_remove_child_source(source: *mut GSource,
                                        child_source: *mut GSource);
    pub fn g_source_get_current_time(source: *mut GSource,
                                     timeval: *mut GTimeVal);
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
    pub fn g_idle_source_new() -> *mut GSource;
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
    pub fn g_get_current_time(result: *mut GTimeVal);
    pub fn g_get_monotonic_time() -> gint64;
    pub fn g_get_real_time() -> gint64;
    pub fn g_source_remove(tag: guint) -> gboolean;
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
    pub fn g_source_remove_by_funcs_user_data(funcs: *mut GSourceFuncs,
                                              user_data: gpointer)
     -> gboolean;
    pub fn g_timeout_add_full(priority: gint, interval: guint,
                              function: GSourceFunc, data: gpointer,
                              notify: GDestroyNotify) -> guint;
    pub fn g_timeout_add(interval: guint, function: GSourceFunc,
                         data: gpointer) -> guint;
    pub fn g_timeout_add_seconds_full(priority: gint, interval: guint,
                                      function: GSourceFunc, data: gpointer,
                                      notify: GDestroyNotify) -> guint;
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc,
                                 data: gpointer) -> guint;
    pub fn g_child_watch_add_full(priority: gint, pid: GPid,
                                  function: GChildWatchFunc, data: gpointer,
                                  notify: GDestroyNotify) -> guint;
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc,
                             data: gpointer) -> guint;
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_idle_add_full(priority: gint, function: GSourceFunc,
                           data: gpointer, notify: GDestroyNotify) -> guint;
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
    pub fn g_main_context_invoke_full(context: *mut GMainContext,
                                      priority: gint, function: GSourceFunc,
                                      data: gpointer, notify: GDestroyNotify);
    pub fn g_main_context_invoke(context: *mut GMainContext,
                                 function: GSourceFunc, data: gpointer);
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
    pub fn g_unicode_script_from_iso15924(iso15924: guint32)
     -> GUnicodeScript;
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar)
     -> gboolean;
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar)
     -> gboolean;
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar,
                               b: *mut gunichar) -> gboolean;
    pub fn g_unichar_fully_decompose(ch: gunichar, compat: gboolean,
                                     result: *mut gunichar, result_len: gsize)
     -> gsize;
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
    pub fn g_unicode_canonical_decomposition(ch: gunichar,
                                             result_len: *mut gsize)
     -> *mut gunichar;
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize)
     -> gunichar;
    pub fn g_utf8_offset_to_pointer(str: *const gchar, offset: glong)
     -> *mut gchar;
    pub fn g_utf8_pointer_to_offset(str: *const gchar, pos: *const gchar)
     -> glong;
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar)
     -> *mut gchar;
    pub fn g_utf8_find_prev_char(str: *const gchar, p: *const gchar)
     -> *mut gchar;
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
    pub fn g_utf8_substring(str: *const gchar, start_pos: glong,
                            end_pos: glong) -> *mut gchar;
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize)
     -> *mut gchar;
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar)
     -> *mut gchar;
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar)
     -> *mut gchar;
    pub fn g_utf8_strreverse(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_to_utf16(str: *const gchar, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gunichar2;
    pub fn g_utf8_to_ucs4(str: *const gchar, len: glong,
                          items_read: *mut glong, items_written: *mut glong,
                          error: *mut *mut GError) -> *mut gunichar;
    pub fn g_utf8_to_ucs4_fast(str: *const gchar, len: glong,
                               items_written: *mut glong) -> *mut gunichar;
    pub fn g_utf16_to_ucs4(str: *const gunichar2, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gunichar;
    pub fn g_utf16_to_utf8(str: *const gunichar2, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gchar;
    pub fn g_ucs4_to_utf16(str: *const gunichar, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gunichar2;
    pub fn g_ucs4_to_utf8(str: *const gunichar, len: glong,
                          items_read: *mut glong, items_written: *mut glong,
                          error: *mut *mut GError) -> *mut gchar;
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
    pub fn g_utf8_validate(str: *const gchar, max_len: gssize,
                           end: *mut *const gchar) -> gboolean;
    pub fn g_utf8_strup(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_strdown(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_casefold(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_normalize(str: *const gchar, len: gssize,
                            mode: GNormalizeMode) -> *mut gchar;
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
    pub fn g_utf8_collate_key(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_collate_key_for_filename(str: *const gchar, len: gssize)
     -> *mut gchar;
    pub fn _g_utf8_make_valid(name: *const gchar) -> *mut gchar;
    pub fn g_get_user_name() -> *const gchar;
    pub fn g_get_real_name() -> *const gchar;
    pub fn g_get_home_dir() -> *const gchar;
    pub fn g_get_tmp_dir() -> *const gchar;
    pub fn g_get_host_name() -> *const gchar;
    pub fn g_get_prgname() -> *const gchar;
    pub fn g_set_prgname(prgname: *const gchar);
    pub fn g_get_application_name() -> *const gchar;
    pub fn g_set_application_name(application_name: *const gchar);
    pub fn g_reload_user_special_dirs_cache();
    pub fn g_get_user_data_dir() -> *const gchar;
    pub fn g_get_user_config_dir() -> *const gchar;
    pub fn g_get_user_cache_dir() -> *const gchar;
    pub fn g_get_system_data_dirs() -> *const *const gchar;
    pub fn g_get_system_config_dirs() -> *const *const gchar;
    pub fn g_get_user_runtime_dir() -> *const gchar;
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
    pub fn g_parse_debug_string(string: *const gchar, keys: *const GDebugKey,
                                nkeys: guint) -> guint;
    pub fn g_snprintf(string: *mut gchar, n: gulong,
                      format: *const gchar, ...) -> gint;
    pub fn g_vsnprintf(string: *mut gchar, n: gulong, format: *const gchar,
                       args: va_list) -> gint;
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags)
     -> *mut gchar;
    pub fn g_format_size(size: guint64) -> *mut gchar;
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
    pub fn g_atexit(func: GVoidFunc);
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
    pub fn g_string_new(init: *const gchar) -> *mut GString;
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
    pub fn g_string_free(string: *mut GString, free_segment: gboolean)
     -> *mut gchar;
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
    pub fn g_string_hash(str: *const GString) -> guint;
    pub fn g_string_assign(string: *mut GString, rval: *const gchar)
     -> *mut GString;
    pub fn g_string_truncate(string: *mut GString, len: gsize)
     -> *mut GString;
    pub fn g_string_set_size(string: *mut GString, len: gsize)
     -> *mut GString;
    pub fn g_string_insert_len(string: *mut GString, pos: gssize,
                               val: *const gchar, len: gssize)
     -> *mut GString;
    pub fn g_string_append(string: *mut GString, val: *const gchar)
     -> *mut GString;
    pub fn g_string_append_len(string: *mut GString, val: *const gchar,
                               len: gssize) -> *mut GString;
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar)
     -> *mut GString;
    pub fn g_string_prepend(string: *mut GString, val: *const gchar)
     -> *mut GString;
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar)
     -> *mut GString;
    pub fn g_string_prepend_len(string: *mut GString, val: *const gchar,
                                len: gssize) -> *mut GString;
    pub fn g_string_insert(string: *mut GString, pos: gssize,
                           val: *const gchar) -> *mut GString;
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar)
     -> *mut GString;
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize,
                                   wc: gunichar) -> *mut GString;
    pub fn g_string_overwrite(string: *mut GString, pos: gsize,
                              val: *const gchar) -> *mut GString;
    pub fn g_string_overwrite_len(string: *mut GString, pos: gsize,
                                  val: *const gchar, len: gssize)
     -> *mut GString;
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize)
     -> *mut GString;
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar,
                            args: va_list);
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
    pub fn g_string_append_vprintf(string: *mut GString, format: *const gchar,
                                   args: va_list);
    pub fn g_string_append_printf(string: *mut GString,
                                  format: *const gchar, ...);
    pub fn g_string_append_uri_escaped(string: *mut GString,
                                       unescaped: *const gchar,
                                       reserved_chars_allowed: *const gchar,
                                       allow_utf8: gboolean) -> *mut GString;
    pub fn g_string_down(string: *mut GString) -> *mut GString;
    pub fn g_string_up(string: *mut GString) -> *mut GString;
    pub fn g_io_channel_init(channel: *mut GIOChannel);
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
    pub fn g_io_channel_read(channel: *mut GIOChannel, buf: *mut gchar,
                             count: gsize, bytes_read: *mut gsize)
     -> GIOError;
    pub fn g_io_channel_write(channel: *mut GIOChannel, buf: *const gchar,
                              count: gsize, bytes_written: *mut gsize)
     -> GIOError;
    pub fn g_io_channel_seek(channel: *mut GIOChannel, offset: gint64,
                             _type: GSeekType) -> GIOError;
    pub fn g_io_channel_close(channel: *mut GIOChannel);
    pub fn g_io_channel_shutdown(channel: *mut GIOChannel, flush: gboolean,
                                 err: *mut *mut GError) -> GIOStatus;
    pub fn g_io_add_watch_full(channel: *mut GIOChannel, priority: gint,
                               condition: GIOCondition, func: GIOFunc,
                               user_data: gpointer, notify: GDestroyNotify)
     -> guint;
    pub fn g_io_create_watch(channel: *mut GIOChannel,
                             condition: GIOCondition) -> *mut GSource;
    pub fn g_io_add_watch(channel: *mut GIOChannel, condition: GIOCondition,
                          func: GIOFunc, user_data: gpointer) -> guint;
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel,
                                        size: gsize);
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel)
     -> GIOCondition;
    pub fn g_io_channel_set_flags(channel: *mut GIOChannel, flags: GIOFlags,
                                  error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
    pub fn g_io_channel_set_line_term(channel: *mut GIOChannel,
                                      line_term: *const gchar, length: gint);
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel,
                                      length: *mut gint) -> *const gchar;
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel,
                                     buffered: gboolean);
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_set_encoding(channel: *mut GIOChannel,
                                     encoding: *const gchar,
                                     error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel)
     -> *const gchar;
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel,
                                           do_close: gboolean);
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel)
     -> gboolean;
    pub fn g_io_channel_flush(channel: *mut GIOChannel,
                              error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line(channel: *mut GIOChannel,
                                  str_return: *mut *mut gchar,
                                  length: *mut gsize,
                                  terminator_pos: *mut gsize,
                                  error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line_string(channel: *mut GIOChannel,
                                         buffer: *mut GString,
                                         terminator_pos: *mut gsize,
                                         error: *mut *mut GError)
     -> GIOStatus;
    pub fn g_io_channel_read_to_end(channel: *mut GIOChannel,
                                    str_return: *mut *mut gchar,
                                    length: *mut gsize,
                                    error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_chars(channel: *mut GIOChannel, buf: *mut gchar,
                                   count: gsize, bytes_read: *mut gsize,
                                   error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_unichar(channel: *mut GIOChannel,
                                     thechar: *mut gunichar,
                                     error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_write_chars(channel: *mut GIOChannel,
                                    buf: *const gchar, count: gssize,
                                    bytes_written: *mut gsize,
                                    error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_write_unichar(channel: *mut GIOChannel,
                                      thechar: gunichar,
                                      error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_seek_position(channel: *mut GIOChannel,
                                      offset: gint64, _type: GSeekType,
                                      error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_new_file(filename: *const gchar, mode: *const gchar,
                                 error: *mut *mut GError) -> *mut GIOChannel;
    pub fn g_io_channel_error_quark() -> GQuark;
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
    pub fn g_io_channel_unix_new(fd: ::libc::c_int) -> *mut GIOChannel;
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
    pub fn g_key_file_error_quark() -> GQuark;
    pub fn g_key_file_new() -> *mut GKeyFile;
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
    pub fn g_key_file_free(key_file: *mut GKeyFile);
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile,
                                         separator: gchar);
    pub fn g_key_file_load_from_file(key_file: *mut GKeyFile,
                                     file: *const gchar, flags: GKeyFileFlags,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data(key_file: *mut GKeyFile,
                                     data: *const gchar, length: gsize,
                                     flags: GKeyFileFlags,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_dirs(key_file: *mut GKeyFile,
                                     file: *const gchar,
                                     search_dirs: *mut *const gchar,
                                     full_path: *mut *mut gchar,
                                     flags: GKeyFileFlags,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data_dirs(key_file: *mut GKeyFile,
                                          file: *const gchar,
                                          full_path: *mut *mut gchar,
                                          flags: GKeyFileFlags,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_key_file_to_data(key_file: *mut GKeyFile, length: *mut gsize,
                              error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_save_to_file(key_file: *mut GKeyFile,
                                   filename: *const gchar,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_key_file_get_keys(key_file: *mut GKeyFile,
                               group_name: *const gchar, length: *mut gsize,
                               error: *mut *mut GError) -> *mut *mut gchar;
    pub fn g_key_file_has_group(key_file: *mut GKeyFile,
                                group_name: *const gchar) -> gboolean;
    pub fn g_key_file_has_key(key_file: *mut GKeyFile,
                              group_name: *const gchar, key: *const gchar,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_value(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_set_value(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                value: *const gchar);
    pub fn g_key_file_get_string(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_set_string(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 string: *const gchar);
    pub fn g_key_file_get_locale_string(key_file: *mut GKeyFile,
                                        group_name: *const gchar,
                                        key: *const gchar,
                                        locale: *const gchar,
                                        error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_key_file_set_locale_string(key_file: *mut GKeyFile,
                                        group_name: *const gchar,
                                        key: *const gchar,
                                        locale: *const gchar,
                                        string: *const gchar);
    pub fn g_key_file_get_boolean(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_set_boolean(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  value: gboolean);
    pub fn g_key_file_get_integer(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  error: *mut *mut GError) -> gint;
    pub fn g_key_file_set_integer(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  value: gint);
    pub fn g_key_file_get_int64(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                error: *mut *mut GError) -> gint64;
    pub fn g_key_file_set_int64(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                value: gint64);
    pub fn g_key_file_get_uint64(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> guint64;
    pub fn g_key_file_set_uint64(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 value: guint64);
    pub fn g_key_file_get_double(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> gdouble;
    pub fn g_key_file_set_double(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 value: gdouble);
    pub fn g_key_file_get_string_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar, length: *mut gsize,
                                      error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_key_file_set_string_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar,
                                      list: *const *const gchar,
                                      length: gsize);
    pub fn g_key_file_get_locale_string_list(key_file: *mut GKeyFile,
                                             group_name: *const gchar,
                                             key: *const gchar,
                                             locale: *const gchar,
                                             length: *mut gsize,
                                             error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_key_file_set_locale_string_list(key_file: *mut GKeyFile,
                                             group_name: *const gchar,
                                             key: *const gchar,
                                             locale: *const gchar,
                                             list: *const *const gchar,
                                             length: gsize);
    pub fn g_key_file_get_boolean_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, length: *mut gsize,
                                       error: *mut *mut GError)
     -> *mut gboolean;
    pub fn g_key_file_set_boolean_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, list: *mut gboolean,
                                       length: gsize);
    pub fn g_key_file_get_integer_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, length: *mut gsize,
                                       error: *mut *mut GError) -> *mut gint;
    pub fn g_key_file_set_double_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar, list: *mut gdouble,
                                      length: gsize);
    pub fn g_key_file_get_double_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar, length: *mut gsize,
                                      error: *mut *mut GError)
     -> *mut gdouble;
    pub fn g_key_file_set_integer_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, list: *mut gint,
                                       length: gsize);
    pub fn g_key_file_set_comment(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  comment: *const gchar,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_comment(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_remove_comment(key_file: *mut GKeyFile,
                                     group_name: *const gchar,
                                     key: *const gchar,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_key(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_group(key_file: *mut GKeyFile,
                                   group_name: *const gchar,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_mapped_file_new(filename: *const gchar, writable: gboolean,
                             error: *mut *mut GError) -> *mut GMappedFile;
    pub fn g_mapped_file_new_from_fd(fd: gint, writable: gboolean,
                                     error: *mut *mut GError)
     -> *mut GMappedFile;
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
    pub fn g_mapped_file_free(file: *mut GMappedFile);
    pub fn g_markup_error_quark() -> GQuark;
    pub fn g_markup_parse_context_new(parser: *const GMarkupParser,
                                      flags: GMarkupParseFlags,
                                      user_data: gpointer,
                                      user_data_dnotify: GDestroyNotify)
     -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_ref(context: *mut GMarkupParseContext)
     -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_parse(context: *mut GMarkupParseContext,
                                        text: *const gchar, text_len: gssize,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_markup_parse_context_push(context: *mut GMarkupParseContext,
                                       parser: *const GMarkupParser,
                                       user_data: gpointer);
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext)
     -> gpointer;
    pub fn g_markup_parse_context_end_parse(context: *mut GMarkupParseContext,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn g_markup_parse_context_get_element(context:
                                                  *mut GMarkupParseContext)
     -> *const gchar;
    pub fn g_markup_parse_context_get_element_stack(context:
                                                        *mut GMarkupParseContext)
     -> *const GSList;
    pub fn g_markup_parse_context_get_position(context:
                                                   *mut GMarkupParseContext,
                                               line_number: *mut gint,
                                               char_number: *mut gint);
    pub fn g_markup_parse_context_get_user_data(context:
                                                    *mut GMarkupParseContext)
     -> gpointer;
    pub fn g_markup_escape_text(text: *const gchar, length: gssize)
     -> *mut gchar;
    pub fn g_markup_printf_escaped(format: *const ::libc::c_char, ...)
     -> *mut gchar;
    pub fn g_markup_vprintf_escaped(format: *const ::libc::c_char,
                                    args: va_list) -> *mut gchar;
    pub fn g_markup_collect_attributes(element_name: *const gchar,
                                       attribute_names: *mut *const gchar,
                                       attribute_values: *mut *const gchar,
                                       error: *mut *mut GError,
                                       first_type: GMarkupCollectType,
                                       first_attr: *const gchar, ...)
     -> gboolean;
    pub fn g_printf_string_upper_bound(format: *const gchar, args: va_list)
     -> gsize;
    pub fn g_log_set_handler(log_domain: *const gchar,
                             log_levels: GLogLevelFlags, log_func: GLogFunc,
                             user_data: gpointer) -> guint;
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
    pub fn g_log_default_handler(log_domain: *const gchar,
                                 log_level: GLogLevelFlags,
                                 message: *const gchar,
                                 unused_data: gpointer);
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer)
     -> GLogFunc;
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags,
                 format: *const gchar, ...);
    pub fn g_logv(log_domain: *const gchar, log_level: GLogLevelFlags,
                  format: *const gchar, args: va_list);
    pub fn g_log_set_fatal_mask(log_domain: *const gchar,
                                fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags)
     -> GLogLevelFlags;
    pub fn _g_log_fallback_handler(log_domain: *const gchar,
                                   log_level: GLogLevelFlags,
                                   message: *const gchar,
                                   unused_data: gpointer);
    pub fn g_return_if_fail_warning(log_domain: *const ::libc::c_char,
                                    pretty_function: *const ::libc::c_char,
                                    expression: *const ::libc::c_char);
    pub fn g_warn_message(domain: *const ::libc::c_char,
                          file: *const ::libc::c_char, line: ::libc::c_int,
                          func: *const ::libc::c_char,
                          warnexpr: *const ::libc::c_char);
    pub fn g_assert_warning(log_domain: *const ::libc::c_char,
                            file: *const ::libc::c_char, line: ::libc::c_int,
                            pretty_function: *const ::libc::c_char,
                            expression: *const ::libc::c_char);
    pub fn g_print(format: *const gchar, ...);
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_printerr(format: *const gchar, ...);
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_option_error_quark() -> GQuark;
    pub fn g_option_context_new(parameter_string: *const gchar)
     -> *mut GOptionContext;
    pub fn g_option_context_set_summary(context: *mut GOptionContext,
                                        summary: *const gchar);
    pub fn g_option_context_get_summary(context: *mut GOptionContext)
     -> *const gchar;
    pub fn g_option_context_set_description(context: *mut GOptionContext,
                                            description: *const gchar);
    pub fn g_option_context_get_description(context: *mut GOptionContext)
     -> *const gchar;
    pub fn g_option_context_free(context: *mut GOptionContext);
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext,
                                             help_enabled: gboolean);
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext)
     -> gboolean;
    pub fn g_option_context_set_ignore_unknown_options(context:
                                                           *mut GOptionContext,
                                                       ignore_unknown:
                                                           gboolean);
    pub fn g_option_context_get_ignore_unknown_options(context:
                                                           *mut GOptionContext)
     -> gboolean;
    pub fn g_option_context_add_main_entries(context: *mut GOptionContext,
                                             entries: *const GOptionEntry,
                                             translation_domain:
                                                 *const gchar);
    pub fn g_option_context_parse(context: *mut GOptionContext,
                                  argc: *mut gint, argv: *mut *mut *mut gchar,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_option_context_parse_strv(context: *mut GOptionContext,
                                       arguments: *mut *mut *mut gchar,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_option_context_set_translate_func(context: *mut GOptionContext,
                                               func: GTranslateFunc,
                                               data: gpointer,
                                               destroy_notify:
                                                   GDestroyNotify);
    pub fn g_option_context_set_translation_domain(context:
                                                       *mut GOptionContext,
                                                   domain: *const gchar);
    pub fn g_option_context_add_group(context: *mut GOptionContext,
                                      group: *mut GOptionGroup);
    pub fn g_option_context_set_main_group(context: *mut GOptionContext,
                                           group: *mut GOptionGroup);
    pub fn g_option_context_get_main_group(context: *mut GOptionContext)
     -> *mut GOptionGroup;
    pub fn g_option_context_get_help(context: *mut GOptionContext,
                                     main_help: gboolean,
                                     group: *mut GOptionGroup) -> *mut gchar;
    pub fn g_option_group_new(name: *const gchar, description: *const gchar,
                              help_description: *const gchar,
                              user_data: gpointer, destroy: GDestroyNotify)
     -> *mut GOptionGroup;
    pub fn g_option_group_set_parse_hooks(group: *mut GOptionGroup,
                                          pre_parse_func: GOptionParseFunc,
                                          post_parse_func: GOptionParseFunc);
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup,
                                         error_func: GOptionErrorFunc);
    pub fn g_option_group_free(group: *mut GOptionGroup);
    pub fn g_option_group_add_entries(group: *mut GOptionGroup,
                                      entries: *const GOptionEntry);
    pub fn g_option_group_set_translate_func(group: *mut GOptionGroup,
                                             func: GTranslateFunc,
                                             data: gpointer,
                                             destroy_notify: GDestroyNotify);
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup,
                                                 domain: *const gchar);
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec,
                                pspec2: *mut GPatternSpec) -> gboolean;
    pub fn g_pattern_match(pspec: *mut GPatternSpec, string_length: guint,
                           string: *const gchar,
                           string_reversed: *const gchar) -> gboolean;
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec,
                                  string: *const gchar) -> gboolean;
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar)
     -> gboolean;
    pub fn g_spaced_primes_closest(num: guint) -> guint;
    pub fn g_qsort_with_data(pbase: gconstpointer, total_elems: gint,
                             size: gsize, compare_func: GCompareDataFunc,
                             user_data: gpointer);
    pub fn g_queue_new() -> *mut GQueue;
    pub fn g_queue_free(queue: *mut GQueue);
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_init(queue: *mut GQueue);
    pub fn g_queue_clear(queue: *mut GQueue);
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
    pub fn g_queue_reverse(queue: *mut GQueue);
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc,
                           user_data: gpointer);
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer)
     -> *mut GList;
    pub fn g_queue_find_custom(queue: *mut GQueue, data: gconstpointer,
                               func: GCompareFunc) -> *mut GList;
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc,
                        user_data: gpointer);
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer)
     -> gboolean;
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer)
     -> guint;
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList,
                                 data: gpointer);
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList,
                                data: gpointer);
    pub fn g_queue_insert_sorted(queue: *mut GQueue, data: gpointer,
                                 func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint,
                                 link_: *mut GList);
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
    pub fn g_rand_new_with_seed_array(seed: *const guint32,
                                      seed_length: guint) -> *mut GRand;
    pub fn g_rand_new() -> *mut GRand;
    pub fn g_rand_free(rand_: *mut GRand);
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32,
                                 seed_length: guint);
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32)
     -> gint32;
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble,
                               end: gdouble) -> gdouble;
    pub fn g_random_set_seed(seed: guint32);
    pub fn g_random_int() -> guint32;
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
    pub fn g_random_double() -> gdouble;
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
    pub fn g_regex_error_quark() -> GQuark;
    pub fn g_regex_new(pattern: *const gchar,
                       compile_options: GRegexCompileFlags,
                       match_options: GRegexMatchFlags,
                       error: *mut *mut GError) -> *mut GRegex;
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
    pub fn g_regex_unref(regex: *mut GRegex);
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar)
     -> gint;
    pub fn g_regex_escape_string(string: *const gchar, length: gint)
     -> *mut gchar;
    pub fn g_regex_escape_nul(string: *const gchar, length: gint)
     -> *mut gchar;
    pub fn g_regex_get_compile_flags(regex: *const GRegex)
     -> GRegexCompileFlags;
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
    pub fn g_regex_match_simple(pattern: *const gchar, string: *const gchar,
                                compile_options: GRegexCompileFlags,
                                match_options: GRegexMatchFlags) -> gboolean;
    pub fn g_regex_match(regex: *const GRegex, string: *const gchar,
                         match_options: GRegexMatchFlags,
                         match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_full(regex: *const GRegex, string: *const gchar,
                              string_len: gssize, start_position: gint,
                              match_options: GRegexMatchFlags,
                              match_info: *mut *mut GMatchInfo,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_regex_match_all(regex: *const GRegex, string: *const gchar,
                             match_options: GRegexMatchFlags,
                             match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all_full(regex: *const GRegex, string: *const gchar,
                                  string_len: gssize, start_position: gint,
                                  match_options: GRegexMatchFlags,
                                  match_info: *mut *mut GMatchInfo,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_regex_split_simple(pattern: *const gchar, string: *const gchar,
                                compile_options: GRegexCompileFlags,
                                match_options: GRegexMatchFlags)
     -> *mut *mut gchar;
    pub fn g_regex_split(regex: *const GRegex, string: *const gchar,
                         match_options: GRegexMatchFlags) -> *mut *mut gchar;
    pub fn g_regex_split_full(regex: *const GRegex, string: *const gchar,
                              string_len: gssize, start_position: gint,
                              match_options: GRegexMatchFlags,
                              max_tokens: gint, error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_regex_replace(regex: *const GRegex, string: *const gchar,
                           string_len: gssize, start_position: gint,
                           replacement: *const gchar,
                           match_options: GRegexMatchFlags,
                           error: *mut *mut GError) -> *mut gchar;
    pub fn g_regex_replace_literal(regex: *const GRegex, string: *const gchar,
                                   string_len: gssize, start_position: gint,
                                   replacement: *const gchar,
                                   match_options: GRegexMatchFlags,
                                   error: *mut *mut GError) -> *mut gchar;
    pub fn g_regex_replace_eval(regex: *const GRegex, string: *const gchar,
                                string_len: gssize, start_position: gint,
                                match_options: GRegexMatchFlags,
                                eval: GRegexEvalCallback, user_data: gpointer,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_regex_check_replacement(replacement: *const gchar,
                                     has_references: *mut gboolean,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo)
     -> *mut GRegex;
    pub fn g_match_info_get_string(match_info: *const GMatchInfo)
     -> *const gchar;
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
    pub fn g_match_info_next(match_info: *mut GMatchInfo,
                             error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo)
     -> gint;
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo)
     -> gboolean;
    pub fn g_match_info_expand_references(match_info: *const GMatchInfo,
                                          string_to_expand: *const gchar,
                                          error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint)
     -> *mut gchar;
    pub fn g_match_info_fetch_pos(match_info: *const GMatchInfo,
                                  match_num: gint, start_pos: *mut gint,
                                  end_pos: *mut gint) -> gboolean;
    pub fn g_match_info_fetch_named(match_info: *const GMatchInfo,
                                    name: *const gchar) -> *mut gchar;
    pub fn g_match_info_fetch_named_pos(match_info: *const GMatchInfo,
                                        name: *const gchar,
                                        start_pos: *mut gint,
                                        end_pos: *mut gint) -> gboolean;
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo)
     -> *mut *mut gchar;
    pub fn g_scanner_new(config_templ: *const GScannerConfig)
     -> *mut GScanner;
    pub fn g_scanner_destroy(scanner: *mut GScanner);
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar,
                                text_len: guint);
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint)
     -> guint;
    pub fn g_scanner_scope_add_symbol(scanner: *mut GScanner, scope_id: guint,
                                      symbol: *const gchar, value: gpointer);
    pub fn g_scanner_scope_remove_symbol(scanner: *mut GScanner,
                                         scope_id: guint,
                                         symbol: *const gchar);
    pub fn g_scanner_scope_lookup_symbol(scanner: *mut GScanner,
                                         scope_id: guint,
                                         symbol: *const gchar) -> gpointer;
    pub fn g_scanner_scope_foreach_symbol(scanner: *mut GScanner,
                                          scope_id: guint, func: GHFunc,
                                          user_data: gpointer);
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner,
                                   symbol: *const gchar) -> gpointer;
    pub fn g_scanner_unexp_token(scanner: *mut GScanner,
                                 expected_token: GTokenType,
                                 identifier_spec: *const gchar,
                                 symbol_spec: *const gchar,
                                 symbol_name: *const gchar,
                                 message: *const gchar, is_error: gint);
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
    pub fn g_sequence_free(seq: *mut GSequence);
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc,
                              user_data: gpointer);
    pub fn g_sequence_foreach_range(begin: *mut GSequenceIter,
                                    end: *mut GSequenceIter, func: GFunc,
                                    user_data: gpointer);
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc,
                           cmp_data: gpointer);
    pub fn g_sequence_sort_iter(seq: *mut GSequence,
                                cmp_func: GSequenceIterCompareFunc,
                                cmp_data: gpointer);
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence)
     -> *mut GSequenceIter;
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint)
     -> *mut GSequenceIter;
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
    pub fn g_sequence_insert_sorted(seq: *mut GSequence, data: gpointer,
                                    cmp_func: GCompareDataFunc,
                                    cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted_iter(seq: *mut GSequence, data: gpointer,
                                         iter_cmp: GSequenceIterCompareFunc,
                                         cmp_data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_sort_changed(iter: *mut GSequenceIter,
                                   cmp_func: GCompareDataFunc,
                                   cmp_data: gpointer);
    pub fn g_sequence_sort_changed_iter(iter: *mut GSequenceIter,
                                        iter_cmp: GSequenceIterCompareFunc,
                                        cmp_data: gpointer);
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter,
                                   end: *mut GSequenceIter);
    pub fn g_sequence_move_range(dest: *mut GSequenceIter,
                                 begin: *mut GSequenceIter,
                                 end: *mut GSequenceIter);
    pub fn g_sequence_search(seq: *mut GSequence, data: gpointer,
                             cmp_func: GCompareDataFunc, cmp_data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_search_iter(seq: *mut GSequence, data: gpointer,
                                  iter_cmp: GSequenceIterCompareFunc,
                                  cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_lookup(seq: *mut GSequence, data: gpointer,
                             cmp_func: GCompareDataFunc, cmp_data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_lookup_iter(seq: *mut GSequence, data: gpointer,
                                  iter_cmp: GSequenceIterCompareFunc,
                                  cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter)
     -> *mut GSequenceIter;
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter)
     -> *mut GSequenceIter;
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint)
     -> *mut GSequenceIter;
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter)
     -> *mut GSequence;
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter,
                                   b: *mut GSequenceIter) -> gint;
    pub fn g_sequence_range_get_midpoint(begin: *mut GSequenceIter,
                                         end: *mut GSequenceIter)
     -> *mut GSequenceIter;
    pub fn g_shell_error_quark() -> GQuark;
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
    pub fn g_shell_unquote(quoted_string: *const gchar,
                           error: *mut *mut GError) -> *mut gchar;
    pub fn g_shell_parse_argv(command_line: *const gchar, argcp: *mut gint,
                              argvp: *mut *mut *mut gchar,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer)
     -> gpointer;
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
    pub fn g_slice_free_chain_with_offset(block_size: gsize,
                                          mem_chain: gpointer,
                                          next_offset: gsize);
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
    pub fn g_slice_get_config_state(ckey: GSliceConfig, address: gint64,
                                    n_values: *mut guint) -> *mut gint64;
    pub fn g_spawn_error_quark() -> GQuark;
    pub fn g_spawn_exit_error_quark() -> GQuark;
    pub fn g_spawn_async(working_directory: *const gchar,
                         argv: *mut *mut gchar, envp: *mut *mut gchar,
                         flags: GSpawnFlags,
                         child_setup: GSpawnChildSetupFunc,
                         user_data: gpointer, child_pid: *mut GPid,
                         error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_async_with_pipes(working_directory: *const gchar,
                                    argv: *mut *mut gchar,
                                    envp: *mut *mut gchar, flags: GSpawnFlags,
                                    child_setup: GSpawnChildSetupFunc,
                                    user_data: gpointer, child_pid: *mut GPid,
                                    standard_input: *mut gint,
                                    standard_output: *mut gint,
                                    standard_error: *mut gint,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_sync(working_directory: *const gchar,
                        argv: *mut *mut gchar, envp: *mut *mut gchar,
                        flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc,
                        user_data: gpointer, standard_output: *mut *mut gchar,
                        standard_error: *mut *mut gchar,
                        exit_status: *mut gint, error: *mut *mut GError)
     -> gboolean;
    pub fn g_spawn_command_line_sync(command_line: *const gchar,
                                     standard_output: *mut *mut gchar,
                                     standard_error: *mut *mut gchar,
                                     exit_status: *mut gint,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_command_line_async(command_line: *const gchar,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_check_exit_status(exit_status: gint,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_close_pid(pid: GPid);
    pub fn g_ascii_tolower(c: gchar) -> gchar;
    pub fn g_ascii_toupper(c: gchar) -> gchar;
    pub fn g_ascii_digit_value(c: gchar) -> gint;
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
    pub fn g_strdelimit(string: *mut gchar, delimiters: *const gchar,
                        new_delimiter: gchar) -> *mut gchar;
    pub fn g_strcanon(string: *mut gchar, valid_chars: *const gchar,
                      substitutor: gchar) -> *mut gchar;
    pub fn g_strerror(errnum: gint) -> *const gchar;
    pub fn g_strsignal(signum: gint) -> *const gchar;
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize)
     -> gsize;
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize)
     -> gsize;
    pub fn g_strstr_len(haystack: *const gchar, haystack_len: gssize,
                        needle: *const gchar) -> *mut gchar;
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar)
     -> *mut gchar;
    pub fn g_strrstr_len(haystack: *const gchar, haystack_len: gssize,
                         needle: *const gchar) -> *mut gchar;
    pub fn g_str_has_suffix(str: *const gchar, suffix: *const gchar)
     -> gboolean;
    pub fn g_str_has_prefix(str: *const gchar, prefix: *const gchar)
     -> gboolean;
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar)
     -> gdouble;
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar,
                            base: guint) -> guint64;
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar,
                           base: guint) -> gint64;
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble)
     -> *mut gchar;
    pub fn g_ascii_formatd(buffer: *mut gchar, buf_len: gint,
                           format: *const gchar, d: gdouble) -> *mut gchar;
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize)
     -> gint;
    pub fn g_ascii_strdown(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_ascii_strup(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_str_is_ascii(str: *const gchar) -> gboolean;
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint)
     -> gint;
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
    pub fn g_strdup(str: *const gchar) -> *mut gchar;
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
    pub fn g_strdup_vprintf(format: *const gchar, args: va_list)
     -> *mut gchar;
    pub fn g_strndup(str: *const gchar, n: gsize) -> *mut gchar;
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar)
     -> *mut gchar;
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
    pub fn g_strsplit(string: *const gchar, delimiter: *const gchar,
                      max_tokens: gint) -> *mut *mut gchar;
    pub fn g_strsplit_set(string: *const gchar, delimiters: *const gchar,
                          max_tokens: gint) -> *mut *mut gchar;
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar)
     -> *mut gchar;
    pub fn g_strfreev(str_array: *mut *mut gchar);
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::libc::c_char)
     -> *mut gchar;
    pub fn g_str_to_ascii(str: *const gchar, from_locale: *const gchar)
     -> *mut gchar;
    pub fn g_str_tokenize_and_fold(string: *const gchar,
                                   translit_locale: *const gchar,
                                   ascii_alternates: *mut *mut *mut gchar)
     -> *mut *mut gchar;
    pub fn g_str_match_string(search_term: *const gchar,
                              potential_hit: *const gchar,
                              accept_alternates: gboolean) -> gboolean;
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk,
                                 string: *const gchar) -> *mut gchar;
    pub fn g_string_chunk_insert_len(chunk: *mut GStringChunk,
                                     string: *const gchar, len: gssize)
     -> *mut gchar;
    pub fn g_string_chunk_insert_const(chunk: *mut GStringChunk,
                                       string: *const gchar) -> *mut gchar;
    pub fn g_strcmp0(str1: *const ::libc::c_char, str2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn g_test_minimized_result(minimized_quantity: ::libc::c_double,
                                   format: *const ::libc::c_char, ...);
    pub fn g_test_maximized_result(maximized_quantity: ::libc::c_double,
                                   format: *const ::libc::c_char, ...);
    pub fn g_test_init(argc: *mut ::libc::c_int,
                       argv: *mut *mut *mut ::libc::c_char, ...);
    pub fn g_test_subprocess() -> gboolean;
    pub fn g_test_run() -> ::libc::c_int;
    pub fn g_test_add_func(testpath: *const ::libc::c_char,
                           test_func: GTestFunc);
    pub fn g_test_add_data_func(testpath: *const ::libc::c_char,
                                test_data: gconstpointer,
                                test_func: GTestDataFunc);
    pub fn g_test_add_data_func_full(testpath: *const ::libc::c_char,
                                     test_data: gpointer,
                                     test_func: GTestDataFunc,
                                     data_free_func: GDestroyNotify);
    pub fn g_test_fail();
    pub fn g_test_incomplete(msg: *const gchar);
    pub fn g_test_skip(msg: *const gchar);
    pub fn g_test_failed() -> gboolean;
    pub fn g_test_set_nonfatal_assertions();
    pub fn g_test_message(format: *const ::libc::c_char, ...);
    pub fn g_test_bug_base(uri_pattern: *const ::libc::c_char);
    pub fn g_test_bug(bug_uri_snippet: *const ::libc::c_char);
    pub fn g_test_timer_start();
    pub fn g_test_timer_elapsed() -> ::libc::c_double;
    pub fn g_test_timer_last() -> ::libc::c_double;
    pub fn g_test_queue_free(gfree_pointer: gpointer);
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify,
                                destroy_data: gpointer);
    pub fn g_test_trap_fork(usec_timeout: guint64,
                            test_trap_flags: GTestTrapFlags) -> gboolean;
    pub fn g_test_trap_subprocess(test_path: *const ::libc::c_char,
                                  usec_timeout: guint64,
                                  test_flags: GTestSubprocessFlags);
    pub fn g_test_trap_has_passed() -> gboolean;
    pub fn g_test_trap_reached_timeout() -> gboolean;
    pub fn g_test_rand_int() -> gint32;
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
    pub fn g_test_rand_double() -> ::libc::c_double;
    pub fn g_test_rand_double_range(range_start: ::libc::c_double,
                                    range_end: ::libc::c_double)
     -> ::libc::c_double;
    pub fn g_test_create_case(test_name: *const ::libc::c_char,
                              data_size: gsize, test_data: gconstpointer,
                              data_setup: GTestFixtureFunc,
                              data_test: GTestFixtureFunc,
                              data_teardown: GTestFixtureFunc)
     -> *mut GTestCase;
    pub fn g_test_create_suite(suite_name: *const ::libc::c_char)
     -> *mut GTestSuite;
    pub fn g_test_get_root() -> *mut GTestSuite;
    pub fn g_test_suite_add(suite: *mut GTestSuite,
                            test_case: *mut GTestCase);
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite,
                                  nestedsuite: *mut GTestSuite);
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::libc::c_int;
    pub fn g_test_trap_assertions(domain: *const ::libc::c_char,
                                  file: *const ::libc::c_char,
                                  line: ::libc::c_int,
                                  func: *const ::libc::c_char,
                                  assertion_flags: guint64,
                                  pattern: *const ::libc::c_char);
    pub fn g_assertion_message(domain: *const ::libc::c_char,
                               file: *const ::libc::c_char,
                               line: ::libc::c_int,
                               func: *const ::libc::c_char,
                               message: *const ::libc::c_char);
    pub fn g_assertion_message_expr(domain: *const ::libc::c_char,
                                    file: *const ::libc::c_char,
                                    line: ::libc::c_int,
                                    func: *const ::libc::c_char,
                                    expr: *const ::libc::c_char);
    pub fn g_assertion_message_cmpstr(domain: *const ::libc::c_char,
                                      file: *const ::libc::c_char,
                                      line: ::libc::c_int,
                                      func: *const ::libc::c_char,
                                      expr: *const ::libc::c_char,
                                      arg1: *const ::libc::c_char,
                                      cmp: *const ::libc::c_char,
                                      arg2: *const ::libc::c_char);
    pub fn g_assertion_message_cmpnum(domain: *const ::libc::c_char,
                                      file: *const ::libc::c_char,
                                      line: ::libc::c_int,
                                      func: *const ::libc::c_char,
                                      expr: *const ::libc::c_char,
                                      arg1: ::libc::c_double,
                                      cmp: *const ::libc::c_char,
                                      arg2: ::libc::c_double,
                                      numtype: ::libc::c_char);
    pub fn g_assertion_message_error(domain: *const ::libc::c_char,
                                     file: *const ::libc::c_char,
                                     line: ::libc::c_int,
                                     func: *const ::libc::c_char,
                                     expr: *const ::libc::c_char,
                                     error: *const GError,
                                     error_domain: GQuark,
                                     error_code: ::libc::c_int);
    pub fn g_test_add_vtable(testpath: *const ::libc::c_char,
                             data_size: gsize, test_data: gconstpointer,
                             data_setup: GTestFixtureFunc,
                             data_test: GTestFixtureFunc,
                             data_teardown: GTestFixtureFunc);
    pub fn g_test_log_type_name(log_type: GTestLogType)
     -> *const ::libc::c_char;
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
    pub fn g_test_log_buffer_push(tbuffer: *mut GTestLogBuffer,
                                  n_bytes: guint, bytes: *const guint8);
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer)
     -> *mut GTestLogMsg;
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc,
                                        user_data: gpointer);
    pub fn g_test_expect_message(log_domain: *const gchar,
                                 log_level: GLogLevelFlags,
                                 pattern: *const gchar);
    pub fn g_test_assert_expected_messages_internal(domain:
                                                        *const ::libc::c_char,
                                                    file:
                                                        *const ::libc::c_char,
                                                    line: ::libc::c_int,
                                                    func:
                                                        *const ::libc::c_char);
    pub fn g_test_build_filename(file_type: GTestFileType,
                                 first_path: *const gchar, ...) -> *mut gchar;
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
    pub fn g_test_get_filename(file_type: GTestFileType,
                               first_path: *const gchar, ...) -> *const gchar;
    pub fn g_thread_pool_new(func: GFunc, user_data: gpointer,
                             max_threads: gint, exclusive: gboolean,
                             error: *mut *mut GError) -> *mut GThreadPool;
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean,
                              wait_: gboolean);
    pub fn g_thread_pool_push(pool: *mut GThreadPool, data: gpointer,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_pool_set_sort_function(pool: *mut GThreadPool,
                                           func: GCompareDataFunc,
                                           user_data: gpointer);
    pub fn g_thread_pool_set_max_threads(pool: *mut GThreadPool,
                                         max_threads: gint,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
    pub fn g_thread_pool_stop_unused_threads();
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
    pub fn g_thread_pool_get_max_idle_time() -> guint;
    pub fn g_timer_new() -> *mut GTimer;
    pub fn g_timer_destroy(timer: *mut GTimer);
    pub fn g_timer_start(timer: *mut GTimer);
    pub fn g_timer_stop(timer: *mut GTimer);
    pub fn g_timer_reset(timer: *mut GTimer);
    pub fn g_timer_continue(timer: *mut GTimer);
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong)
     -> gdouble;
    pub fn g_usleep(microseconds: gulong);
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
    pub fn g_time_val_from_iso8601(iso_date: *const gchar,
                                   time_: *mut GTimeVal) -> gboolean;
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
    pub fn g_tree_new_with_data(key_compare_func: GCompareDataFunc,
                                key_compare_data: gpointer) -> *mut GTree;
    pub fn g_tree_new_full(key_compare_func: GCompareDataFunc,
                           key_compare_data: gpointer,
                           key_destroy_func: GDestroyNotify,
                           value_destroy_func: GDestroyNotify) -> *mut GTree;
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
    pub fn g_tree_unref(tree: *mut GTree);
    pub fn g_tree_destroy(tree: *mut GTree);
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
    pub fn g_tree_lookup_extended(tree: *mut GTree, lookup_key: gconstpointer,
                                  orig_key: *mut gpointer,
                                  value: *mut gpointer) -> gboolean;
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc,
                          user_data: gpointer);
    pub fn g_tree_traverse(tree: *mut GTree, traverse_func: GTraverseFunc,
                           traverse_type: GTraverseType, user_data: gpointer);
    pub fn g_tree_search(tree: *mut GTree, search_func: GCompareFunc,
                         user_data: gconstpointer) -> gpointer;
    pub fn g_tree_height(tree: *mut GTree) -> gint;
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
    pub fn g_uri_unescape_string(escaped_string: *const ::libc::c_char,
                                 illegal_characters: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn g_uri_unescape_segment(escaped_string: *const ::libc::c_char,
                                  escaped_string_end: *const ::libc::c_char,
                                  illegal_characters: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn g_uri_parse_scheme(uri: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn g_uri_escape_string(unescaped: *const ::libc::c_char,
                               reserved_chars_allowed: *const ::libc::c_char,
                               allow_utf8: gboolean) -> *mut ::libc::c_char;
    pub fn g_variant_type_string_is_valid(type_string: *const gchar)
     -> gboolean;
    pub fn g_variant_type_string_scan(string: *const gchar,
                                      limit: *const gchar,
                                      endptr: *mut *const gchar) -> gboolean;
    pub fn g_variant_type_free(_type: *mut GVariantType);
    pub fn g_variant_type_copy(_type: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
    pub fn g_variant_type_get_string_length(_type: *const GVariantType)
     -> gsize;
    pub fn g_variant_type_peek_string(_type: *const GVariantType)
     -> *const gchar;
    pub fn g_variant_type_dup_string(_type: *const GVariantType)
     -> *mut gchar;
    pub fn g_variant_type_is_definite(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_container(_type: *const GVariantType)
     -> gboolean;
    pub fn g_variant_type_is_basic(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_maybe(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_array(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_tuple(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_dict_entry(_type: *const GVariantType)
     -> gboolean;
    pub fn g_variant_type_is_variant(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_hash(_type: gconstpointer) -> guint;
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer)
     -> gboolean;
    pub fn g_variant_type_is_subtype_of(_type: *const GVariantType,
                                        supertype: *const GVariantType)
     -> gboolean;
    pub fn g_variant_type_element(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_first(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_next(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_n_items(_type: *const GVariantType) -> gsize;
    pub fn g_variant_type_key(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_value(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_new_array(element: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_new_maybe(element: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_new_tuple(items: *const *const GVariantType,
                                    length: gint) -> *mut GVariantType;
    pub fn g_variant_type_new_dict_entry(key: *const GVariantType,
                                         value: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
    pub fn g_variant_unref(value: *mut GVariant);
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
    pub fn g_variant_is_of_type(value: *mut GVariant,
                                _type: *const GVariantType) -> gboolean;
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
    pub fn g_variant_new_byte(value: guchar) -> *mut GVariant;
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
    pub fn g_variant_new_printf(format_string: *const gchar, ...)
     -> *mut GVariant;
    pub fn g_variant_new_object_path(object_path: *const gchar)
     -> *mut GVariant;
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize)
     -> *mut GVariant;
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize)
     -> *mut GVariant;
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_bytestring_array(strv: *const *const gchar,
                                          length: gssize) -> *mut GVariant;
    pub fn g_variant_new_fixed_array(element_type: *const GVariantType,
                                     elements: gconstpointer,
                                     n_elements: gsize, element_size: gsize)
     -> *mut GVariant;
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
    pub fn g_variant_get_byte(value: *mut GVariant) -> guchar;
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize)
     -> *const gchar;
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize)
     -> *mut gchar;
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize)
     -> *mut *const gchar;
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize)
     -> *mut *const gchar;
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize)
     -> *mut gchar;
    pub fn g_variant_get_bytestring_array(value: *mut GVariant,
                                          length: *mut gsize)
     -> *mut *const gchar;
    pub fn g_variant_dup_bytestring_array(value: *mut GVariant,
                                          length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_variant_new_maybe(child_type: *const GVariantType,
                               child: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_array(child_type: *const GVariantType,
                               children: *const *mut GVariant,
                               n_children: gsize) -> *mut GVariant;
    pub fn g_variant_new_tuple(children: *const *mut GVariant,
                               n_children: gsize) -> *mut GVariant;
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant)
     -> *mut GVariant;
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
    pub fn g_variant_get_child(value: *mut GVariant, index_: gsize,
                               format_string: *const gchar, ...);
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize)
     -> *mut GVariant;
    pub fn g_variant_lookup(dictionary: *mut GVariant, key: *const gchar,
                            format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_lookup_value(dictionary: *mut GVariant,
                                  key: *const gchar,
                                  expected_type: *const GVariantType)
     -> *mut GVariant;
    pub fn g_variant_get_fixed_array(value: *mut GVariant,
                                     n_elements: *mut gsize,
                                     element_size: gsize) -> gconstpointer;
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean)
     -> *mut gchar;
    pub fn g_variant_print_string(value: *mut GVariant, string: *mut GString,
                                  type_annotate: gboolean) -> *mut GString;
    pub fn g_variant_hash(value: gconstpointer) -> guint;
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer)
     -> gboolean;
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_from_bytes(_type: *const GVariantType,
                                    bytes: *mut GBytes, trusted: gboolean)
     -> *mut GVariant;
    pub fn g_variant_new_from_data(_type: *const GVariantType,
                                   data: gconstpointer, size: gsize,
                                   trusted: gboolean, notify: GDestroyNotify,
                                   user_data: gpointer) -> *mut GVariant;
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant)
     -> gsize;
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter)
     -> *mut GVariant;
    pub fn g_variant_iter_next(iter: *mut GVariantIter,
                               format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_iter_loop(iter: *mut GVariantIter,
                               format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_parser_get_error_quark() -> GQuark;
    pub fn g_variant_parse_error_quark() -> GQuark;
    pub fn g_variant_builder_new(_type: *const GVariantType)
     -> *mut GVariantBuilder;
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder)
     -> *mut GVariantBuilder;
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder,
                                  _type: *const GVariantType);
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder)
     -> *mut GVariant;
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder,
                                  _type: *const GVariantType);
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder,
                                       value: *mut GVariant);
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder,
                                 format_string: *const gchar, ...);
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder,
                                        format: *const gchar, ...);
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_get(value: *mut GVariant,
                         format_string: *const gchar, ...);
    pub fn g_variant_new_va(format_string: *const gchar,
                            endptr: *mut *const gchar, app: *mut va_list)
     -> *mut GVariant;
    pub fn g_variant_get_va(value: *mut GVariant, format_string: *const gchar,
                            endptr: *mut *const gchar, app: *mut va_list);
    pub fn g_variant_check_format_string(value: *mut GVariant,
                                         format_string: *const gchar,
                                         copy_only: gboolean) -> gboolean;
    pub fn g_variant_parse(_type: *const GVariantType, text: *const gchar,
                           limit: *const gchar, endptr: *mut *const gchar,
                           error: *mut *mut GError) -> *mut GVariant;
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list)
     -> *mut GVariant;
    pub fn g_variant_parse_error_print_context(error: *mut GError,
                                               source_str: *const gchar)
     -> *mut gchar;
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
    pub fn g_variant_dict_init(dict: *mut GVariantDict,
                               from_asv: *mut GVariant);
    pub fn g_variant_dict_lookup(dict: *mut GVariantDict, key: *const gchar,
                                 format_string: *const gchar, ...)
     -> gboolean;
    pub fn g_variant_dict_lookup_value(dict: *mut GVariantDict,
                                       key: *const gchar,
                                       expected_type: *const GVariantType)
     -> *mut GVariant;
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar)
     -> gboolean;
    pub fn g_variant_dict_insert(dict: *mut GVariantDict, key: *const gchar,
                                 format_string: *const gchar, ...);
    pub fn g_variant_dict_insert_value(dict: *mut GVariantDict,
                                       key: *const gchar,
                                       value: *mut GVariant);
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar)
     -> gboolean;
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
    pub fn glib_check_version(required_major: guint, required_minor: guint,
                              required_micro: guint) -> *const gchar;
    pub fn g_mem_chunk_new(name: *const gchar, atom_size: gint,
                           area_size: gsize, _type: gint) -> *mut GMemChunk;
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_info();
    pub fn g_blow_chunks();
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint)
     -> *mut GAllocator;
    pub fn g_allocator_free(allocator: *mut GAllocator);
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
    pub fn g_list_pop_allocator();
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
    pub fn g_slist_pop_allocator();
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
    pub fn g_node_pop_allocator();
    pub fn g_cache_new(value_new_func: GCacheNewFunc,
                       value_destroy_func: GCacheDestroyFunc,
                       key_dup_func: GCacheDupFunc,
                       key_destroy_func: GCacheDestroyFunc,
                       hash_key_func: GHashFunc, hash_value_func: GHashFunc,
                       key_equal_func: GEqualFunc) -> *mut GCache;
    pub fn g_cache_destroy(cache: *mut GCache);
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc,
                               user_data: gpointer);
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc,
                                 user_data: gpointer);
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
    pub fn g_completion_remove_items(cmp: *mut GCompletion,
                                     items: *mut GList);
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
    pub fn g_completion_complete(cmp: *mut GCompletion, prefix: *const gchar,
                                 new_prefix: *mut *mut gchar) -> *mut GList;
    pub fn g_completion_complete_utf8(cmp: *mut GCompletion,
                                      prefix: *const gchar,
                                      new_prefix: *mut *mut gchar)
     -> *mut GList;
    pub fn g_completion_set_compare(cmp: *mut GCompletion,
                                    strncmp_func: GCompletionStrncmpFunc);
    pub fn g_completion_free(cmp: *mut GCompletion);
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
    pub fn g_relation_destroy(relation: *mut GRelation);
    pub fn g_relation_index(relation: *mut GRelation, field: gint,
                            hash_func: GHashFunc, key_equal_func: GEqualFunc);
    pub fn g_relation_insert(relation: *mut GRelation, ...);
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer,
                             field: gint) -> gint;
    pub fn g_relation_select(relation: *mut GRelation, key: gconstpointer,
                             field: gint) -> *mut GTuples;
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer,
                            field: gint) -> gint;
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
    pub fn g_relation_print(relation: *mut GRelation);
    pub fn g_tuples_destroy(tuples: *mut GTuples);
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint)
     -> gpointer;
    pub fn g_thread_create(func: GThreadFunc, data: gpointer,
                           joinable: gboolean, error: *mut *mut GError)
     -> *mut GThread;
    pub fn g_thread_create_full(func: GThreadFunc, data: gpointer,
                                stack_size: gulong, joinable: gboolean,
                                bound: gboolean, priority: GThreadPriority,
                                error: *mut *mut GError) -> *mut GThread;
    pub fn g_thread_set_priority(thread: *mut GThread,
                                 priority: GThreadPriority);
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
    pub fn select(__nfds: ::libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> ::libc::c_int;
    pub fn pselect(__nfds: ::libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const Struct_timespec,
                   __sigmask: *const __sigset_t) -> ::libc::c_int;
    pub fn gnu_dev_major(__dev: ::libc::c_ulonglong) -> ::libc::c_uint;
    pub fn gnu_dev_minor(__dev: ::libc::c_ulonglong) -> ::libc::c_uint;
    pub fn gnu_dev_makedev(__major: ::libc::c_uint, __minor: ::libc::c_uint)
     -> ::libc::c_ulonglong;
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t)
     -> ::libc::c_int;
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
    pub fn sched_setparam(__pid: __pid_t, __param: *const Struct_sched_param)
     -> ::libc::c_int;
    pub fn sched_getparam(__pid: __pid_t, __param: *mut Struct_sched_param)
     -> ::libc::c_int;
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::libc::c_int,
                              __param: *const Struct_sched_param)
     -> ::libc::c_int;
    pub fn sched_getscheduler(__pid: __pid_t) -> ::libc::c_int;
    pub fn sched_yield() -> ::libc::c_int;
    pub fn sched_get_priority_max(__algorithm: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sched_get_priority_min(__algorithm: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut Struct_timespec)
     -> ::libc::c_int;
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                              ::std::option::Option<extern "C" fn
                                                        (arg1:
                                                             *mut ::libc::c_void)
                                                        ->
                                                            *mut ::libc::c_void>,
                          __arg: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn pthread_exit(__retval: *mut ::libc::c_void);
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut ::libc::c_void)
     -> ::libc::c_int;
    pub fn pthread_detach(__th: pthread_t) -> ::libc::c_int;
    pub fn pthread_self() -> pthread_t;
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> ::libc::c_int;
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::libc::c_int;
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::libc::c_int;
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut size_t)
     -> ::libc::c_int;
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: size_t) -> ::libc::c_int;
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut Struct_sched_param)
     -> ::libc::c_int;
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const Struct_sched_param)
     -> ::libc::c_int;
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: ::libc::c_int) -> ::libc::c_int;
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr: *mut *mut ::libc::c_void)
     -> ::libc::c_int;
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut ::libc::c_void)
     -> ::libc::c_int;
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut size_t)
     -> ::libc::c_int;
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: size_t) -> ::libc::c_int;
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr: *mut *mut ::libc::c_void,
                                 __stacksize: *mut size_t) -> ::libc::c_int;
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut ::libc::c_void,
                                 __stacksize: size_t) -> ::libc::c_int;
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: ::libc::c_int,
                                 __param: *const Struct_sched_param)
     -> ::libc::c_int;
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut ::libc::c_int,
                                 __param: *mut Struct_sched_param)
     -> ::libc::c_int;
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: ::libc::c_int) -> ::libc::c_int;
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<extern "C" fn()>)
     -> ::libc::c_int;
    pub fn pthread_setcancelstate(__state: ::libc::c_int,
                                  __oldstate: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_setcanceltype(__type: ::libc::c_int,
                                 __oldtype: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_cancel(__th: pthread_t) -> ::libc::c_int;
    pub fn pthread_testcancel();
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
    pub fn __sigsetjmp(__env: *mut Struct___jmp_buf_tag,
                       __savemask: ::libc::c_int) -> ::libc::c_int;
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
     -> ::libc::c_int;
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
     -> ::libc::c_int;
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
     -> ::libc::c_int;
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::libc::c_int;
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const Struct_timespec)
     -> ::libc::c_int;
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t)
     -> ::libc::c_int;
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: ::libc::c_int,
                                        __old_ceiling: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: ::libc::c_int) -> ::libc::c_int;
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                                *const pthread_mutexattr_t,
                                            __prioceiling: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
     -> ::libc::c_int;
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
     -> ::libc::c_int;
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::libc::c_int;
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::libc::c_int;
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const Struct_timespec)
     -> ::libc::c_int;
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::libc::c_int;
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::libc::c_int;
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const Struct_timespec)
     -> ::libc::c_int;
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
     -> ::libc::c_int;
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
     -> ::libc::c_int;
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
     -> ::libc::c_int;
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
     -> ::libc::c_int;
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::libc::c_int;
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::libc::c_int;
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t)
     -> ::libc::c_int;
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t) -> ::libc::c_int;
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const Struct_timespec)
     -> ::libc::c_int;
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
     -> ::libc::c_int;
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
     -> ::libc::c_int;
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
     -> ::libc::c_int;
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t)
     -> ::libc::c_int;
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: ::libc::c_int) -> ::libc::c_int;
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> ::libc::c_int;
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t)
     -> ::libc::c_int;
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> ::libc::c_int;
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> ::libc::c_int;
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: ::libc::c_uint) -> ::libc::c_int;
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
     -> ::libc::c_int;
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
     -> ::libc::c_int;
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
     -> ::libc::c_int;
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
     -> ::libc::c_int;
    pub fn pthread_barrierattr_getpshared(__attr:
                                              *const pthread_barrierattr_t,
                                          __pshared: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<extern "C" fn
                                                            (arg1:
                                                                 *mut ::libc::c_void)>)
     -> ::libc::c_int;
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::libc::c_int;
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::libc::c_void;
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const ::libc::c_void)
     -> ::libc::c_int;
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t)
     -> ::libc::c_int;
    pub fn pthread_atfork(__prepare: ::std::option::Option<extern "C" fn()>,
                          __parent: ::std::option::Option<extern "C" fn()>,
                          __child: ::std::option::Option<extern "C" fn()>)
     -> ::libc::c_int;
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex)
     -> *mut GMutex;
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex)
     -> gboolean;
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex,
                                        depth: guint);
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex)
     -> guint;
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock)
     -> gboolean;
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock)
     -> gboolean;
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
    pub fn g_static_private_set(private_key: *mut GStaticPrivate,
                                data: gpointer, notify: GDestroyNotify);
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
    pub fn g_thread_init(vtable: gpointer);
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
    pub fn g_thread_get_initialized() -> gboolean;
    pub fn g_mutex_new() -> *mut GMutex;
    pub fn g_mutex_free(mutex: *mut GMutex);
    pub fn g_cond_new() -> *mut GCond;
    pub fn g_cond_free(cond: *mut GCond);
    pub fn g_cond_timed_wait(cond: *mut GCond, mutex: *mut GMutex,
                             timeval: *mut GTimeVal) -> gboolean;
    pub fn g_type_init();
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
    pub fn g_type_name(_type: GType) -> *const gchar;
    pub fn g_type_qname(_type: GType) -> GQuark;
    pub fn g_type_from_name(name: *const gchar) -> GType;
    pub fn g_type_parent(_type: GType) -> GType;
    pub fn g_type_depth(_type: GType) -> guint;
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
    pub fn g_type_is_a(_type: GType, is_a_type: GType) -> gboolean;
    pub fn g_type_class_ref(_type: GType) -> gpointer;
    pub fn g_type_class_peek(_type: GType) -> gpointer;
    pub fn g_type_class_peek_static(_type: GType) -> gpointer;
    pub fn g_type_class_unref(g_class: gpointer);
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType)
     -> gpointer;
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_unref(g_iface: gpointer);
    pub fn g_type_children(_type: GType, n_children: *mut guint)
     -> *mut GType;
    pub fn g_type_interfaces(_type: GType, n_interfaces: *mut guint)
     -> *mut GType;
    pub fn g_type_set_qdata(_type: GType, quark: GQuark, data: gpointer);
    pub fn g_type_get_qdata(_type: GType, quark: GQuark) -> gpointer;
    pub fn g_type_query(_type: GType, query: *mut GTypeQuery);
    pub fn g_type_register_static(parent_type: GType, type_name: *const gchar,
                                  info: *const GTypeInfo, flags: GTypeFlags)
     -> GType;
    pub fn g_type_register_static_simple(parent_type: GType,
                                         type_name: *const gchar,
                                         class_size: guint,
                                         class_init: GClassInitFunc,
                                         instance_size: guint,
                                         instance_init: GInstanceInitFunc,
                                         flags: GTypeFlags) -> GType;
    pub fn g_type_register_dynamic(parent_type: GType,
                                   type_name: *const gchar,
                                   plugin: *mut GTypePlugin,
                                   flags: GTypeFlags) -> GType;
    pub fn g_type_register_fundamental(type_id: GType,
                                       type_name: *const gchar,
                                       info: *const GTypeInfo,
                                       finfo: *const GTypeFundamentalInfo,
                                       flags: GTypeFlags) -> GType;
    pub fn g_type_add_interface_static(instance_type: GType,
                                       interface_type: GType,
                                       info: *const GInterfaceInfo);
    pub fn g_type_add_interface_dynamic(instance_type: GType,
                                        interface_type: GType,
                                        plugin: *mut GTypePlugin);
    pub fn g_type_interface_add_prerequisite(interface_type: GType,
                                             prerequisite_type: GType);
    pub fn g_type_interface_prerequisites(interface_type: GType,
                                          n_prerequisites: *mut guint)
     -> *mut GType;
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize)
     -> gint;
    pub fn g_type_instance_get_private(instance: *mut GTypeInstance,
                                       private_type: GType) -> gpointer;
    pub fn g_type_class_adjust_private_offset(g_class: gpointer,
                                              private_size_or_offset:
                                                  *mut gint);
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
    pub fn g_type_class_get_private(klass: *mut GTypeClass,
                                    private_type: GType) -> gpointer;
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer)
     -> gint;
    pub fn g_type_ensure(_type: GType);
    pub fn g_type_get_type_registration_serial() -> guint;
    pub fn g_type_get_plugin(_type: GType) -> *mut GTypePlugin;
    pub fn g_type_interface_get_plugin(instance_type: GType,
                                       interface_type: GType)
     -> *mut GTypePlugin;
    pub fn g_type_fundamental_next() -> GType;
    pub fn g_type_fundamental(type_id: GType) -> GType;
    pub fn g_type_create_instance(_type: GType) -> *mut GTypeInstance;
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
    pub fn g_type_add_class_cache_func(cache_data: gpointer,
                                       cache_func: GTypeClassCacheFunc);
    pub fn g_type_remove_class_cache_func(cache_data: gpointer,
                                          cache_func: GTypeClassCacheFunc);
    pub fn g_type_class_unref_uncached(g_class: gpointer);
    pub fn g_type_add_interface_check(check_data: gpointer,
                                      check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_remove_interface_check(check_data: gpointer,
                                         check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_value_table_peek(_type: GType) -> *mut GTypeValueTable;
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
    pub fn g_type_check_instance_cast(instance: *mut GTypeInstance,
                                      iface_type: GType)
     -> *mut GTypeInstance;
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance,
                                      iface_type: GType) -> gboolean;
    pub fn g_type_check_instance_is_fundamentally_a(instance:
                                                        *mut GTypeInstance,
                                                    fundamental_type: GType)
     -> gboolean;
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType)
     -> *mut GTypeClass;
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType)
     -> gboolean;
    pub fn g_type_check_is_value_type(_type: GType) -> gboolean;
    pub fn g_type_check_value(value: *mut GValue) -> gboolean;
    pub fn g_type_check_value_holds(value: *mut GValue, _type: GType)
     -> gboolean;
    pub fn g_type_test_flags(_type: GType, flags: guint) -> gboolean;
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance)
     -> *const gchar;
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
    pub fn g_value_unset(value: *mut GValue);
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType)
     -> gboolean;
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType)
     -> gboolean;
    pub fn g_value_transform(src_value: *const GValue,
                             dest_value: *mut GValue) -> gboolean;
    pub fn g_value_register_transform_func(src_type: GType, dest_type: GType,
                                           transform_func: GValueTransform);
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark)
     -> gpointer;
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark,
                                  data: gpointer);
    pub fn g_param_spec_set_qdata_full(pspec: *mut GParamSpec, quark: GQuark,
                                       data: gpointer,
                                       destroy: GDestroyNotify);
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark)
     -> gpointer;
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec)
     -> *mut GParamSpec;
    pub fn g_param_value_set_default(pspec: *mut GParamSpec,
                                     value: *mut GValue);
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *mut GValue)
     -> gboolean;
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue)
     -> gboolean;
    pub fn g_param_value_convert(pspec: *mut GParamSpec,
                                 src_value: *const GValue,
                                 dest_value: *mut GValue,
                                 strict_validation: gboolean) -> gboolean;
    pub fn g_param_values_cmp(pspec: *mut GParamSpec, value1: *const GValue,
                              value2: *const GValue) -> gint;
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_param_take_ownership(value: *mut GValue,
                                            param: *mut GParamSpec);
    pub fn g_param_spec_get_default_value(param: *mut GParamSpec)
     -> *const GValue;
    pub fn g_param_type_register_static(name: *const gchar,
                                        pspec_info: *const GParamSpecTypeInfo)
     -> GType;
    pub fn _g_param_type_register_static_constant(name: *const gchar,
                                                  pspec_info:
                                                      *const GParamSpecTypeInfo,
                                                  opt_type: GType) -> GType;
    pub fn g_param_spec_internal(param_type: GType, name: *const gchar,
                                 nick: *const gchar, blurb: *const gchar,
                                 flags: GParamFlags) -> gpointer;
    pub fn g_param_spec_pool_new(type_prefixing: gboolean)
     -> *mut GParamSpecPool;
    pub fn g_param_spec_pool_insert(pool: *mut GParamSpecPool,
                                    pspec: *mut GParamSpec,
                                    owner_type: GType);
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool,
                                    pspec: *mut GParamSpec);
    pub fn g_param_spec_pool_lookup(pool: *mut GParamSpecPool,
                                    param_name: *const gchar,
                                    owner_type: GType,
                                    walk_ancestors: gboolean)
     -> *mut GParamSpec;
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool,
                                        owner_type: GType) -> *mut GList;
    pub fn g_param_spec_pool_list(pool: *mut GParamSpecPool,
                                  owner_type: GType, n_pspecs_p: *mut guint)
     -> *mut *mut GParamSpec;
    pub fn g_cclosure_new(callback_func: GCallback, user_data: gpointer,
                          destroy_data: GClosureNotify) -> *mut GClosure;
    pub fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer,
                               destroy_data: GClosureNotify) -> *mut GClosure;
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint)
     -> *mut GClosure;
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
    pub fn g_closure_sink(closure: *mut GClosure);
    pub fn g_closure_unref(closure: *mut GClosure);
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer)
     -> *mut GClosure;
    pub fn g_closure_add_finalize_notifier(closure: *mut GClosure,
                                           notify_data: gpointer,
                                           notify_func: GClosureNotify);
    pub fn g_closure_remove_finalize_notifier(closure: *mut GClosure,
                                              notify_data: gpointer,
                                              notify_func: GClosureNotify);
    pub fn g_closure_add_invalidate_notifier(closure: *mut GClosure,
                                             notify_data: gpointer,
                                             notify_func: GClosureNotify);
    pub fn g_closure_remove_invalidate_notifier(closure: *mut GClosure,
                                                notify_data: gpointer,
                                                notify_func: GClosureNotify);
    pub fn g_closure_add_marshal_guards(closure: *mut GClosure,
                                        pre_marshal_data: gpointer,
                                        pre_marshal_notify: GClosureNotify,
                                        post_marshal_data: gpointer,
                                        post_marshal_notify: GClosureNotify);
    pub fn g_closure_set_marshal(closure: *mut GClosure,
                                 marshal: GClosureMarshal);
    pub fn g_closure_set_meta_marshal(closure: *mut GClosure,
                                      marshal_data: gpointer,
                                      meta_marshal: GClosureMarshal);
    pub fn g_closure_invalidate(closure: *mut GClosure);
    pub fn g_closure_invoke(closure: *mut GClosure, return_value: *mut GValue,
                            n_param_values: guint,
                            param_values: *const GValue,
                            invocation_hint: gpointer);
    pub fn g_cclosure_marshal_generic(closure: *mut GClosure,
                                      return_gvalue: *mut GValue,
                                      n_param_values: guint,
                                      param_values: *const GValue,
                                      invocation_hint: gpointer,
                                      marshal_data: gpointer);
    pub fn g_cclosure_marshal_generic_va(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         instance: gpointer,
                                         args_list: va_list,
                                         marshal_data: gpointer,
                                         n_params: ::libc::c_int,
                                         param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VOID(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__VOIDv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::libc::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOOLEAN(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            n_param_values: guint,
                                            param_values: *const GValue,
                                            invocation_hint: gpointer,
                                            marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__BOOLEANv(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             instance: gpointer,
                                             args: va_list,
                                             marshal_data: gpointer,
                                             n_params: ::libc::c_int,
                                             param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__CHAR(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__CHARv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::libc::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UCHAR(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UCHARv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::libc::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__INT(closure: *mut GClosure,
                                        return_value: *mut GValue,
                                        n_param_values: guint,
                                        param_values: *const GValue,
                                        invocation_hint: gpointer,
                                        marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__INTv(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         instance: gpointer, args: va_list,
                                         marshal_data: gpointer,
                                         n_params: ::libc::c_int,
                                         param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UINT(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UINTv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::libc::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__LONG(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__LONGv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::libc::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ULONG(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__ULONGv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::libc::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ENUM(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__ENUMv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::libc::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLAGS(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__FLAGSv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::libc::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLOAT(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__FLOATv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::libc::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__DOUBLE(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           n_param_values: guint,
                                           param_values: *const GValue,
                                           invocation_hint: gpointer,
                                           marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__DOUBLEv(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            instance: gpointer, args: va_list,
                                            marshal_data: gpointer,
                                            n_params: ::libc::c_int,
                                            param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__STRING(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           n_param_values: guint,
                                           param_values: *const GValue,
                                           invocation_hint: gpointer,
                                           marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__STRINGv(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            instance: gpointer, args: va_list,
                                            marshal_data: gpointer,
                                            n_params: ::libc::c_int,
                                            param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__PARAM(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__PARAMv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::libc::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOXED(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__BOXEDv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::libc::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__POINTER(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            n_param_values: guint,
                                            param_values: *const GValue,
                                            invocation_hint: gpointer,
                                            marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__POINTERv(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             instance: gpointer,
                                             args: va_list,
                                             marshal_data: gpointer,
                                             n_params: ::libc::c_int,
                                             param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__OBJECT(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           n_param_values: guint,
                                           param_values: *const GValue,
                                           invocation_hint: gpointer,
                                           marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__OBJECTv(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            instance: gpointer, args: va_list,
                                            marshal_data: gpointer,
                                            n_params: ::libc::c_int,
                                            param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VARIANT(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            n_param_values: guint,
                                            param_values: *const GValue,
                                            invocation_hint: gpointer,
                                            marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__VARIANTv(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             instance: gpointer,
                                             args: va_list,
                                             marshal_data: gpointer,
                                             n_params: ::libc::c_int,
                                             param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(closure: *mut GClosure,
                                                 return_value: *mut GValue,
                                                 n_param_values: guint,
                                                 param_values: *const GValue,
                                                 invocation_hint: gpointer,
                                                 marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(closure: *mut GClosure,
                                                  return_value: *mut GValue,
                                                  instance: gpointer,
                                                  args: va_list,
                                                  marshal_data: gpointer,
                                                  n_params: ::libc::c_int,
                                                  param_types: *mut GType);
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             n_param_values: guint,
                                             param_values: *const GValue,
                                             invocation_hint: gpointer,
                                             marshal_data: gpointer);
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(closure: *mut GClosure,
                                              return_value: *mut GValue,
                                              instance: gpointer,
                                              args: va_list,
                                              marshal_data: gpointer,
                                              n_params: ::libc::c_int,
                                              param_types: *mut GType);
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(closure: *mut GClosure,
                                                     return_value:
                                                         *mut GValue,
                                                     n_param_values: guint,
                                                     param_values:
                                                         *const GValue,
                                                     invocation_hint:
                                                         gpointer,
                                                     marshal_data: gpointer);
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(closure: *mut GClosure,
                                                      return_value:
                                                          *mut GValue,
                                                      instance: gpointer,
                                                      args: va_list,
                                                      marshal_data: gpointer,
                                                      n_params: ::libc::c_int,
                                                      param_types:
                                                          *mut GType);
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: *mut GClosure,
                                                   return_value: *mut GValue,
                                                   n_param_values: guint,
                                                   param_values:
                                                       *const GValue,
                                                   invocation_hint: gpointer,
                                                   marshal_data: gpointer);
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure: *mut GClosure,
                                                    return_value: *mut GValue,
                                                    instance: gpointer,
                                                    args: va_list,
                                                    marshal_data: gpointer,
                                                    n_params: ::libc::c_int,
                                                    param_types: *mut GType);
    pub fn g_signal_newv(signal_name: *const gchar, itype: GType,
                         signal_flags: GSignalFlags,
                         class_closure: *mut GClosure,
                         accumulator: GSignalAccumulator, accu_data: gpointer,
                         c_marshaller: GSignalCMarshaller, return_type: GType,
                         n_params: guint, param_types: *mut GType) -> guint;
    pub fn g_signal_new_valist(signal_name: *const gchar, itype: GType,
                               signal_flags: GSignalFlags,
                               class_closure: *mut GClosure,
                               accumulator: GSignalAccumulator,
                               accu_data: gpointer,
                               c_marshaller: GSignalCMarshaller,
                               return_type: GType, n_params: guint,
                               args: va_list) -> guint;
    pub fn g_signal_new(signal_name: *const gchar, itype: GType,
                        signal_flags: GSignalFlags, class_offset: guint,
                        accumulator: GSignalAccumulator, accu_data: gpointer,
                        c_marshaller: GSignalCMarshaller, return_type: GType,
                        n_params: guint, ...) -> guint;
    pub fn g_signal_new_class_handler(signal_name: *const gchar, itype: GType,
                                      signal_flags: GSignalFlags,
                                      class_handler: GCallback,
                                      accumulator: GSignalAccumulator,
                                      accu_data: gpointer,
                                      c_marshaller: GSignalCMarshaller,
                                      return_type: GType,
                                      n_params: guint, ...) -> guint;
    pub fn g_signal_set_va_marshaller(signal_id: guint, instance_type: GType,
                                      va_marshaller: GSignalCVaMarshaller);
    pub fn g_signal_emitv(instance_and_params: *const GValue,
                          signal_id: guint, detail: GQuark,
                          return_value: *mut GValue);
    pub fn g_signal_emit_valist(instance: gpointer, signal_id: guint,
                                detail: GQuark, var_args: va_list);
    pub fn g_signal_emit(instance: gpointer, signal_id: guint,
                         detail: GQuark, ...);
    pub fn g_signal_emit_by_name(instance: gpointer,
                                 detailed_signal: *const gchar, ...);
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
    pub fn g_signal_parse_name(detailed_signal: *const gchar, itype: GType,
                               signal_id_p: *mut guint, detail_p: *mut GQuark,
                               force_detail_quark: gboolean) -> gboolean;
    pub fn g_signal_get_invocation_hint(instance: gpointer)
     -> *mut GSignalInvocationHint;
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint,
                                  detail: GQuark);
    pub fn g_signal_stop_emission_by_name(instance: gpointer,
                                          detailed_signal: *const gchar);
    pub fn g_signal_add_emission_hook(signal_id: guint, detail: GQuark,
                                      hook_func: GSignalEmissionHook,
                                      hook_data: gpointer,
                                      data_destroy: GDestroyNotify) -> gulong;
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
    pub fn g_signal_has_handler_pending(instance: gpointer, signal_id: guint,
                                        detail: GQuark,
                                        may_be_blocked: gboolean) -> gboolean;
    pub fn g_signal_connect_closure_by_id(instance: gpointer,
                                          signal_id: guint, detail: GQuark,
                                          closure: *mut GClosure,
                                          after: gboolean) -> gulong;
    pub fn g_signal_connect_closure(instance: gpointer,
                                    detailed_signal: *const gchar,
                                    closure: *mut GClosure, after: gboolean)
     -> gulong;
    pub fn g_signal_connect_data(instance: gpointer,
                                 detailed_signal: *const gchar,
                                 c_handler: GCallback, data: gpointer,
                                 destroy_data: GClosureNotify,
                                 connect_flags: GConnectFlags) -> gulong;
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
    pub fn g_signal_handler_disconnect(instance: gpointer,
                                       handler_id: gulong);
    pub fn g_signal_handler_is_connected(instance: gpointer,
                                         handler_id: gulong) -> gboolean;
    pub fn g_signal_handler_find(instance: gpointer, mask: GSignalMatchType,
                                 signal_id: guint, detail: GQuark,
                                 closure: *mut GClosure, func: gpointer,
                                 data: gpointer) -> gulong;
    pub fn g_signal_handlers_block_matched(instance: gpointer,
                                           mask: GSignalMatchType,
                                           signal_id: guint, detail: GQuark,
                                           closure: *mut GClosure,
                                           func: gpointer, data: gpointer)
     -> guint;
    pub fn g_signal_handlers_unblock_matched(instance: gpointer,
                                             mask: GSignalMatchType,
                                             signal_id: guint, detail: GQuark,
                                             closure: *mut GClosure,
                                             func: gpointer, data: gpointer)
     -> guint;
    pub fn g_signal_handlers_disconnect_matched(instance: gpointer,
                                                mask: GSignalMatchType,
                                                signal_id: guint,
                                                detail: GQuark,
                                                closure: *mut GClosure,
                                                func: gpointer,
                                                data: gpointer) -> guint;
    pub fn g_signal_override_class_closure(signal_id: guint,
                                           instance_type: GType,
                                           class_closure: *mut GClosure);
    pub fn g_signal_override_class_handler(signal_name: *const gchar,
                                           instance_type: GType,
                                           class_handler: GCallback);
    pub fn g_signal_chain_from_overridden(instance_and_params: *const GValue,
                                          return_value: *mut GValue);
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
    pub fn g_signal_accumulator_true_handled(ihint:
                                                 *mut GSignalInvocationHint,
                                             return_accu: *mut GValue,
                                             handler_return: *const GValue,
                                             dummy: gpointer) -> gboolean;
    pub fn g_signal_accumulator_first_wins(ihint: *mut GSignalInvocationHint,
                                           return_accu: *mut GValue,
                                           handler_return: *const GValue,
                                           dummy: gpointer) -> gboolean;
    pub fn g_signal_handlers_destroy(instance: gpointer);
    pub fn _g_signals_destroy(itype: GType);
    pub fn g_date_get_type() -> GType;
    pub fn g_strv_get_type() -> GType;
    pub fn g_gstring_get_type() -> GType;
    pub fn g_hash_table_get_type() -> GType;
    pub fn g_array_get_type() -> GType;
    pub fn g_byte_array_get_type() -> GType;
    pub fn g_ptr_array_get_type() -> GType;
    pub fn g_bytes_get_type() -> GType;
    pub fn g_variant_type_get_gtype() -> GType;
    pub fn g_regex_get_type() -> GType;
    pub fn g_match_info_get_type() -> GType;
    pub fn g_error_get_type() -> GType;
    pub fn g_date_time_get_type() -> GType;
    pub fn g_time_zone_get_type() -> GType;
    pub fn g_io_channel_get_type() -> GType;
    pub fn g_io_condition_get_type() -> GType;
    pub fn g_variant_builder_get_type() -> GType;
    pub fn g_variant_dict_get_type() -> GType;
    pub fn g_key_file_get_type() -> GType;
    pub fn g_main_loop_get_type() -> GType;
    pub fn g_main_context_get_type() -> GType;
    pub fn g_source_get_type() -> GType;
    pub fn g_pollfd_get_type() -> GType;
    pub fn g_thread_get_type() -> GType;
    pub fn g_checksum_get_type() -> GType;
    pub fn g_markup_parse_context_get_type() -> GType;
    pub fn g_mapped_file_get_type() -> GType;
    pub fn g_variant_get_gtype() -> GType;
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer)
     -> gpointer;
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_static_boxed(value: *mut GValue,
                                    v_boxed: gconstpointer);
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue,
                                            v_boxed: gconstpointer);
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
    pub fn g_boxed_type_register_static(name: *const gchar,
                                        boxed_copy: GBoxedCopyFunc,
                                        boxed_free: GBoxedFreeFunc) -> GType;
    pub fn g_closure_get_type() -> GType;
    pub fn g_value_get_type() -> GType;
    pub fn g_initially_unowned_get_type() -> GType;
    pub fn g_object_class_install_property(oclass: *mut GObjectClass,
                                           property_id: guint,
                                           pspec: *mut GParamSpec);
    pub fn g_object_class_find_property(oclass: *mut GObjectClass,
                                        property_name: *const gchar)
     -> *mut GParamSpec;
    pub fn g_object_class_list_properties(oclass: *mut GObjectClass,
                                          n_properties: *mut guint)
     -> *mut *mut GParamSpec;
    pub fn g_object_class_override_property(oclass: *mut GObjectClass,
                                            property_id: guint,
                                            name: *const gchar);
    pub fn g_object_class_install_properties(oclass: *mut GObjectClass,
                                             n_pspecs: guint,
                                             pspecs: *mut *mut GParamSpec);
    pub fn g_object_interface_install_property(g_iface: gpointer,
                                               pspec: *mut GParamSpec);
    pub fn g_object_interface_find_property(g_iface: gpointer,
                                            property_name: *const gchar)
     -> *mut GParamSpec;
    pub fn g_object_interface_list_properties(g_iface: gpointer,
                                              n_properties_p: *mut guint)
     -> *mut *mut GParamSpec;
    pub fn g_object_get_type() -> GType;
    pub fn g_object_new(object_type: GType,
                        first_property_name: *const gchar, ...) -> gpointer;
    pub fn g_object_newv(object_type: GType, n_parameters: guint,
                         parameters: *mut GParameter) -> gpointer;
    pub fn g_object_new_valist(object_type: GType,
                               first_property_name: *const gchar,
                               var_args: va_list) -> *mut GObject;
    pub fn g_object_set(object: gpointer,
                        first_property_name: *const gchar, ...);
    pub fn g_object_get(object: gpointer,
                        first_property_name: *const gchar, ...);
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...)
     -> gpointer;
    pub fn g_object_disconnect(object: gpointer,
                               signal_spec: *const gchar, ...);
    pub fn g_object_set_valist(object: *mut GObject,
                               first_property_name: *const gchar,
                               var_args: va_list);
    pub fn g_object_get_valist(object: *mut GObject,
                               first_property_name: *const gchar,
                               var_args: va_list);
    pub fn g_object_set_property(object: *mut GObject,
                                 property_name: *const gchar,
                                 value: *const GValue);
    pub fn g_object_get_property(object: *mut GObject,
                                 property_name: *const gchar,
                                 value: *mut GValue);
    pub fn g_object_freeze_notify(object: *mut GObject);
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
    pub fn g_object_notify_by_pspec(object: *mut GObject,
                                    pspec: *mut GParamSpec);
    pub fn g_object_thaw_notify(object: *mut GObject);
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
    pub fn g_object_ref(object: gpointer) -> gpointer;
    pub fn g_object_unref(object: gpointer);
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify,
                             data: gpointer);
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify,
                               data: gpointer);
    pub fn g_object_add_weak_pointer(object: *mut GObject,
                                     weak_pointer_location: *mut gpointer);
    pub fn g_object_remove_weak_pointer(object: *mut GObject,
                                        weak_pointer_location: *mut gpointer);
    pub fn g_object_add_toggle_ref(object: *mut GObject,
                                   notify: GToggleNotify, data: gpointer);
    pub fn g_object_remove_toggle_ref(object: *mut GObject,
                                      notify: GToggleNotify, data: gpointer);
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark)
     -> gpointer;
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark,
                              data: gpointer);
    pub fn g_object_set_qdata_full(object: *mut GObject, quark: GQuark,
                                   data: gpointer, destroy: GDestroyNotify);
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark)
     -> gpointer;
    pub fn g_object_dup_qdata(object: *mut GObject, quark: GQuark,
                              dup_func: GDuplicateFunc, user_data: gpointer)
     -> gpointer;
    pub fn g_object_replace_qdata(object: *mut GObject, quark: GQuark,
                                  oldval: gpointer, newval: gpointer,
                                  destroy: GDestroyNotify,
                                  old_destroy: *mut GDestroyNotify)
     -> gboolean;
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar)
     -> gpointer;
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar,
                             data: gpointer);
    pub fn g_object_set_data_full(object: *mut GObject, key: *const gchar,
                                  data: gpointer, destroy: GDestroyNotify);
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar)
     -> gpointer;
    pub fn g_object_dup_data(object: *mut GObject, key: *const gchar,
                             dup_func: GDuplicateFunc, user_data: gpointer)
     -> gpointer;
    pub fn g_object_replace_data(object: *mut GObject, key: *const gchar,
                                 oldval: gpointer, newval: gpointer,
                                 destroy: GDestroyNotify,
                                 old_destroy: *mut GDestroyNotify)
     -> gboolean;
    pub fn g_object_watch_closure(object: *mut GObject,
                                  closure: *mut GClosure);
    pub fn g_cclosure_new_object(callback_func: GCallback,
                                 object: *mut GObject) -> *mut GClosure;
    pub fn g_cclosure_new_object_swap(callback_func: GCallback,
                                      object: *mut GObject) -> *mut GClosure;
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject)
     -> *mut GClosure;
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
    pub fn g_signal_connect_object(instance: gpointer,
                                   detailed_signal: *const gchar,
                                   c_handler: GCallback, gobject: gpointer,
                                   connect_flags: GConnectFlags) -> gulong;
    pub fn g_object_force_floating(object: *mut GObject);
    pub fn g_object_run_dispose(object: *mut GObject);
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_set_object_take_ownership(value: *mut GValue,
                                             v_object: gpointer);
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
    pub fn g_binding_flags_get_type() -> GType;
    pub fn g_binding_get_type() -> GType;
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_source_property(binding: *mut GBinding)
     -> *const gchar;
    pub fn g_binding_get_target_property(binding: *mut GBinding)
     -> *const gchar;
    pub fn g_binding_unbind(binding: *mut GBinding);
    pub fn g_object_bind_property(source: gpointer,
                                  source_property: *const gchar,
                                  target: gpointer,
                                  target_property: *const gchar,
                                  flags: GBindingFlags) -> *mut GBinding;
    pub fn g_object_bind_property_full(source: gpointer,
                                       source_property: *const gchar,
                                       target: gpointer,
                                       target_property: *const gchar,
                                       flags: GBindingFlags,
                                       transform_to: GBindingTransformFunc,
                                       transform_from: GBindingTransformFunc,
                                       user_data: gpointer,
                                       notify: GDestroyNotify)
     -> *mut GBinding;
    pub fn g_object_bind_property_with_closures(source: gpointer,
                                                source_property: *const gchar,
                                                target: gpointer,
                                                target_property: *const gchar,
                                                flags: GBindingFlags,
                                                transform_to: *mut GClosure,
                                                transform_from: *mut GClosure)
     -> *mut GBinding;
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint)
     -> *mut GEnumValue;
    pub fn g_enum_get_value_by_name(enum_class: *mut GEnumClass,
                                    name: *const gchar) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_nick(enum_class: *mut GEnumClass,
                                    nick: *const gchar) -> *mut GEnumValue;
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass,
                                   value: guint) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_name(flags_class: *mut GFlagsClass,
                                     name: *const gchar) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_nick(flags_class: *mut GFlagsClass,
                                     nick: *const gchar) -> *mut GFlagsValue;
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
    pub fn g_value_get_enum(value: *const GValue) -> gint;
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
    pub fn g_value_get_flags(value: *const GValue) -> guint;
    pub fn g_enum_register_static(name: *const gchar,
                                  const_static_values: *const GEnumValue)
     -> GType;
    pub fn g_flags_register_static(name: *const gchar,
                                   const_static_values: *const GFlagsValue)
     -> GType;
    pub fn g_enum_complete_type_info(g_enum_type: GType, info: *mut GTypeInfo,
                                     const_values: *const GEnumValue);
    pub fn g_flags_complete_type_info(g_flags_type: GType,
                                      info: *mut GTypeInfo,
                                      const_values: *const GFlagsValue);
    pub fn g_param_spec_char(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, minimum: gint8,
                             maximum: gint8, default_value: gint8,
                             flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uchar(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: guint8,
                              maximum: guint8, default_value: guint8,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_boolean(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar, default_value: gboolean,
                                flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int(name: *const gchar, nick: *const gchar,
                            blurb: *const gchar, minimum: gint, maximum: gint,
                            default_value: gint, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_uint(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, minimum: guint,
                             maximum: guint, default_value: guint,
                             flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_long(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, minimum: glong,
                             maximum: glong, default_value: glong,
                             flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_ulong(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: gulong,
                              maximum: gulong, default_value: gulong,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int64(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: gint64,
                              maximum: gint64, default_value: gint64,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uint64(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar, minimum: guint64,
                               maximum: guint64, default_value: guint64,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_unichar(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar, default_value: gunichar,
                                flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_enum(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, enum_type: GType,
                             default_value: gint, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_flags(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, flags_type: GType,
                              default_value: guint, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_float(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: gfloat,
                              maximum: gfloat, default_value: gfloat,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_double(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar, minimum: gdouble,
                               maximum: gdouble, default_value: gdouble,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_string(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar,
                               default_value: *const gchar,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_param(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, param_type: GType,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_boxed(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, boxed_type: GType,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_pointer(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_value_array(name: *const gchar, nick: *const gchar,
                                    blurb: *const gchar,
                                    element_spec: *mut GParamSpec,
                                    flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_object(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar, object_type: GType,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_override(name: *const gchar,
                                 overridden: *mut GParamSpec)
     -> *mut GParamSpec;
    pub fn g_param_spec_gtype(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, is_a_type: GType,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_variant(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar,
                                _type: *const GVariantType,
                                default_value: *mut GVariant,
                                flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
    pub fn g_source_set_dummy_callback(source: *mut GSource);
    pub fn g_type_module_get_type() -> GType;
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
    pub fn g_type_module_unuse(module: *mut GTypeModule);
    pub fn g_type_module_set_name(module: *mut GTypeModule,
                                  name: *const gchar);
    pub fn g_type_module_register_type(module: *mut GTypeModule,
                                       parent_type: GType,
                                       type_name: *const gchar,
                                       type_info: *const GTypeInfo,
                                       flags: GTypeFlags) -> GType;
    pub fn g_type_module_add_interface(module: *mut GTypeModule,
                                       instance_type: GType,
                                       interface_type: GType,
                                       interface_info: *const GInterfaceInfo);
    pub fn g_type_module_register_enum(module: *mut GTypeModule,
                                       name: *const gchar,
                                       const_static_values: *const GEnumValue)
     -> GType;
    pub fn g_type_module_register_flags(module: *mut GTypeModule,
                                        name: *const gchar,
                                        const_static_values:
                                            *const GFlagsValue) -> GType;
    pub fn g_type_plugin_get_type() -> GType;
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
    pub fn g_type_plugin_complete_type_info(plugin: *mut GTypePlugin,
                                            g_type: GType,
                                            info: *mut GTypeInfo,
                                            value_table:
                                                *mut GTypeValueTable);
    pub fn g_type_plugin_complete_interface_info(plugin: *mut GTypePlugin,
                                                 instance_type: GType,
                                                 interface_type: GType,
                                                 info: *mut GInterfaceInfo);
    pub fn g_value_array_get_type() -> GType;
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint)
     -> *mut GValue;
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
    pub fn g_value_array_free(value_array: *mut GValueArray);
    pub fn g_value_array_copy(value_array: *const GValueArray)
     -> *mut GValueArray;
    pub fn g_value_array_prepend(value_array: *mut GValueArray,
                                 value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_append(value_array: *mut GValueArray,
                                value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_insert(value_array: *mut GValueArray, index_: guint,
                                value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint)
     -> *mut GValueArray;
    pub fn g_value_array_sort(value_array: *mut GValueArray,
                              compare_func: GCompareFunc) -> *mut GValueArray;
    pub fn g_value_array_sort_with_data(value_array: *mut GValueArray,
                                        compare_func: GCompareDataFunc,
                                        user_data: gpointer)
     -> *mut GValueArray;
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
    pub fn g_value_get_char(value: *const GValue) -> gchar;
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
    pub fn g_value_get_int(value: *const GValue) -> gint;
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
    pub fn g_value_get_uint(value: *const GValue) -> guint;
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
    pub fn g_value_get_long(value: *const GValue) -> glong;
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
    pub fn g_value_set_static_string(value: *mut GValue,
                                     v_string: *const gchar);
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
    pub fn g_gtype_get_type() -> GType;
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
    pub fn g_value_set_string_take_ownership(value: *mut GValue,
                                             v_string: *mut gchar);
    pub fn gst_object_flags_get_type() -> GType;
    pub fn gst_allocator_flags_get_type() -> GType;
    pub fn gst_bin_flags_get_type() -> GType;
    pub fn gst_buffer_flags_get_type() -> GType;
    pub fn gst_buffer_copy_flags_get_type() -> GType;
    pub fn gst_buffer_pool_acquire_flags_get_type() -> GType;
    pub fn gst_bus_flags_get_type() -> GType;
    pub fn gst_bus_sync_reply_get_type() -> GType;
    pub fn gst_caps_flags_get_type() -> GType;
    pub fn gst_caps_intersect_mode_get_type() -> GType;
    pub fn gst_clock_return_get_type() -> GType;
    pub fn gst_clock_entry_type_get_type() -> GType;
    pub fn gst_clock_flags_get_type() -> GType;
    pub fn gst_debug_graph_details_get_type() -> GType;
    pub fn gst_state_get_type() -> GType;
    pub fn gst_state_change_return_get_type() -> GType;
    pub fn gst_state_change_get_type() -> GType;
    pub fn gst_element_flags_get_type() -> GType;
    pub fn gst_core_error_get_type() -> GType;
    pub fn gst_library_error_get_type() -> GType;
    pub fn gst_resource_error_get_type() -> GType;
    pub fn gst_stream_error_get_type() -> GType;
    pub fn gst_event_type_flags_get_type() -> GType;
    pub fn gst_event_type_get_type() -> GType;
    pub fn gst_qos_type_get_type() -> GType;
    pub fn gst_stream_flags_get_type() -> GType;
    pub fn gst_format_get_type() -> GType;
    pub fn gst_debug_level_get_type() -> GType;
    pub fn gst_debug_color_flags_get_type() -> GType;
    pub fn gst_debug_color_mode_get_type() -> GType;
    pub fn gst_iterator_result_get_type() -> GType;
    pub fn gst_iterator_item_get_type() -> GType;
    pub fn gst_message_type_get_type() -> GType;
    pub fn gst_structure_change_type_get_type() -> GType;
    pub fn gst_stream_status_type_get_type() -> GType;
    pub fn gst_progress_type_get_type() -> GType;
    pub fn gst_meta_flags_get_type() -> GType;
    pub fn gst_memory_flags_get_type() -> GType;
    pub fn gst_map_flags_get_type() -> GType;
    pub fn gst_mini_object_flags_get_type() -> GType;
    pub fn gst_lock_flags_get_type() -> GType;
    pub fn gst_pad_direction_get_type() -> GType;
    pub fn gst_pad_mode_get_type() -> GType;
    pub fn gst_pad_link_return_get_type() -> GType;
    pub fn gst_flow_return_get_type() -> GType;
    pub fn gst_pad_link_check_get_type() -> GType;
    pub fn gst_pad_probe_type_get_type() -> GType;
    pub fn gst_pad_probe_return_get_type() -> GType;
    pub fn gst_pad_flags_get_type() -> GType;
    pub fn gst_pad_presence_get_type() -> GType;
    pub fn gst_pad_template_flags_get_type() -> GType;
    pub fn gst_pipeline_flags_get_type() -> GType;
    pub fn gst_plugin_error_get_type() -> GType;
    pub fn gst_plugin_flags_get_type() -> GType;
    pub fn gst_plugin_dependency_flags_get_type() -> GType;
    pub fn gst_rank_get_type() -> GType;
    pub fn gst_query_type_flags_get_type() -> GType;
    pub fn gst_query_type_get_type() -> GType;
    pub fn gst_buffering_mode_get_type() -> GType;
    pub fn gst_scheduling_flags_get_type() -> GType;
    pub fn gst_seek_type_get_type() -> GType;
    pub fn gst_seek_flags_get_type() -> GType;
    pub fn gst_segment_flags_get_type() -> GType;
    pub fn gst_clock_type_get_type() -> GType;
    pub fn gst_tag_merge_mode_get_type() -> GType;
    pub fn gst_tag_flag_get_type() -> GType;
    pub fn gst_tag_scope_get_type() -> GType;
    pub fn gst_task_state_get_type() -> GType;
    pub fn gst_toc_scope_get_type() -> GType;
    pub fn gst_toc_entry_type_get_type() -> GType;
    pub fn gst_toc_loop_type_get_type() -> GType;
    pub fn gst_type_find_probability_get_type() -> GType;
    pub fn gst_uri_error_get_type() -> GType;
    pub fn gst_uri_type_get_type() -> GType;
    pub fn gst_search_mode_get_type() -> GType;
    pub fn gst_parse_error_get_type() -> GType;
    pub fn gst_parse_flags_get_type() -> GType;
    pub fn gst_atomic_queue_get_type() -> GType;
    pub fn gst_atomic_queue_new(initial_size: guint) -> *mut GstAtomicQueue;
    pub fn gst_atomic_queue_ref(queue: *mut GstAtomicQueue);
    pub fn gst_atomic_queue_unref(queue: *mut GstAtomicQueue);
    pub fn gst_atomic_queue_push(queue: *mut GstAtomicQueue, data: gpointer);
    pub fn gst_atomic_queue_pop(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_peek(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_length(queue: *mut GstAtomicQueue) -> guint;
    pub fn gst_object_get_type() -> GType;
    pub fn gst_object_set_name(object: *mut GstObject, name: *const gchar)
     -> gboolean;
    pub fn gst_object_get_name(object: *mut GstObject) -> *mut gchar;
    pub fn gst_object_set_parent(object: *mut GstObject,
                                 parent: *mut GstObject) -> gboolean;
    pub fn gst_object_get_parent(object: *mut GstObject) -> *mut GstObject;
    pub fn gst_object_unparent(object: *mut GstObject);
    pub fn gst_object_has_ancestor(object: *mut GstObject,
                                   ancestor: *mut GstObject) -> gboolean;
    pub fn gst_object_default_deep_notify(object: *mut GObject,
                                          orig: *mut GstObject,
                                          pspec: *mut GParamSpec,
                                          excluded_props: *mut *mut gchar);
    pub fn gst_object_ref(object: gpointer) -> gpointer;
    pub fn gst_object_unref(object: gpointer);
    pub fn gst_object_ref_sink(object: gpointer) -> gpointer;
    pub fn gst_object_replace(oldobj: *mut *mut GstObject,
                              newobj: *mut GstObject) -> gboolean;
    pub fn gst_object_get_path_string(object: *mut GstObject) -> *mut gchar;
    pub fn gst_object_check_uniqueness(list: *mut GList, name: *const gchar)
     -> gboolean;
    pub fn gst_clock_get_type() -> GType;
    pub fn gst_clock_set_resolution(clock: *mut GstClock,
                                    resolution: GstClockTime) -> GstClockTime;
    pub fn gst_clock_get_resolution(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_set_calibration(clock: *mut GstClock,
                                     internal: GstClockTime,
                                     external: GstClockTime,
                                     rate_num: GstClockTime,
                                     rate_denom: GstClockTime);
    pub fn gst_clock_get_calibration(clock: *mut GstClock,
                                     internal: *mut GstClockTime,
                                     external: *mut GstClockTime,
                                     rate_num: *mut GstClockTime,
                                     rate_denom: *mut GstClockTime);
    pub fn gst_clock_set_master(clock: *mut GstClock, master: *mut GstClock)
     -> gboolean;
    pub fn gst_clock_get_master(clock: *mut GstClock) -> *mut GstClock;
    pub fn gst_clock_set_timeout(clock: *mut GstClock, timeout: GstClockTime);
    pub fn gst_clock_get_timeout(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_add_observation(clock: *mut GstClock,
                                     slave: GstClockTime,
                                     master: GstClockTime,
                                     r_squared: *mut gdouble) -> gboolean;
    pub fn gst_clock_get_internal_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_adjust_unlocked(clock: *mut GstClock,
                                     internal: GstClockTime) -> GstClockTime;
    pub fn gst_clock_unadjust_unlocked(clock: *mut GstClock,
                                       external: GstClockTime)
     -> GstClockTime;
    pub fn gst_clock_new_single_shot_id(clock: *mut GstClock,
                                        time: GstClockTime) -> GstClockID;
    pub fn gst_clock_new_periodic_id(clock: *mut GstClock,
                                     start_time: GstClockTime,
                                     interval: GstClockTime) -> GstClockID;
    pub fn gst_clock_id_ref(id: GstClockID) -> GstClockID;
    pub fn gst_clock_id_unref(id: GstClockID);
    pub fn gst_clock_id_compare_func(id1: gconstpointer, id2: gconstpointer)
     -> gint;
    pub fn gst_clock_id_get_time(id: GstClockID) -> GstClockTime;
    pub fn gst_clock_id_wait(id: GstClockID, jitter: *mut GstClockTimeDiff)
     -> GstClockReturn;
    pub fn gst_clock_id_wait_async(id: GstClockID, func: GstClockCallback,
                                   user_data: gpointer,
                                   destroy_data: GDestroyNotify)
     -> GstClockReturn;
    pub fn gst_clock_id_unschedule(id: GstClockID);
    pub fn gst_clock_single_shot_id_reinit(clock: *mut GstClock,
                                           id: GstClockID, time: GstClockTime)
     -> gboolean;
    pub fn gst_clock_periodic_id_reinit(clock: *mut GstClock, id: GstClockID,
                                        start_time: GstClockTime,
                                        interval: GstClockTime) -> gboolean;
    pub fn gst_control_source_get_type() -> GType;
    pub fn gst_control_source_get_value(_self: *mut GstControlSource,
                                        timestamp: GstClockTime,
                                        value: *mut gdouble) -> gboolean;
    pub fn gst_control_source_get_value_array(_self: *mut GstControlSource,
                                              timestamp: GstClockTime,
                                              interval: GstClockTime,
                                              n_values: guint,
                                              values: *mut gdouble)
     -> gboolean;
    pub fn gst_control_binding_get_type() -> GType;
    pub fn gst_control_binding_sync_values(binding: *mut GstControlBinding,
                                           object: *mut GstObject,
                                           timestamp: GstClockTime,
                                           last_sync: GstClockTime)
     -> gboolean;
    pub fn gst_control_binding_get_value(binding: *mut GstControlBinding,
                                         timestamp: GstClockTime)
     -> *mut GValue;
    pub fn gst_control_binding_get_value_array(binding:
                                                   *mut GstControlBinding,
                                               timestamp: GstClockTime,
                                               interval: GstClockTime,
                                               n_values: guint,
                                               values: gpointer) -> gboolean;
    pub fn gst_control_binding_get_g_value_array(binding:
                                                     *mut GstControlBinding,
                                                 timestamp: GstClockTime,
                                                 interval: GstClockTime,
                                                 n_values: guint,
                                                 values: *mut GValue)
     -> gboolean;
    pub fn gst_control_binding_set_disabled(binding: *mut GstControlBinding,
                                            disabled: gboolean);
    pub fn gst_control_binding_is_disabled(binding: *mut GstControlBinding)
     -> gboolean;
    pub fn gst_object_suggest_next_sync(object: *mut GstObject)
     -> GstClockTime;
    pub fn gst_object_sync_values(object: *mut GstObject,
                                  timestamp: GstClockTime) -> gboolean;
    pub fn gst_object_has_active_control_bindings(object: *mut GstObject)
     -> gboolean;
    pub fn gst_object_set_control_bindings_disabled(object: *mut GstObject,
                                                    disabled: gboolean);
    pub fn gst_object_set_control_binding_disabled(object: *mut GstObject,
                                                   property_name:
                                                       *const gchar,
                                                   disabled: gboolean);
    pub fn gst_object_add_control_binding(object: *mut GstObject,
                                          binding: *mut GstControlBinding)
     -> gboolean;
    pub fn gst_object_get_control_binding(object: *mut GstObject,
                                          property_name: *const gchar)
     -> *mut GstControlBinding;
    pub fn gst_object_remove_control_binding(object: *mut GstObject,
                                             binding: *mut GstControlBinding)
     -> gboolean;
    pub fn gst_object_get_value(object: *mut GstObject,
                                property_name: *const gchar,
                                timestamp: GstClockTime) -> *mut GValue;
    pub fn gst_object_get_value_array(object: *mut GstObject,
                                      property_name: *const gchar,
                                      timestamp: GstClockTime,
                                      interval: GstClockTime, n_values: guint,
                                      values: gpointer) -> gboolean;
    pub fn gst_object_get_g_value_array(object: *mut GstObject,
                                        property_name: *const gchar,
                                        timestamp: GstClockTime,
                                        interval: GstClockTime,
                                        n_values: guint, values: *mut GValue)
     -> gboolean;
    pub fn gst_object_get_control_rate(object: *mut GstObject)
     -> GstClockTime;
    pub fn gst_object_set_control_rate(object: *mut GstObject,
                                       control_rate: GstClockTime);
    pub fn gst_pad_mode_get_name(mode: GstPadMode) -> *const gchar;
    pub fn gst_mini_object_init(mini_object: *mut GstMiniObject, flags: guint,
                                _type: GType,
                                copy_func: GstMiniObjectCopyFunction,
                                dispose_func: GstMiniObjectDisposeFunction,
                                free_func: GstMiniObjectFreeFunction);
    pub fn gst_mini_object_ref(mini_object: *mut GstMiniObject)
     -> *mut GstMiniObject;
    pub fn gst_mini_object_unref(mini_object: *mut GstMiniObject);
    pub fn gst_mini_object_weak_ref(object: *mut GstMiniObject,
                                    notify: GstMiniObjectNotify,
                                    data: gpointer);
    pub fn gst_mini_object_weak_unref(object: *mut GstMiniObject,
                                      notify: GstMiniObjectNotify,
                                      data: gpointer);
    pub fn gst_mini_object_lock(object: *mut GstMiniObject,
                                flags: GstLockFlags) -> gboolean;
    pub fn gst_mini_object_unlock(object: *mut GstMiniObject,
                                  flags: GstLockFlags);
    pub fn gst_mini_object_is_writable(mini_object: *const GstMiniObject)
     -> gboolean;
    pub fn gst_mini_object_make_writable(mini_object: *mut GstMiniObject)
     -> *mut GstMiniObject;
    pub fn gst_mini_object_copy(mini_object: *const GstMiniObject)
     -> *mut GstMiniObject;
    pub fn gst_mini_object_set_qdata(object: *mut GstMiniObject,
                                     quark: GQuark, data: gpointer,
                                     destroy: GDestroyNotify);
    pub fn gst_mini_object_get_qdata(object: *mut GstMiniObject,
                                     quark: GQuark) -> gpointer;
    pub fn gst_mini_object_steal_qdata(object: *mut GstMiniObject,
                                       quark: GQuark) -> gpointer;
    pub fn gst_mini_object_replace(olddata: *mut *mut GstMiniObject,
                                   newdata: *mut GstMiniObject) -> gboolean;
    pub fn gst_mini_object_take(olddata: *mut *mut GstMiniObject,
                                newdata: *mut GstMiniObject) -> gboolean;
    pub fn gst_mini_object_steal(olddata: *mut *mut GstMiniObject)
     -> *mut GstMiniObject;
    pub fn gst_memory_get_type() -> GType;
    pub fn gst_memory_init(mem: *mut GstMemory, flags: GstMemoryFlags,
                           allocator: *mut GstAllocator,
                           parent: *mut GstMemory, maxsize: gsize,
                           align: gsize, offset: gsize, size: gsize);
    pub fn gst_memory_is_type(mem: *mut GstMemory, mem_type: *const gchar)
     -> gboolean;
    pub fn gst_memory_get_sizes(mem: *mut GstMemory, offset: *mut gsize,
                                maxsize: *mut gsize) -> gsize;
    pub fn gst_memory_resize(mem: *mut GstMemory, offset: gssize,
                             size: gsize);
    pub fn gst_memory_make_mapped(mem: *mut GstMemory, info: *mut GstMapInfo,
                                  flags: GstMapFlags) -> *mut GstMemory;
    pub fn gst_memory_map(mem: *mut GstMemory, info: *mut GstMapInfo,
                          flags: GstMapFlags) -> gboolean;
    pub fn gst_memory_unmap(mem: *mut GstMemory, info: *mut GstMapInfo);
    pub fn gst_memory_copy(mem: *mut GstMemory, offset: gssize, size: gssize)
     -> *mut GstMemory;
    pub fn gst_memory_share(mem: *mut GstMemory, offset: gssize, size: gssize)
     -> *mut GstMemory;
    pub fn gst_memory_is_span(mem1: *mut GstMemory, mem2: *mut GstMemory,
                              offset: *mut gsize) -> gboolean;
    pub fn gst_allocation_params_get_type() -> GType;
    pub fn gst_allocator_get_type() -> GType;
    pub fn gst_allocator_register(name: *const gchar,
                                  allocator: *mut GstAllocator);
    pub fn gst_allocator_find(name: *const gchar) -> *mut GstAllocator;
    pub fn gst_allocator_set_default(allocator: *mut GstAllocator);
    pub fn gst_allocation_params_init(params: *mut GstAllocationParams);
    pub fn gst_allocation_params_copy(params: *const GstAllocationParams)
     -> *mut GstAllocationParams;
    pub fn gst_allocation_params_free(params: *mut GstAllocationParams);
    pub fn gst_allocator_alloc(allocator: *mut GstAllocator, size: gsize,
                               params: *mut GstAllocationParams)
     -> *mut GstMemory;
    pub fn gst_allocator_free(allocator: *mut GstAllocator,
                              memory: *mut GstMemory);
    pub fn gst_memory_new_wrapped(flags: GstMemoryFlags, data: gpointer,
                                  maxsize: gsize, offset: gsize, size: gsize,
                                  user_data: gpointer, notify: GDestroyNotify)
     -> *mut GstMemory;
    pub fn gst_buffer_get_type() -> GType;
    pub fn gst_buffer_get_max_memory() -> guint;
    pub fn gst_buffer_new() -> *mut GstBuffer;
    pub fn gst_buffer_new_allocate(allocator: *mut GstAllocator, size: gsize,
                                   params: *mut GstAllocationParams)
     -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped_full(flags: GstMemoryFlags, data: gpointer,
                                       maxsize: gsize, offset: gsize,
                                       size: gsize, user_data: gpointer,
                                       notify: GDestroyNotify)
     -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped(data: gpointer, size: gsize)
     -> *mut GstBuffer;
    pub fn gst_buffer_n_memory(buffer: *mut GstBuffer) -> guint;
    pub fn gst_buffer_insert_memory(buffer: *mut GstBuffer, idx: gint,
                                    mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory_range(buffer: *mut GstBuffer, idx: guint,
                                           length: gint, mem: *mut GstMemory);
    pub fn gst_buffer_peek_memory(buffer: *mut GstBuffer, idx: guint)
     -> *mut GstMemory;
    pub fn gst_buffer_get_memory_range(buffer: *mut GstBuffer, idx: guint,
                                       length: gint) -> *mut GstMemory;
    pub fn gst_buffer_remove_memory_range(buffer: *mut GstBuffer, idx: guint,
                                          length: gint);
    pub fn gst_buffer_prepend_memory(buffer: *mut GstBuffer,
                                     mem: *mut GstMemory);
    pub fn gst_buffer_append_memory(buffer: *mut GstBuffer,
                                    mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory(buffer: *mut GstBuffer, idx: guint,
                                     mem: *mut GstMemory);
    pub fn gst_buffer_replace_all_memory(buffer: *mut GstBuffer,
                                         mem: *mut GstMemory);
    pub fn gst_buffer_get_memory(buffer: *mut GstBuffer, idx: guint)
     -> *mut GstMemory;
    pub fn gst_buffer_get_all_memory(buffer: *mut GstBuffer)
     -> *mut GstMemory;
    pub fn gst_buffer_remove_memory(buffer: *mut GstBuffer, idx: guint);
    pub fn gst_buffer_remove_all_memory(buffer: *mut GstBuffer);
    pub fn gst_buffer_find_memory(buffer: *mut GstBuffer, offset: gsize,
                                  size: gsize, idx: *mut guint,
                                  length: *mut guint, skip: *mut gsize)
     -> gboolean;
    pub fn gst_buffer_is_memory_range_writable(buffer: *mut GstBuffer,
                                               idx: guint, length: gint)
     -> gboolean;
    pub fn gst_buffer_is_all_memory_writable(buffer: *mut GstBuffer)
     -> gboolean;
    pub fn gst_buffer_fill(buffer: *mut GstBuffer, offset: gsize,
                           src: gconstpointer, size: gsize) -> gsize;
    pub fn gst_buffer_extract(buffer: *mut GstBuffer, offset: gsize,
                              dest: gpointer, size: gsize) -> gsize;
    pub fn gst_buffer_memcmp(buffer: *mut GstBuffer, offset: gsize,
                             mem: gconstpointer, size: gsize) -> gint;
    pub fn gst_buffer_memset(buffer: *mut GstBuffer, offset: gsize,
                             val: guint8, size: gsize) -> gsize;
    pub fn gst_buffer_get_sizes_range(buffer: *mut GstBuffer, idx: guint,
                                      length: gint, offset: *mut gsize,
                                      maxsize: *mut gsize) -> gsize;
    pub fn gst_buffer_resize_range(buffer: *mut GstBuffer, idx: guint,
                                   length: gint, offset: gssize, size: gssize)
     -> gboolean;
    pub fn gst_buffer_get_sizes(buffer: *mut GstBuffer, offset: *mut gsize,
                                maxsize: *mut gsize) -> gsize;
    pub fn gst_buffer_get_size(buffer: *mut GstBuffer) -> gsize;
    pub fn gst_buffer_resize(buffer: *mut GstBuffer, offset: gssize,
                             size: gssize);
    pub fn gst_buffer_set_size(buffer: *mut GstBuffer, size: gssize);
    pub fn gst_buffer_map_range(buffer: *mut GstBuffer, idx: guint,
                                length: gint, info: *mut GstMapInfo,
                                flags: GstMapFlags) -> gboolean;
    pub fn gst_buffer_map(buffer: *mut GstBuffer, info: *mut GstMapInfo,
                          flags: GstMapFlags) -> gboolean;
    pub fn gst_buffer_unmap(buffer: *mut GstBuffer, info: *mut GstMapInfo);
    pub fn gst_buffer_extract_dup(buffer: *mut GstBuffer, offset: gsize,
                                  size: gsize, dest: *mut gpointer,
                                  dest_size: *mut gsize);
    pub fn gst_buffer_copy_into(dest: *mut GstBuffer, src: *mut GstBuffer,
                                flags: GstBufferCopyFlags, offset: gsize,
                                size: gsize) -> gboolean;
    pub fn gst_buffer_copy_region(parent: *mut GstBuffer,
                                  flags: GstBufferCopyFlags, offset: gsize,
                                  size: gsize) -> *mut GstBuffer;
    pub fn gst_buffer_append_region(buf1: *mut GstBuffer,
                                    buf2: *mut GstBuffer, offset: gssize,
                                    size: gssize) -> *mut GstBuffer;
    pub fn gst_buffer_append(buf1: *mut GstBuffer, buf2: *mut GstBuffer)
     -> *mut GstBuffer;
    pub fn gst_meta_api_type_register(api: *const gchar,
                                      tags: *mut *const gchar) -> GType;
    pub fn gst_meta_api_type_has_tag(api: GType, tag: GQuark) -> gboolean;
    pub fn gst_meta_register(api: GType, _impl: *const gchar, size: gsize,
                             init_func: GstMetaInitFunction,
                             free_func: GstMetaFreeFunction,
                             transform_func: GstMetaTransformFunction)
     -> *const GstMetaInfo;
    pub fn gst_meta_get_info(_impl: *const gchar) -> *const GstMetaInfo;
    pub fn gst_meta_api_type_get_tags(api: GType) -> *const *const gchar;
    pub fn gst_buffer_get_meta(buffer: *mut GstBuffer, api: GType)
     -> *mut GstMeta;
    pub fn gst_buffer_add_meta(buffer: *mut GstBuffer,
                               info: *const GstMetaInfo, params: gpointer)
     -> *mut GstMeta;
    pub fn gst_buffer_remove_meta(buffer: *mut GstBuffer, meta: *mut GstMeta)
     -> gboolean;
    pub fn gst_buffer_iterate_meta(buffer: *mut GstBuffer,
                                   state: *mut gpointer) -> *mut GstMeta;
    pub fn gst_buffer_foreach_meta(buffer: *mut GstBuffer,
                                   func: GstBufferForeachMetaFunc,
                                   user_data: gpointer) -> gboolean;
    pub fn gst_buffer_list_get_type() -> GType;
    pub fn gst_buffer_list_new() -> *mut GstBufferList;
    pub fn gst_buffer_list_new_sized(size: guint) -> *mut GstBufferList;
    pub fn gst_buffer_list_length(list: *mut GstBufferList) -> guint;
    pub fn gst_buffer_list_get(list: *mut GstBufferList, idx: guint)
     -> *mut GstBuffer;
    pub fn gst_buffer_list_insert(list: *mut GstBufferList, idx: gint,
                                  buffer: *mut GstBuffer);
    pub fn gst_buffer_list_remove(list: *mut GstBufferList, idx: guint,
                                  length: guint);
    pub fn gst_buffer_list_foreach(list: *mut GstBufferList,
                                   func: GstBufferListFunc,
                                   user_data: gpointer) -> gboolean;
    pub fn gst_date_time_get_type() -> GType;
    pub fn gst_date_time_has_year(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_month(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_day(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_time(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_second(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_get_year(datetime: *const GstDateTime) -> gint;
    pub fn gst_date_time_get_month(datetime: *const GstDateTime) -> gint;
    pub fn gst_date_time_get_day(datetime: *const GstDateTime) -> gint;
    pub fn gst_date_time_get_hour(datetime: *const GstDateTime) -> gint;
    pub fn gst_date_time_get_minute(datetime: *const GstDateTime) -> gint;
    pub fn gst_date_time_get_second(datetime: *const GstDateTime) -> gint;
    pub fn gst_date_time_get_microsecond(datetime: *const GstDateTime)
     -> gint;
    pub fn gst_date_time_get_time_zone_offset(datetime: *const GstDateTime)
     -> gfloat;
    pub fn gst_date_time_new_from_unix_epoch_local_time(secs: gint64)
     -> *mut GstDateTime;
    pub fn gst_date_time_new_from_unix_epoch_utc(secs: gint64)
     -> *mut GstDateTime;
    pub fn gst_date_time_new_local_time(year: gint, month: gint, day: gint,
                                        hour: gint, minute: gint,
                                        seconds: gdouble) -> *mut GstDateTime;
    pub fn gst_date_time_new_y(year: gint) -> *mut GstDateTime;
    pub fn gst_date_time_new_ym(year: gint, month: gint) -> *mut GstDateTime;
    pub fn gst_date_time_new_ymd(year: gint, month: gint, day: gint)
     -> *mut GstDateTime;
    pub fn gst_date_time_new(tzoffset: gfloat, year: gint, month: gint,
                             day: gint, hour: gint, minute: gint,
                             seconds: gdouble) -> *mut GstDateTime;
    pub fn gst_date_time_new_now_local_time() -> *mut GstDateTime;
    pub fn gst_date_time_new_now_utc() -> *mut GstDateTime;
    pub fn gst_date_time_to_iso8601_string(datetime: *mut GstDateTime)
     -> *mut gchar;
    pub fn gst_date_time_new_from_iso8601_string(string: *const gchar)
     -> *mut GstDateTime;
    pub fn gst_date_time_to_g_date_time(datetime: *mut GstDateTime)
     -> *mut GDateTime;
    pub fn gst_date_time_new_from_g_date_time(dt: *mut GDateTime)
     -> *mut GstDateTime;
    pub fn gst_date_time_ref(datetime: *mut GstDateTime) -> *mut GstDateTime;
    pub fn gst_date_time_unref(datetime: *mut GstDateTime);
    pub fn gst_structure_get_type() -> GType;
    pub fn gst_structure_new_empty(name: *const gchar) -> *mut GstStructure;
    pub fn gst_structure_new_id_empty(quark: GQuark) -> *mut GstStructure;
    pub fn gst_structure_new(name: *const gchar,
                             firstfield: *const gchar, ...)
     -> *mut GstStructure;
    pub fn gst_structure_new_valist(name: *const gchar,
                                    firstfield: *const gchar,
                                    varargs: va_list) -> *mut GstStructure;
    pub fn gst_structure_new_id(name_quark: GQuark, field_quark: GQuark, ...)
     -> *mut GstStructure;
    pub fn gst_structure_new_from_string(string: *const gchar)
     -> *mut GstStructure;
    pub fn gst_structure_copy(structure: *const GstStructure)
     -> *mut GstStructure;
    pub fn gst_structure_set_parent_refcount(structure: *mut GstStructure,
                                             refcount: *mut gint) -> gboolean;
    pub fn gst_structure_free(structure: *mut GstStructure);
    pub fn gst_structure_get_name(structure: *const GstStructure)
     -> *const gchar;
    pub fn gst_structure_get_name_id(structure: *const GstStructure)
     -> GQuark;
    pub fn gst_structure_has_name(structure: *const GstStructure,
                                  name: *const gchar) -> gboolean;
    pub fn gst_structure_set_name(structure: *mut GstStructure,
                                  name: *const gchar);
    pub fn gst_structure_id_set_value(structure: *mut GstStructure,
                                      field: GQuark, value: *const GValue);
    pub fn gst_structure_set_value(structure: *mut GstStructure,
                                   fieldname: *const gchar,
                                   value: *const GValue);
    pub fn gst_structure_id_take_value(structure: *mut GstStructure,
                                       field: GQuark, value: *mut GValue);
    pub fn gst_structure_take_value(structure: *mut GstStructure,
                                    fieldname: *const gchar,
                                    value: *mut GValue);
    pub fn gst_structure_set(structure: *mut GstStructure,
                             fieldname: *const gchar, ...);
    pub fn gst_structure_set_valist(structure: *mut GstStructure,
                                    fieldname: *const gchar,
                                    varargs: va_list);
    pub fn gst_structure_id_set(structure: *mut GstStructure,
                                fieldname: GQuark, ...);
    pub fn gst_structure_id_set_valist(structure: *mut GstStructure,
                                       fieldname: GQuark, varargs: va_list);
    pub fn gst_structure_get_valist(structure: *const GstStructure,
                                    first_fieldname: *const ::libc::c_char,
                                    args: va_list) -> gboolean;
    pub fn gst_structure_get(structure: *const GstStructure,
                             first_fieldname: *const ::libc::c_char, ...)
     -> gboolean;
    pub fn gst_structure_id_get_valist(structure: *const GstStructure,
                                       first_field_id: GQuark, args: va_list)
     -> gboolean;
    pub fn gst_structure_id_get(structure: *const GstStructure,
                                first_field_id: GQuark, ...) -> gboolean;
    pub fn gst_structure_id_get_value(structure: *const GstStructure,
                                      field: GQuark) -> *const GValue;
    pub fn gst_structure_get_value(structure: *const GstStructure,
                                   fieldname: *const gchar) -> *const GValue;
    pub fn gst_structure_remove_field(structure: *mut GstStructure,
                                      fieldname: *const gchar);
    pub fn gst_structure_remove_fields(structure: *mut GstStructure,
                                       fieldname: *const gchar, ...);
    pub fn gst_structure_remove_fields_valist(structure: *mut GstStructure,
                                              fieldname: *const gchar,
                                              varargs: va_list);
    pub fn gst_structure_remove_all_fields(structure: *mut GstStructure);
    pub fn gst_structure_get_field_type(structure: *const GstStructure,
                                        fieldname: *const gchar) -> GType;
    pub fn gst_structure_foreach(structure: *const GstStructure,
                                 func: GstStructureForeachFunc,
                                 user_data: gpointer) -> gboolean;
    pub fn gst_structure_map_in_place(structure: *mut GstStructure,
                                      func: GstStructureMapFunc,
                                      user_data: gpointer) -> gboolean;
    pub fn gst_structure_n_fields(structure: *const GstStructure) -> gint;
    pub fn gst_structure_nth_field_name(structure: *const GstStructure,
                                        index: guint) -> *const gchar;
    pub fn gst_structure_id_has_field(structure: *const GstStructure,
                                      field: GQuark) -> gboolean;
    pub fn gst_structure_id_has_field_typed(structure: *const GstStructure,
                                            field: GQuark, _type: GType)
     -> gboolean;
    pub fn gst_structure_has_field(structure: *const GstStructure,
                                   fieldname: *const gchar) -> gboolean;
    pub fn gst_structure_has_field_typed(structure: *const GstStructure,
                                         fieldname: *const gchar,
                                         _type: GType) -> gboolean;
    pub fn gst_structure_get_boolean(structure: *const GstStructure,
                                     fieldname: *const gchar,
                                     value: *mut gboolean) -> gboolean;
    pub fn gst_structure_get_int(structure: *const GstStructure,
                                 fieldname: *const gchar, value: *mut gint)
     -> gboolean;
    pub fn gst_structure_get_uint(structure: *const GstStructure,
                                  fieldname: *const gchar, value: *mut guint)
     -> gboolean;
    pub fn gst_structure_get_int64(structure: *const GstStructure,
                                   fieldname: *const gchar,
                                   value: *mut gint64) -> gboolean;
    pub fn gst_structure_get_uint64(structure: *const GstStructure,
                                    fieldname: *const gchar,
                                    value: *mut guint64) -> gboolean;
    pub fn gst_structure_get_double(structure: *const GstStructure,
                                    fieldname: *const gchar,
                                    value: *mut gdouble) -> gboolean;
    pub fn gst_structure_get_date(structure: *const GstStructure,
                                  fieldname: *const gchar,
                                  value: *mut *mut GDate) -> gboolean;
    pub fn gst_structure_get_date_time(structure: *const GstStructure,
                                       fieldname: *const gchar,
                                       value: *mut *mut GstDateTime)
     -> gboolean;
    pub fn gst_structure_get_clock_time(structure: *const GstStructure,
                                        fieldname: *const gchar,
                                        value: *mut GstClockTime) -> gboolean;
    pub fn gst_structure_get_string(structure: *const GstStructure,
                                    fieldname: *const gchar) -> *const gchar;
    pub fn gst_structure_get_enum(structure: *const GstStructure,
                                  fieldname: *const gchar, enumtype: GType,
                                  value: *mut gint) -> gboolean;
    pub fn gst_structure_get_fraction(structure: *const GstStructure,
                                      fieldname: *const gchar,
                                      value_numerator: *mut gint,
                                      value_denominator: *mut gint)
     -> gboolean;
    pub fn gst_structure_to_string(structure: *const GstStructure)
     -> *mut gchar;
    pub fn gst_structure_from_string(string: *const gchar,
                                     end: *mut *mut gchar)
     -> *mut GstStructure;
    pub fn gst_structure_fixate_field_nearest_int(structure:
                                                      *mut GstStructure,
                                                  field_name:
                                                      *const ::libc::c_char,
                                                  target: ::libc::c_int)
     -> gboolean;
    pub fn gst_structure_fixate_field_nearest_double(structure:
                                                         *mut GstStructure,
                                                     field_name:
                                                         *const ::libc::c_char,
                                                     target: ::libc::c_double)
     -> gboolean;
    pub fn gst_structure_fixate_field_boolean(structure: *mut GstStructure,
                                              field_name:
                                                  *const ::libc::c_char,
                                              target: gboolean) -> gboolean;
    pub fn gst_structure_fixate_field_string(structure: *mut GstStructure,
                                             field_name:
                                                 *const ::libc::c_char,
                                             target: *const gchar)
     -> gboolean;
    pub fn gst_structure_fixate_field_nearest_fraction(structure:
                                                           *mut GstStructure,
                                                       field_name:
                                                           *const ::libc::c_char,
                                                       target_numerator: gint,
                                                       target_denominator:
                                                           gint) -> gboolean;
    pub fn gst_structure_fixate_field(structure: *mut GstStructure,
                                      field_name: *const ::libc::c_char)
     -> gboolean;
    pub fn gst_structure_fixate(structure: *mut GstStructure);
    pub fn gst_structure_is_equal(structure1: *const GstStructure,
                                  structure2: *const GstStructure)
     -> gboolean;
    pub fn gst_structure_is_subset(subset: *const GstStructure,
                                   superset: *const GstStructure) -> gboolean;
    pub fn gst_structure_can_intersect(struct1: *const GstStructure,
                                       struct2: *const GstStructure)
     -> gboolean;
    pub fn gst_structure_intersect(struct1: *const GstStructure,
                                   struct2: *const GstStructure)
     -> *mut GstStructure;
    pub fn gst_caps_features_get_type() -> GType;
    pub fn gst_is_caps_features(obj: gconstpointer) -> gboolean;
    pub fn gst_caps_features_new_empty() -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new_any() -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new(feature1: *const gchar, ...)
     -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new_valist(feature1: *const gchar,
                                        varargs: va_list)
     -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new_id(feature1: GQuark, ...)
     -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new_id_valist(feature1: GQuark, varargs: va_list)
     -> *mut GstCapsFeatures;
    pub fn gst_caps_features_set_parent_refcount(features:
                                                     *mut GstCapsFeatures,
                                                 refcount: *mut gint)
     -> gboolean;
    pub fn gst_caps_features_copy(features: *const GstCapsFeatures)
     -> *mut GstCapsFeatures;
    pub fn gst_caps_features_free(features: *mut GstCapsFeatures);
    pub fn gst_caps_features_to_string(features: *const GstCapsFeatures)
     -> *mut gchar;
    pub fn gst_caps_features_from_string(features: *const gchar)
     -> *mut GstCapsFeatures;
    pub fn gst_caps_features_get_size(features: *const GstCapsFeatures)
     -> guint;
    pub fn gst_caps_features_get_nth(features: *const GstCapsFeatures,
                                     i: guint) -> *const gchar;
    pub fn gst_caps_features_get_nth_id(features: *const GstCapsFeatures,
                                        i: guint) -> GQuark;
    pub fn gst_caps_features_contains(features: *const GstCapsFeatures,
                                      feature: *const gchar) -> gboolean;
    pub fn gst_caps_features_contains_id(features: *const GstCapsFeatures,
                                         feature: GQuark) -> gboolean;
    pub fn gst_caps_features_is_equal(features1: *const GstCapsFeatures,
                                      features2: *const GstCapsFeatures)
     -> gboolean;
    pub fn gst_caps_features_is_any(features: *const GstCapsFeatures)
     -> gboolean;
    pub fn gst_caps_features_add(features: *mut GstCapsFeatures,
                                 feature: *const gchar);
    pub fn gst_caps_features_add_id(features: *mut GstCapsFeatures,
                                    feature: GQuark);
    pub fn gst_caps_features_remove(features: *mut GstCapsFeatures,
                                    feature: *const gchar);
    pub fn gst_caps_features_remove_id(features: *mut GstCapsFeatures,
                                       feature: GQuark);
    pub fn gst_caps_get_type() -> GType;
    pub fn gst_caps_new_empty() -> *mut GstCaps;
    pub fn gst_caps_new_any() -> *mut GstCaps;
    pub fn gst_caps_new_empty_simple(media_type: *const ::libc::c_char)
     -> *mut GstCaps;
    pub fn gst_caps_new_simple(media_type: *const ::libc::c_char,
                               fieldname: *const ::libc::c_char, ...)
     -> *mut GstCaps;
    pub fn gst_caps_new_full(struct1: *mut GstStructure, ...) -> *mut GstCaps;
    pub fn gst_caps_new_full_valist(structure: *mut GstStructure,
                                    var_args: va_list) -> *mut GstCaps;
    pub fn gst_static_caps_get_type() -> GType;
    pub fn gst_static_caps_get(static_caps: *mut GstStaticCaps)
     -> *mut GstCaps;
    pub fn gst_static_caps_cleanup(static_caps: *mut GstStaticCaps);
    pub fn gst_caps_append(caps1: *mut GstCaps, caps2: *mut GstCaps);
    pub fn gst_caps_append_structure(caps: *mut GstCaps,
                                     structure: *mut GstStructure);
    pub fn gst_caps_append_structure_full(caps: *mut GstCaps,
                                          structure: *mut GstStructure,
                                          features: *mut GstCapsFeatures);
    pub fn gst_caps_remove_structure(caps: *mut GstCaps, idx: guint);
    pub fn gst_caps_merge(caps1: *mut GstCaps, caps2: *mut GstCaps)
     -> *mut GstCaps;
    pub fn gst_caps_merge_structure(caps: *mut GstCaps,
                                    structure: *mut GstStructure)
     -> *mut GstCaps;
    pub fn gst_caps_merge_structure_full(caps: *mut GstCaps,
                                         structure: *mut GstStructure,
                                         features: *mut GstCapsFeatures)
     -> *mut GstCaps;
    pub fn gst_caps_get_size(caps: *const GstCaps) -> guint;
    pub fn gst_caps_get_structure(caps: *const GstCaps, index: guint)
     -> *mut GstStructure;
    pub fn gst_caps_steal_structure(caps: *mut GstCaps, index: guint)
     -> *mut GstStructure;
    pub fn gst_caps_set_features(caps: *mut GstCaps, index: guint,
                                 features: *mut GstCapsFeatures);
    pub fn gst_caps_get_features(caps: *const GstCaps, index: guint)
     -> *mut GstCapsFeatures;
    pub fn gst_caps_copy_nth(caps: *const GstCaps, nth: guint)
     -> *mut GstCaps;
    pub fn gst_caps_truncate(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_set_value(caps: *mut GstCaps,
                              field: *const ::libc::c_char,
                              value: *const GValue);
    pub fn gst_caps_set_simple(caps: *mut GstCaps,
                               field: *const ::libc::c_char, ...);
    pub fn gst_caps_set_simple_valist(caps: *mut GstCaps,
                                      field: *const ::libc::c_char,
                                      varargs: va_list);
    pub fn gst_caps_is_any(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_empty(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_fixed(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_always_compatible(caps1: *const GstCaps,
                                         caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset(subset: *const GstCaps,
                              superset: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset_structure(caps: *const GstCaps,
                                        structure: *const GstStructure)
     -> gboolean;
    pub fn gst_caps_is_subset_structure_full(caps: *const GstCaps,
                                             structure: *const GstStructure,
                                             features: *const GstCapsFeatures)
     -> gboolean;
    pub fn gst_caps_is_equal(caps1: *const GstCaps, caps2: *const GstCaps)
     -> gboolean;
    pub fn gst_caps_is_equal_fixed(caps1: *const GstCaps,
                                   caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_can_intersect(caps1: *const GstCaps,
                                  caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_strictly_equal(caps1: *const GstCaps,
                                      caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_intersect(caps1: *mut GstCaps, caps2: *mut GstCaps)
     -> *mut GstCaps;
    pub fn gst_caps_intersect_full(caps1: *mut GstCaps, caps2: *mut GstCaps,
                                   mode: GstCapsIntersectMode)
     -> *mut GstCaps;
    pub fn gst_caps_subtract(minuend: *mut GstCaps, subtrahend: *mut GstCaps)
     -> *mut GstCaps;
    pub fn gst_caps_normalize(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_simplify(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_fixate(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_to_string(caps: *const GstCaps) -> *mut gchar;
    pub fn gst_caps_from_string(string: *const gchar) -> *mut GstCaps;
    pub fn gst_iterator_get_type() -> GType;
    pub fn gst_iterator_new(size: guint, _type: GType, lock: *mut GMutex,
                            master_cookie: *mut guint32,
                            copy: GstIteratorCopyFunction,
                            next: GstIteratorNextFunction,
                            item: GstIteratorItemFunction,
                            resync: GstIteratorResyncFunction,
                            free: GstIteratorFreeFunction)
     -> *mut GstIterator;
    pub fn gst_iterator_new_list(_type: GType, lock: *mut GMutex,
                                 master_cookie: *mut guint32,
                                 list: *mut *mut GList, owner: *mut GObject,
                                 item: GstIteratorItemFunction)
     -> *mut GstIterator;
    pub fn gst_iterator_new_single(_type: GType, object: *const GValue)
     -> *mut GstIterator;
    pub fn gst_iterator_copy(it: *const GstIterator) -> *mut GstIterator;
    pub fn gst_iterator_next(it: *mut GstIterator, elem: *mut GValue)
     -> GstIteratorResult;
    pub fn gst_iterator_resync(it: *mut GstIterator);
    pub fn gst_iterator_free(it: *mut GstIterator);
    pub fn gst_iterator_push(it: *mut GstIterator, other: *mut GstIterator);
    pub fn gst_iterator_filter(it: *mut GstIterator, func: GCompareFunc,
                               user_data: *const GValue) -> *mut GstIterator;
    pub fn gst_iterator_fold(it: *mut GstIterator,
                             func: GstIteratorFoldFunction, ret: *mut GValue,
                             user_data: gpointer) -> GstIteratorResult;
    pub fn gst_iterator_foreach(it: *mut GstIterator,
                                func: GstIteratorForeachFunction,
                                user_data: gpointer) -> GstIteratorResult;
    pub fn gst_iterator_find_custom(it: *mut GstIterator, func: GCompareFunc,
                                    elem: *mut GValue, user_data: gpointer)
     -> gboolean;
    pub fn gst_format_get_name(format: GstFormat) -> *const gchar;
    pub fn gst_format_to_quark(format: GstFormat) -> GQuark;
    pub fn gst_format_register(nick: *const gchar, description: *const gchar)
     -> GstFormat;
    pub fn gst_format_get_by_nick(nick: *const gchar) -> GstFormat;
    pub fn gst_formats_contains(formats: *const GstFormat, format: GstFormat)
     -> gboolean;
    pub fn gst_format_get_details(format: GstFormat)
     -> *const GstFormatDefinition;
    pub fn gst_format_iterate_definitions() -> *mut GstIterator;
    pub fn gst_segment_get_type() -> GType;
    pub fn gst_segment_new() -> *mut GstSegment;
    pub fn gst_segment_copy(segment: *const GstSegment) -> *mut GstSegment;
    pub fn gst_segment_copy_into(src: *const GstSegment,
                                 dest: *mut GstSegment);
    pub fn gst_segment_free(segment: *mut GstSegment);
    pub fn gst_segment_init(segment: *mut GstSegment, format: GstFormat);
    pub fn gst_segment_to_stream_time(segment: *const GstSegment,
                                      format: GstFormat, position: guint64)
     -> guint64;
    pub fn gst_segment_to_running_time(segment: *const GstSegment,
                                       format: GstFormat, position: guint64)
     -> guint64;
    pub fn gst_segment_to_position(segment: *const GstSegment,
                                   format: GstFormat, running_time: guint64)
     -> guint64;
    pub fn gst_segment_set_running_time(segment: *mut GstSegment,
                                        format: GstFormat,
                                        running_time: guint64) -> gboolean;
    pub fn gst_segment_offset_running_time(segment: *mut GstSegment,
                                           format: GstFormat, offset: gint64)
     -> gboolean;
    pub fn gst_segment_clip(segment: *const GstSegment, format: GstFormat,
                            start: guint64, stop: guint64,
                            clip_start: *mut guint64, clip_stop: *mut guint64)
     -> gboolean;
    pub fn gst_segment_do_seek(segment: *mut GstSegment, rate: gdouble,
                               format: GstFormat, flags: GstSeekFlags,
                               start_type: GstSeekType, start: guint64,
                               stop_type: GstSeekType, stop: guint64,
                               update: *mut gboolean) -> gboolean;
    pub fn gst_sample_get_type() -> GType;
    pub fn gst_sample_new(buffer: *mut GstBuffer, caps: *mut GstCaps,
                          segment: *const GstSegment, info: *mut GstStructure)
     -> *mut GstSample;
    pub fn gst_sample_get_buffer(sample: *mut GstSample) -> *mut GstBuffer;
    pub fn gst_sample_get_caps(sample: *mut GstSample) -> *mut GstCaps;
    pub fn gst_sample_get_segment(sample: *mut GstSample) -> *mut GstSegment;
    pub fn gst_sample_get_info(sample: *mut GstSample) -> *const GstStructure;
    pub fn gst_tag_list_get_type() -> GType;
    pub fn gst_tag_register(name: *const gchar, flag: GstTagFlag,
                            _type: GType, nick: *const gchar,
                            blurb: *const gchar, func: GstTagMergeFunc);
    pub fn gst_tag_register_static(name: *const gchar, flag: GstTagFlag,
                                   _type: GType, nick: *const gchar,
                                   blurb: *const gchar,
                                   func: GstTagMergeFunc);
    pub fn gst_tag_merge_use_first(dest: *mut GValue, src: *const GValue);
    pub fn gst_tag_merge_strings_with_comma(dest: *mut GValue,
                                            src: *const GValue);
    pub fn gst_tag_exists(tag: *const gchar) -> gboolean;
    pub fn gst_tag_get_type(tag: *const gchar) -> GType;
    pub fn gst_tag_get_nick(tag: *const gchar) -> *const gchar;
    pub fn gst_tag_get_description(tag: *const gchar) -> *const gchar;
    pub fn gst_tag_get_flag(tag: *const gchar) -> GstTagFlag;
    pub fn gst_tag_is_fixed(tag: *const gchar) -> gboolean;
    pub fn gst_tag_list_new_empty() -> *mut GstTagList;
    pub fn gst_tag_list_new(tag: *const gchar, ...) -> *mut GstTagList;
    pub fn gst_tag_list_new_valist(var_args: va_list) -> *mut GstTagList;
    pub fn gst_tag_list_set_scope(list: *mut GstTagList, scope: GstTagScope);
    pub fn gst_tag_list_get_scope(list: *const GstTagList) -> GstTagScope;
    pub fn gst_tag_list_to_string(list: *const GstTagList) -> *mut gchar;
    pub fn gst_tag_list_new_from_string(str: *const gchar) -> *mut GstTagList;
    pub fn gst_tag_list_n_tags(list: *const GstTagList) -> gint;
    pub fn gst_tag_list_nth_tag_name(list: *const GstTagList, index: guint)
     -> *const gchar;
    pub fn gst_tag_list_is_empty(list: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_is_equal(list1: *const GstTagList,
                                 list2: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_insert(into: *mut GstTagList, from: *const GstTagList,
                               mode: GstTagMergeMode);
    pub fn gst_tag_list_merge(list1: *const GstTagList,
                              list2: *const GstTagList, mode: GstTagMergeMode)
     -> *mut GstTagList;
    pub fn gst_tag_list_get_tag_size(list: *const GstTagList,
                                     tag: *const gchar) -> guint;
    pub fn gst_tag_list_add(list: *mut GstTagList, mode: GstTagMergeMode,
                            tag: *const gchar, ...);
    pub fn gst_tag_list_add_values(list: *mut GstTagList,
                                   mode: GstTagMergeMode,
                                   tag: *const gchar, ...);
    pub fn gst_tag_list_add_valist(list: *mut GstTagList,
                                   mode: GstTagMergeMode, tag: *const gchar,
                                   var_args: va_list);
    pub fn gst_tag_list_add_valist_values(list: *mut GstTagList,
                                          mode: GstTagMergeMode,
                                          tag: *const gchar,
                                          var_args: va_list);
    pub fn gst_tag_list_add_value(list: *mut GstTagList,
                                  mode: GstTagMergeMode, tag: *const gchar,
                                  value: *const GValue);
    pub fn gst_tag_list_remove_tag(list: *mut GstTagList, tag: *const gchar);
    pub fn gst_tag_list_foreach(list: *const GstTagList,
                                func: GstTagForeachFunc, user_data: gpointer);
    pub fn gst_tag_list_get_value_index(list: *const GstTagList,
                                        tag: *const gchar, index: guint)
     -> *const GValue;
    pub fn gst_tag_list_copy_value(dest: *mut GValue, list: *const GstTagList,
                                   tag: *const gchar) -> gboolean;
    pub fn gst_tag_list_get_boolean(list: *const GstTagList,
                                    tag: *const gchar, value: *mut gboolean)
     -> gboolean;
    pub fn gst_tag_list_get_boolean_index(list: *const GstTagList,
                                          tag: *const gchar, index: guint,
                                          value: *mut gboolean) -> gboolean;
    pub fn gst_tag_list_get_int(list: *const GstTagList, tag: *const gchar,
                                value: *mut gint) -> gboolean;
    pub fn gst_tag_list_get_int_index(list: *const GstTagList,
                                      tag: *const gchar, index: guint,
                                      value: *mut gint) -> gboolean;
    pub fn gst_tag_list_get_uint(list: *const GstTagList, tag: *const gchar,
                                 value: *mut guint) -> gboolean;
    pub fn gst_tag_list_get_uint_index(list: *const GstTagList,
                                       tag: *const gchar, index: guint,
                                       value: *mut guint) -> gboolean;
    pub fn gst_tag_list_get_int64(list: *const GstTagList, tag: *const gchar,
                                  value: *mut gint64) -> gboolean;
    pub fn gst_tag_list_get_int64_index(list: *const GstTagList,
                                        tag: *const gchar, index: guint,
                                        value: *mut gint64) -> gboolean;
    pub fn gst_tag_list_get_uint64(list: *const GstTagList, tag: *const gchar,
                                   value: *mut guint64) -> gboolean;
    pub fn gst_tag_list_get_uint64_index(list: *const GstTagList,
                                         tag: *const gchar, index: guint,
                                         value: *mut guint64) -> gboolean;
    pub fn gst_tag_list_get_float(list: *const GstTagList, tag: *const gchar,
                                  value: *mut gfloat) -> gboolean;
    pub fn gst_tag_list_get_float_index(list: *const GstTagList,
                                        tag: *const gchar, index: guint,
                                        value: *mut gfloat) -> gboolean;
    pub fn gst_tag_list_get_double(list: *const GstTagList, tag: *const gchar,
                                   value: *mut gdouble) -> gboolean;
    pub fn gst_tag_list_get_double_index(list: *const GstTagList,
                                         tag: *const gchar, index: guint,
                                         value: *mut gdouble) -> gboolean;
    pub fn gst_tag_list_get_string(list: *const GstTagList, tag: *const gchar,
                                   value: *mut *mut gchar) -> gboolean;
    pub fn gst_tag_list_get_string_index(list: *const GstTagList,
                                         tag: *const gchar, index: guint,
                                         value: *mut *mut gchar) -> gboolean;
    pub fn gst_tag_list_peek_string_index(list: *const GstTagList,
                                          tag: *const gchar, index: guint,
                                          value: *mut *const gchar)
     -> gboolean;
    pub fn gst_tag_list_get_pointer(list: *const GstTagList,
                                    tag: *const gchar, value: *mut gpointer)
     -> gboolean;
    pub fn gst_tag_list_get_pointer_index(list: *const GstTagList,
                                          tag: *const gchar, index: guint,
                                          value: *mut gpointer) -> gboolean;
    pub fn gst_tag_list_get_date(list: *const GstTagList, tag: *const gchar,
                                 value: *mut *mut GDate) -> gboolean;
    pub fn gst_tag_list_get_date_index(list: *const GstTagList,
                                       tag: *const gchar, index: guint,
                                       value: *mut *mut GDate) -> gboolean;
    pub fn gst_tag_list_get_date_time(list: *const GstTagList,
                                      tag: *const gchar,
                                      value: *mut *mut GstDateTime)
     -> gboolean;
    pub fn gst_tag_list_get_date_time_index(list: *const GstTagList,
                                            tag: *const gchar, index: guint,
                                            value: *mut *mut GstDateTime)
     -> gboolean;
    pub fn gst_tag_list_get_sample(list: *const GstTagList, tag: *const gchar,
                                   sample: *mut *mut GstSample) -> gboolean;
    pub fn gst_tag_list_get_sample_index(list: *const GstTagList,
                                         tag: *const gchar, index: guint,
                                         sample: *mut *mut GstSample)
     -> gboolean;
    pub fn gst_toc_get_type() -> GType;
    pub fn gst_toc_entry_get_type() -> GType;
    pub fn gst_toc_new(scope: GstTocScope) -> *mut GstToc;
    pub fn gst_toc_get_scope(toc: *const GstToc) -> GstTocScope;
    pub fn gst_toc_set_tags(toc: *mut GstToc, tags: *mut GstTagList);
    pub fn gst_toc_merge_tags(toc: *mut GstToc, tags: *mut GstTagList,
                              mode: GstTagMergeMode);
    pub fn gst_toc_get_tags(toc: *const GstToc) -> *mut GstTagList;
    pub fn gst_toc_append_entry(toc: *mut GstToc, entry: *mut GstTocEntry);
    pub fn gst_toc_get_entries(toc: *const GstToc) -> *mut GList;
    pub fn gst_toc_dump(toc: *mut GstToc);
    pub fn gst_toc_entry_new(_type: GstTocEntryType, uid: *const gchar)
     -> *mut GstTocEntry;
    pub fn gst_toc_find_entry(toc: *const GstToc, uid: *const gchar)
     -> *mut GstTocEntry;
    pub fn gst_toc_entry_get_entry_type(entry: *const GstTocEntry)
     -> GstTocEntryType;
    pub fn gst_toc_entry_get_uid(entry: *const GstTocEntry) -> *const gchar;
    pub fn gst_toc_entry_append_sub_entry(entry: *mut GstTocEntry,
                                          subentry: *mut GstTocEntry);
    pub fn gst_toc_entry_get_sub_entries(entry: *const GstTocEntry)
     -> *mut GList;
    pub fn gst_toc_entry_set_tags(entry: *mut GstTocEntry,
                                  tags: *mut GstTagList);
    pub fn gst_toc_entry_merge_tags(entry: *mut GstTocEntry,
                                    tags: *mut GstTagList,
                                    mode: GstTagMergeMode);
    pub fn gst_toc_entry_get_tags(entry: *const GstTocEntry)
     -> *mut GstTagList;
    pub fn gst_toc_entry_is_alternative(entry: *const GstTocEntry)
     -> gboolean;
    pub fn gst_toc_entry_is_sequence(entry: *const GstTocEntry) -> gboolean;
    pub fn gst_toc_entry_set_start_stop_times(entry: *mut GstTocEntry,
                                              start: gint64, stop: gint64);
    pub fn gst_toc_entry_get_start_stop_times(entry: *const GstTocEntry,
                                              start: *mut gint64,
                                              stop: *mut gint64) -> gboolean;
    pub fn gst_toc_entry_set_loop(entry: *mut GstTocEntry,
                                  loop_type: GstTocLoopType,
                                  repeat_count: gint);
    pub fn gst_toc_entry_get_loop(entry: *const GstTocEntry,
                                  loop_type: *mut GstTocLoopType,
                                  repeat_count: *mut gint) -> gboolean;
    pub fn gst_toc_entry_get_toc(entry: *mut GstTocEntry) -> *mut GstToc;
    pub fn gst_toc_entry_get_parent(entry: *mut GstTocEntry)
     -> *mut GstTocEntry;
    pub fn gst_toc_entry_type_get_nick(_type: GstTocEntryType)
     -> *const gchar;
    pub fn gst_context_get_type() -> GType;
    pub fn gst_context_new(context_type: *const gchar, persistent: gboolean)
     -> *mut GstContext;
    pub fn gst_context_get_context_type(context: *const GstContext)
     -> *const gchar;
    pub fn gst_context_has_context_type(context: *const GstContext,
                                        context_type: *const gchar)
     -> gboolean;
    pub fn gst_context_get_structure(context: *const GstContext)
     -> *const GstStructure;
    pub fn gst_context_writable_structure(context: *mut GstContext)
     -> *mut GstStructure;
    pub fn gst_context_is_persistent(context: *const GstContext) -> gboolean;
    pub fn gst_query_type_get_name(_type: GstQueryType) -> *const gchar;
    pub fn gst_query_type_to_quark(_type: GstQueryType) -> GQuark;
    pub fn gst_query_type_get_flags(_type: GstQueryType) -> GstQueryTypeFlags;
    pub fn gst_query_get_type() -> GType;
    pub fn gst_query_new_custom(_type: GstQueryType,
                                structure: *mut GstStructure)
     -> *mut GstQuery;
    pub fn gst_query_get_structure(query: *mut GstQuery)
     -> *const GstStructure;
    pub fn gst_query_writable_structure(query: *mut GstQuery)
     -> *mut GstStructure;
    pub fn gst_query_new_position(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_set_position(query: *mut GstQuery, format: GstFormat,
                                  cur: gint64);
    pub fn gst_query_parse_position(query: *mut GstQuery,
                                    format: *mut GstFormat, cur: *mut gint64);
    pub fn gst_query_new_duration(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_set_duration(query: *mut GstQuery, format: GstFormat,
                                  duration: gint64);
    pub fn gst_query_parse_duration(query: *mut GstQuery,
                                    format: *mut GstFormat,
                                    duration: *mut gint64);
    pub fn gst_query_new_latency() -> *mut GstQuery;
    pub fn gst_query_set_latency(query: *mut GstQuery, live: gboolean,
                                 min_latency: GstClockTime,
                                 max_latency: GstClockTime);
    pub fn gst_query_parse_latency(query: *mut GstQuery, live: *mut gboolean,
                                   min_latency: *mut GstClockTime,
                                   max_latency: *mut GstClockTime);
    pub fn gst_query_new_convert(src_format: GstFormat, value: gint64,
                                 dest_format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_set_convert(query: *mut GstQuery, src_format: GstFormat,
                                 src_value: gint64, dest_format: GstFormat,
                                 dest_value: gint64);
    pub fn gst_query_parse_convert(query: *mut GstQuery,
                                   src_format: *mut GstFormat,
                                   src_value: *mut gint64,
                                   dest_format: *mut GstFormat,
                                   dest_value: *mut gint64);
    pub fn gst_query_new_segment(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_set_segment(query: *mut GstQuery, rate: gdouble,
                                 format: GstFormat, start_value: gint64,
                                 stop_value: gint64);
    pub fn gst_query_parse_segment(query: *mut GstQuery, rate: *mut gdouble,
                                   format: *mut GstFormat,
                                   start_value: *mut gint64,
                                   stop_value: *mut gint64);
    pub fn gst_query_new_seeking(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_set_seeking(query: *mut GstQuery, format: GstFormat,
                                 seekable: gboolean, segment_start: gint64,
                                 segment_end: gint64);
    pub fn gst_query_parse_seeking(query: *mut GstQuery,
                                   format: *mut GstFormat,
                                   seekable: *mut gboolean,
                                   segment_start: *mut gint64,
                                   segment_end: *mut gint64);
    pub fn gst_query_new_formats() -> *mut GstQuery;
    pub fn gst_query_set_formats(query: *mut GstQuery, n_formats: gint, ...);
    pub fn gst_query_set_formatsv(query: *mut GstQuery, n_formats: gint,
                                  formats: *const GstFormat);
    pub fn gst_query_parse_n_formats(query: *mut GstQuery,
                                     n_formats: *mut guint);
    pub fn gst_query_parse_nth_format(query: *mut GstQuery, nth: guint,
                                      format: *mut GstFormat);
    pub fn gst_query_new_buffering(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_set_buffering_percent(query: *mut GstQuery,
                                           busy: gboolean, percent: gint);
    pub fn gst_query_parse_buffering_percent(query: *mut GstQuery,
                                             busy: *mut gboolean,
                                             percent: *mut gint);
    pub fn gst_query_set_buffering_stats(query: *mut GstQuery,
                                         mode: GstBufferingMode, avg_in: gint,
                                         avg_out: gint,
                                         buffering_left: gint64);
    pub fn gst_query_parse_buffering_stats(query: *mut GstQuery,
                                           mode: *mut GstBufferingMode,
                                           avg_in: *mut gint,
                                           avg_out: *mut gint,
                                           buffering_left: *mut gint64);
    pub fn gst_query_set_buffering_range(query: *mut GstQuery,
                                         format: GstFormat, start: gint64,
                                         stop: gint64,
                                         estimated_total: gint64);
    pub fn gst_query_parse_buffering_range(query: *mut GstQuery,
                                           format: *mut GstFormat,
                                           start: *mut gint64,
                                           stop: *mut gint64,
                                           estimated_total: *mut gint64);
    pub fn gst_query_add_buffering_range(query: *mut GstQuery, start: gint64,
                                         stop: gint64) -> gboolean;
    pub fn gst_query_get_n_buffering_ranges(query: *mut GstQuery) -> guint;
    pub fn gst_query_parse_nth_buffering_range(query: *mut GstQuery,
                                               index: guint,
                                               start: *mut gint64,
                                               stop: *mut gint64) -> gboolean;
    pub fn gst_query_new_uri() -> *mut GstQuery;
    pub fn gst_query_parse_uri(query: *mut GstQuery, uri: *mut *mut gchar);
    pub fn gst_query_set_uri(query: *mut GstQuery, uri: *const gchar);
    pub fn gst_query_parse_uri_redirection(query: *mut GstQuery,
                                           uri: *mut *mut gchar);
    pub fn gst_query_set_uri_redirection(query: *mut GstQuery,
                                         uri: *const gchar);
    pub fn gst_query_parse_uri_redirection_permanent(query: *mut GstQuery,
                                                     permanent:
                                                         *mut gboolean);
    pub fn gst_query_set_uri_redirection_permanent(query: *mut GstQuery,
                                                   permanent: gboolean);
    pub fn gst_query_new_allocation(caps: *mut GstCaps, need_pool: gboolean)
     -> *mut GstQuery;
    pub fn gst_query_parse_allocation(query: *mut GstQuery,
                                      caps: *mut *mut GstCaps,
                                      need_pool: *mut gboolean);
    pub fn gst_query_add_allocation_pool(query: *mut GstQuery,
                                         pool: *mut GstBufferPool,
                                         size: guint, min_buffers: guint,
                                         max_buffers: guint);
    pub fn gst_query_get_n_allocation_pools(query: *mut GstQuery) -> guint;
    pub fn gst_query_parse_nth_allocation_pool(query: *mut GstQuery,
                                               index: guint,
                                               pool: *mut *mut GstBufferPool,
                                               size: *mut guint,
                                               min_buffers: *mut guint,
                                               max_buffers: *mut guint);
    pub fn gst_query_set_nth_allocation_pool(query: *mut GstQuery,
                                             index: guint,
                                             pool: *mut GstBufferPool,
                                             size: guint, min_buffers: guint,
                                             max_buffers: guint);
    pub fn gst_query_remove_nth_allocation_pool(query: *mut GstQuery,
                                                index: guint);
    pub fn gst_query_add_allocation_param(query: *mut GstQuery,
                                          allocator: *mut GstAllocator,
                                          params: *const GstAllocationParams);
    pub fn gst_query_get_n_allocation_params(query: *mut GstQuery) -> guint;
    pub fn gst_query_parse_nth_allocation_param(query: *mut GstQuery,
                                                index: guint,
                                                allocator:
                                                    *mut *mut GstAllocator,
                                                params:
                                                    *mut GstAllocationParams);
    pub fn gst_query_set_nth_allocation_param(query: *mut GstQuery,
                                              index: guint,
                                              allocator: *mut GstAllocator,
                                              params:
                                                  *const GstAllocationParams);
    pub fn gst_query_remove_nth_allocation_param(query: *mut GstQuery,
                                                 index: guint);
    pub fn gst_query_add_allocation_meta(query: *mut GstQuery, api: GType,
                                         params: *const GstStructure);
    pub fn gst_query_get_n_allocation_metas(query: *mut GstQuery) -> guint;
    pub fn gst_query_parse_nth_allocation_meta(query: *mut GstQuery,
                                               index: guint,
                                               params:
                                                   *mut *const GstStructure)
     -> GType;
    pub fn gst_query_remove_nth_allocation_meta(query: *mut GstQuery,
                                                index: guint);
    pub fn gst_query_find_allocation_meta(query: *mut GstQuery, api: GType,
                                          index: *mut guint) -> gboolean;
    pub fn gst_query_new_scheduling() -> *mut GstQuery;
    pub fn gst_query_set_scheduling(query: *mut GstQuery,
                                    flags: GstSchedulingFlags, minsize: gint,
                                    maxsize: gint, align: gint);
    pub fn gst_query_parse_scheduling(query: *mut GstQuery,
                                      flags: *mut GstSchedulingFlags,
                                      minsize: *mut gint, maxsize: *mut gint,
                                      align: *mut gint);
    pub fn gst_query_add_scheduling_mode(query: *mut GstQuery,
                                         mode: GstPadMode);
    pub fn gst_query_get_n_scheduling_modes(query: *mut GstQuery) -> guint;
    pub fn gst_query_parse_nth_scheduling_mode(query: *mut GstQuery,
                                               index: guint) -> GstPadMode;
    pub fn gst_query_has_scheduling_mode(query: *mut GstQuery,
                                         mode: GstPadMode) -> gboolean;
    pub fn gst_query_has_scheduling_mode_with_flags(query: *mut GstQuery,
                                                    mode: GstPadMode,
                                                    flags: GstSchedulingFlags)
     -> gboolean;
    pub fn gst_query_new_accept_caps(caps: *mut GstCaps) -> *mut GstQuery;
    pub fn gst_query_parse_accept_caps(query: *mut GstQuery,
                                       caps: *mut *mut GstCaps);
    pub fn gst_query_set_accept_caps_result(query: *mut GstQuery,
                                            result: gboolean);
    pub fn gst_query_parse_accept_caps_result(query: *mut GstQuery,
                                              result: *mut gboolean);
    pub fn gst_query_new_caps(filter: *mut GstCaps) -> *mut GstQuery;
    pub fn gst_query_parse_caps(query: *mut GstQuery,
                                filter: *mut *mut GstCaps);
    pub fn gst_query_set_caps_result(query: *mut GstQuery,
                                     caps: *mut GstCaps);
    pub fn gst_query_parse_caps_result(query: *mut GstQuery,
                                       caps: *mut *mut GstCaps);
    pub fn gst_query_new_drain() -> *mut GstQuery;
    pub fn gst_query_new_context(context_type: *const gchar) -> *mut GstQuery;
    pub fn gst_query_parse_context_type(query: *mut GstQuery,
                                        context_type: *mut *const gchar)
     -> gboolean;
    pub fn gst_query_set_context(query: *mut GstQuery,
                                 context: *mut GstContext);
    pub fn gst_query_parse_context(query: *mut GstQuery,
                                   context: *mut *mut GstContext);
    pub fn gst_device_get_type() -> GType;
    pub fn gst_device_create_element(device: *mut GstDevice,
                                     name: *const gchar) -> *mut GstElement;
    pub fn gst_device_get_caps(device: *mut GstDevice) -> *mut GstCaps;
    pub fn gst_device_get_display_name(device: *mut GstDevice) -> *mut gchar;
    pub fn gst_device_get_device_class(device: *mut GstDevice) -> *mut gchar;
    pub fn gst_device_reconfigure_element(device: *mut GstDevice,
                                          element: *mut GstElement)
     -> gboolean;
    pub fn gst_device_has_classesv(device: *mut GstDevice,
                                   classes: *mut *mut gchar) -> gboolean;
    pub fn gst_device_has_classes(device: *mut GstDevice,
                                  classes: *const gchar) -> gboolean;
    pub fn gst_message_get_type() -> GType;
    pub fn gst_message_type_get_name(_type: GstMessageType) -> *const gchar;
    pub fn gst_message_type_to_quark(_type: GstMessageType) -> GQuark;
    pub fn gst_message_new_custom(_type: GstMessageType, src: *mut GstObject,
                                  structure: *mut GstStructure)
     -> *mut GstMessage;
    pub fn gst_message_get_structure(message: *mut GstMessage)
     -> *const GstStructure;
    pub fn gst_message_has_name(message: *mut GstMessage, name: *const gchar)
     -> gboolean;
    pub fn gst_message_get_seqnum(message: *mut GstMessage) -> guint32;
    pub fn gst_message_set_seqnum(message: *mut GstMessage, seqnum: guint32);
    pub fn gst_message_new_eos(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_error(src: *mut GstObject, error: *mut GError,
                                 debug: *const gchar) -> *mut GstMessage;
    pub fn gst_message_parse_error(message: *mut GstMessage,
                                   gerror: *mut *mut GError,
                                   debug: *mut *mut gchar);
    pub fn gst_message_new_warning(src: *mut GstObject, error: *mut GError,
                                   debug: *const gchar) -> *mut GstMessage;
    pub fn gst_message_parse_warning(message: *mut GstMessage,
                                     gerror: *mut *mut GError,
                                     debug: *mut *mut gchar);
    pub fn gst_message_new_info(src: *mut GstObject, error: *mut GError,
                                debug: *const gchar) -> *mut GstMessage;
    pub fn gst_message_parse_info(message: *mut GstMessage,
                                  gerror: *mut *mut GError,
                                  debug: *mut *mut gchar);
    pub fn gst_message_new_tag(src: *mut GstObject, tag_list: *mut GstTagList)
     -> *mut GstMessage;
    pub fn gst_message_parse_tag(message: *mut GstMessage,
                                 tag_list: *mut *mut GstTagList);
    pub fn gst_message_new_buffering(src: *mut GstObject, percent: gint)
     -> *mut GstMessage;
    pub fn gst_message_parse_buffering(message: *mut GstMessage,
                                       percent: *mut gint);
    pub fn gst_message_set_buffering_stats(message: *mut GstMessage,
                                           mode: GstBufferingMode,
                                           avg_in: gint, avg_out: gint,
                                           buffering_left: gint64);
    pub fn gst_message_parse_buffering_stats(message: *mut GstMessage,
                                             mode: *mut GstBufferingMode,
                                             avg_in: *mut gint,
                                             avg_out: *mut gint,
                                             buffering_left: *mut gint64);
    pub fn gst_message_new_state_changed(src: *mut GstObject,
                                         oldstate: GstState,
                                         newstate: GstState,
                                         pending: GstState)
     -> *mut GstMessage;
    pub fn gst_message_parse_state_changed(message: *mut GstMessage,
                                           oldstate: *mut GstState,
                                           newstate: *mut GstState,
                                           pending: *mut GstState);
    pub fn gst_message_new_state_dirty(src: *mut GstObject)
     -> *mut GstMessage;
    pub fn gst_message_new_step_done(src: *mut GstObject, format: GstFormat,
                                     amount: guint64, rate: gdouble,
                                     flush: gboolean, intermediate: gboolean,
                                     duration: guint64, eos: gboolean)
     -> *mut GstMessage;
    pub fn gst_message_parse_step_done(message: *mut GstMessage,
                                       format: *mut GstFormat,
                                       amount: *mut guint64,
                                       rate: *mut gdouble,
                                       flush: *mut gboolean,
                                       intermediate: *mut gboolean,
                                       duration: *mut guint64,
                                       eos: *mut gboolean);
    pub fn gst_message_new_clock_provide(src: *mut GstObject,
                                         clock: *mut GstClock,
                                         ready: gboolean) -> *mut GstMessage;
    pub fn gst_message_parse_clock_provide(message: *mut GstMessage,
                                           clock: *mut *mut GstClock,
                                           ready: *mut gboolean);
    pub fn gst_message_new_clock_lost(src: *mut GstObject,
                                      clock: *mut GstClock)
     -> *mut GstMessage;
    pub fn gst_message_parse_clock_lost(message: *mut GstMessage,
                                        clock: *mut *mut GstClock);
    pub fn gst_message_new_new_clock(src: *mut GstObject,
                                     clock: *mut GstClock) -> *mut GstMessage;
    pub fn gst_message_parse_new_clock(message: *mut GstMessage,
                                       clock: *mut *mut GstClock);
    pub fn gst_message_new_application(src: *mut GstObject,
                                       structure: *mut GstStructure)
     -> *mut GstMessage;
    pub fn gst_message_new_element(src: *mut GstObject,
                                   structure: *mut GstStructure)
     -> *mut GstMessage;
    pub fn gst_message_new_segment_start(src: *mut GstObject,
                                         format: GstFormat, position: gint64)
     -> *mut GstMessage;
    pub fn gst_message_parse_segment_start(message: *mut GstMessage,
                                           format: *mut GstFormat,
                                           position: *mut gint64);
    pub fn gst_message_new_segment_done(src: *mut GstObject,
                                        format: GstFormat, position: gint64)
     -> *mut GstMessage;
    pub fn gst_message_parse_segment_done(message: *mut GstMessage,
                                          format: *mut GstFormat,
                                          position: *mut gint64);
    pub fn gst_message_new_duration_changed(src: *mut GstObject)
     -> *mut GstMessage;
    pub fn gst_message_new_latency(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_async_start(src: *mut GstObject)
     -> *mut GstMessage;
    pub fn gst_message_new_async_done(src: *mut GstObject,
                                      running_time: GstClockTime)
     -> *mut GstMessage;
    pub fn gst_message_parse_async_done(message: *mut GstMessage,
                                        running_time: *mut GstClockTime);
    pub fn gst_message_new_structure_change(src: *mut GstObject,
                                            _type: GstStructureChangeType,
                                            owner: *mut GstElement,
                                            busy: gboolean)
     -> *mut GstMessage;
    pub fn gst_message_parse_structure_change(message: *mut GstMessage,
                                              _type:
                                                  *mut GstStructureChangeType,
                                              owner: *mut *mut GstElement,
                                              busy: *mut gboolean);
    pub fn gst_message_new_stream_status(src: *mut GstObject,
                                         _type: GstStreamStatusType,
                                         owner: *mut GstElement)
     -> *mut GstMessage;
    pub fn gst_message_parse_stream_status(message: *mut GstMessage,
                                           _type: *mut GstStreamStatusType,
                                           owner: *mut *mut GstElement);
    pub fn gst_message_set_stream_status_object(message: *mut GstMessage,
                                                object: *const GValue);
    pub fn gst_message_get_stream_status_object(message: *mut GstMessage)
     -> *const GValue;
    pub fn gst_message_new_request_state(src: *mut GstObject, state: GstState)
     -> *mut GstMessage;
    pub fn gst_message_parse_request_state(message: *mut GstMessage,
                                           state: *mut GstState);
    pub fn gst_message_new_step_start(src: *mut GstObject, active: gboolean,
                                      format: GstFormat, amount: guint64,
                                      rate: gdouble, flush: gboolean,
                                      intermediate: gboolean)
     -> *mut GstMessage;
    pub fn gst_message_parse_step_start(message: *mut GstMessage,
                                        active: *mut gboolean,
                                        format: *mut GstFormat,
                                        amount: *mut guint64,
                                        rate: *mut gdouble,
                                        flush: *mut gboolean,
                                        intermediate: *mut gboolean);
    pub fn gst_message_new_qos(src: *mut GstObject, live: gboolean,
                               running_time: guint64, stream_time: guint64,
                               timestamp: guint64, duration: guint64)
     -> *mut GstMessage;
    pub fn gst_message_copy (msg: *const GstMessage) -> *mut GstMessage;
    pub fn gst_message_set_qos_values(message: *mut GstMessage,
                                      jitter: gint64, proportion: gdouble,
                                      quality: gint);
    pub fn gst_message_set_qos_stats(message: *mut GstMessage,
                                     format: GstFormat, processed: guint64,
                                     dropped: guint64);
    pub fn gst_message_parse_qos(message: *mut GstMessage,
                                 live: *mut gboolean,
                                 running_time: *mut guint64,
                                 stream_time: *mut guint64,
                                 timestamp: *mut guint64,
                                 duration: *mut guint64);
    pub fn gst_message_parse_qos_values(message: *mut GstMessage,
                                        jitter: *mut gint64,
                                        proportion: *mut gdouble,
                                        quality: *mut gint);
    pub fn gst_message_parse_qos_stats(message: *mut GstMessage,
                                       format: *mut GstFormat,
                                       processed: *mut guint64,
                                       dropped: *mut guint64);
    pub fn gst_message_new_progress(src: *mut GstObject,
                                    _type: GstProgressType,
                                    code: *const gchar, text: *const gchar)
     -> *mut GstMessage;
    pub fn gst_message_parse_progress(message: *mut GstMessage,
                                      _type: *mut GstProgressType,
                                      code: *mut *mut gchar,
                                      text: *mut *mut gchar);
    pub fn gst_message_new_toc(src: *mut GstObject, toc: *mut GstToc,
                               updated: gboolean) -> *mut GstMessage;
    pub fn gst_message_parse_toc(message: *mut GstMessage,
                                 toc: *mut *mut GstToc,
                                 updated: *mut gboolean);
    pub fn gst_message_new_reset_time(src: *mut GstObject,
                                      running_time: GstClockTime)
     -> *mut GstMessage;
    pub fn gst_message_parse_reset_time(message: *mut GstMessage,
                                        running_time: *mut GstClockTime);
    pub fn gst_message_new_stream_start(src: *mut GstObject)
     -> *mut GstMessage;
    pub fn gst_message_set_group_id(message: *mut GstMessage,
                                    group_id: guint);
    pub fn gst_message_parse_group_id(message: *mut GstMessage,
                                      group_id: *mut guint) -> gboolean;
    pub fn gst_message_new_need_context(src: *mut GstObject,
                                        context_type: *const gchar)
     -> *mut GstMessage;
    pub fn gst_message_parse_context_type(message: *mut GstMessage,
                                          context_type: *mut *const gchar)
     -> gboolean;
    pub fn gst_message_new_have_context(src: *mut GstObject,
                                        context: *mut GstContext)
     -> *mut GstMessage;
    pub fn gst_message_parse_have_context(message: *mut GstMessage,
                                          context: *mut *mut GstContext);
    pub fn gst_message_new_device_added(src: *mut GstObject,
                                        device: *mut GstDevice)
     -> *mut GstMessage;
    pub fn gst_message_parse_device_added(message: *mut GstMessage,
                                          device: *mut *mut GstDevice);
    pub fn gst_message_new_device_removed(src: *mut GstObject,
                                          device: *mut GstDevice)
     -> *mut GstMessage;
    pub fn gst_message_parse_device_removed(message: *mut GstMessage,
                                            device: *mut *mut GstDevice);
    pub fn gst_event_type_get_name(_type: GstEventType) -> *const gchar;
    pub fn gst_event_type_to_quark(_type: GstEventType) -> GQuark;
    pub fn gst_event_type_get_flags(_type: GstEventType) -> GstEventTypeFlags;
    pub fn gst_event_get_type() -> GType;
    pub fn gst_event_new_custom(_type: GstEventType,
                                structure: *mut GstStructure)
     -> *mut GstEvent;
    pub fn gst_event_get_structure(event: *mut GstEvent)
     -> *const GstStructure;
    pub fn gst_event_writable_structure(event: *mut GstEvent)
     -> *mut GstStructure;
    pub fn gst_event_has_name(event: *mut GstEvent, name: *const gchar)
     -> gboolean;
    pub fn gst_event_get_seqnum(event: *mut GstEvent) -> guint32;
    pub fn gst_event_set_seqnum(event: *mut GstEvent, seqnum: guint32);
    pub fn gst_event_get_running_time_offset(event: *mut GstEvent) -> gint64;
    pub fn gst_event_set_running_time_offset(event: *mut GstEvent,
                                             offset: gint64);
    pub fn gst_event_new_stream_start(stream_id: *const gchar)
     -> *mut GstEvent;
    pub fn gst_event_parse_stream_start(event: *mut GstEvent,
                                        stream_id: *mut *const gchar);
    pub fn gst_event_set_stream_flags(event: *mut GstEvent,
                                      flags: GstStreamFlags);
    pub fn gst_event_parse_stream_flags(event: *mut GstEvent,
                                        flags: *mut GstStreamFlags);
    pub fn gst_event_set_group_id(event: *mut GstEvent, group_id: guint);
    pub fn gst_event_parse_group_id(event: *mut GstEvent,
                                    group_id: *mut guint) -> gboolean;
    pub fn gst_event_new_flush_start() -> *mut GstEvent;
    pub fn gst_event_new_flush_stop(reset_time: gboolean) -> *mut GstEvent;
    pub fn gst_event_parse_flush_stop(event: *mut GstEvent,
                                      reset_time: *mut gboolean);
    pub fn gst_event_new_eos() -> *mut GstEvent;
    pub fn gst_event_new_gap(timestamp: GstClockTime, duration: GstClockTime)
     -> *mut GstEvent;
    pub fn gst_event_parse_gap(event: *mut GstEvent,
                               timestamp: *mut GstClockTime,
                               duration: *mut GstClockTime);
    pub fn gst_event_new_caps(caps: *mut GstCaps) -> *mut GstEvent;
    pub fn gst_event_parse_caps(event: *mut GstEvent,
                                caps: *mut *mut GstCaps);
    pub fn gst_event_new_segment(segment: *const GstSegment) -> *mut GstEvent;
    pub fn gst_event_parse_segment(event: *mut GstEvent,
                                   segment: *mut *const GstSegment);
    pub fn gst_event_copy_segment(event: *mut GstEvent,
                                  segment: *mut GstSegment);
    pub fn gst_event_new_tag(taglist: *mut GstTagList) -> *mut GstEvent;
    pub fn gst_event_parse_tag(event: *mut GstEvent,
                               taglist: *mut *mut GstTagList);
    pub fn gst_event_new_toc(toc: *mut GstToc, updated: gboolean)
     -> *mut GstEvent;
    pub fn gst_event_parse_toc(event: *mut GstEvent, toc: *mut *mut GstToc,
                               updated: *mut gboolean);
    pub fn gst_event_new_buffer_size(format: GstFormat, minsize: gint64,
                                     maxsize: gint64, async: gboolean)
     -> *mut GstEvent;
    pub fn gst_event_parse_buffer_size(event: *mut GstEvent,
                                       format: *mut GstFormat,
                                       minsize: *mut gint64,
                                       maxsize: *mut gint64,
                                       async: *mut gboolean);
    pub fn gst_event_new_sink_message(name: *const gchar,
                                      msg: *mut GstMessage) -> *mut GstEvent;
    pub fn gst_event_parse_sink_message(event: *mut GstEvent,
                                        msg: *mut *mut GstMessage);
    pub fn gst_event_new_qos(_type: GstQOSType, proportion: gdouble,
                             diff: GstClockTimeDiff, timestamp: GstClockTime)
     -> *mut GstEvent;
    pub fn gst_event_parse_qos(event: *mut GstEvent, _type: *mut GstQOSType,
                               proportion: *mut gdouble,
                               diff: *mut GstClockTimeDiff,
                               timestamp: *mut GstClockTime);
    pub fn gst_event_new_seek(rate: gdouble, format: GstFormat,
                              flags: GstSeekFlags, start_type: GstSeekType,
                              start: gint64, stop_type: GstSeekType,
                              stop: gint64) -> *mut GstEvent;
    pub fn gst_event_parse_seek(event: *mut GstEvent, rate: *mut gdouble,
                                format: *mut GstFormat,
                                flags: *mut GstSeekFlags,
                                start_type: *mut GstSeekType,
                                start: *mut gint64,
                                stop_type: *mut GstSeekType,
                                stop: *mut gint64);
    pub fn gst_event_new_navigation(structure: *mut GstStructure)
     -> *mut GstEvent;
    pub fn gst_event_new_latency(latency: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_parse_latency(event: *mut GstEvent,
                                   latency: *mut GstClockTime);
    pub fn gst_event_new_step(format: GstFormat, amount: guint64,
                              rate: gdouble, flush: gboolean,
                              intermediate: gboolean) -> *mut GstEvent;
    pub fn gst_event_parse_step(event: *mut GstEvent, format: *mut GstFormat,
                                amount: *mut guint64, rate: *mut gdouble,
                                flush: *mut gboolean,
                                intermediate: *mut gboolean);
    pub fn gst_event_new_reconfigure() -> *mut GstEvent;
    pub fn gst_event_new_toc_select(uid: *const gchar) -> *mut GstEvent;
    pub fn gst_event_parse_toc_select(event: *mut GstEvent,
                                      uid: *mut *mut gchar);
    pub fn gst_event_new_segment_done(format: GstFormat, position: gint64)
     -> *mut GstEvent;
    pub fn gst_event_parse_segment_done(event: *mut GstEvent,
                                        format: *mut GstFormat,
                                        position: *mut gint64);
    pub fn gst_task_pool_get_type() -> GType;
    pub fn gst_task_pool_new() -> *mut GstTaskPool;
    pub fn gst_task_pool_prepare(pool: *mut GstTaskPool,
                                 error: *mut *mut GError);
    pub fn gst_task_pool_push(pool: *mut GstTaskPool,
                              func: GstTaskPoolFunction, user_data: gpointer,
                              error: *mut *mut GError) -> gpointer;
    pub fn gst_task_pool_join(pool: *mut GstTaskPool, id: gpointer);
    pub fn gst_task_pool_cleanup(pool: *mut GstTaskPool);
    pub fn gst_task_cleanup_all();
    pub fn gst_task_get_type() -> GType;
    pub fn gst_task_new(func: GstTaskFunction, user_data: gpointer,
                        notify: GDestroyNotify) -> *mut GstTask;
    pub fn gst_task_set_lock(task: *mut GstTask, mutex: *mut GRecMutex);
    pub fn gst_task_get_pool(task: *mut GstTask) -> *mut GstTaskPool;
    pub fn gst_task_set_pool(task: *mut GstTask, pool: *mut GstTaskPool);
    pub fn gst_task_set_enter_callback(task: *mut GstTask,
                                       enter_func: GstTaskThreadFunc,
                                       user_data: gpointer,
                                       notify: GDestroyNotify);
    pub fn gst_task_set_leave_callback(task: *mut GstTask,
                                       leave_func: GstTaskThreadFunc,
                                       user_data: gpointer,
                                       notify: GDestroyNotify);
    pub fn gst_task_get_state(task: *mut GstTask) -> GstTaskState;
    pub fn gst_task_set_state(task: *mut GstTask, state: GstTaskState)
     -> gboolean;
    pub fn gst_task_start(task: *mut GstTask) -> gboolean;
    pub fn gst_task_stop(task: *mut GstTask) -> gboolean;
    pub fn gst_task_pause(task: *mut GstTask) -> gboolean;
    pub fn gst_task_join(task: *mut GstTask) -> gboolean;
    pub fn gst_pad_template_get_type() -> GType;
    pub fn gst_static_pad_template_get_type() -> GType;
    pub fn gst_pad_template_new(name_template: *const gchar,
                                direction: GstPadDirection,
                                presence: GstPadPresence, caps: *mut GstCaps)
     -> *mut GstPadTemplate;
    pub fn gst_static_pad_template_get(pad_template:
                                           *mut GstStaticPadTemplate)
     -> *mut GstPadTemplate;
    pub fn gst_static_pad_template_get_caps(templ: *mut GstStaticPadTemplate)
     -> *mut GstCaps;
    pub fn gst_pad_template_get_caps(templ: *mut GstPadTemplate)
     -> *mut GstCaps;
    pub fn gst_pad_template_pad_created(templ: *mut GstPadTemplate,
                                        pad: *mut GstPad);
    pub fn gst_flow_get_name(ret: GstFlowReturn) -> *const gchar;
    pub fn gst_flow_to_quark(ret: GstFlowReturn) -> GQuark;
    pub fn gst_pad_link_get_name(ret: GstPadLinkReturn) -> *const gchar;
    pub fn gst_pad_probe_info_get_event(info: *mut GstPadProbeInfo)
     -> *mut GstEvent;
    pub fn gst_pad_probe_info_get_query(info: *mut GstPadProbeInfo)
     -> *mut GstQuery;
    pub fn gst_pad_probe_info_get_buffer(info: *mut GstPadProbeInfo)
     -> *mut GstBuffer;
    pub fn gst_pad_probe_info_get_buffer_list(info: *mut GstPadProbeInfo)
     -> *mut GstBufferList;
    pub fn gst_pad_get_type() -> GType;
    pub fn gst_pad_new(name: *const gchar, direction: GstPadDirection)
     -> *mut GstPad;
    pub fn gst_pad_new_from_template(templ: *mut GstPadTemplate,
                                     name: *const gchar) -> *mut GstPad;
    pub fn gst_pad_new_from_static_template(templ: *mut GstStaticPadTemplate,
                                            name: *const gchar)
     -> *mut GstPad;
    pub fn gst_pad_get_direction(pad: *mut GstPad) -> GstPadDirection;
    pub fn gst_pad_set_active(pad: *mut GstPad, active: gboolean) -> gboolean;
    pub fn gst_pad_is_active(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_activate_mode(pad: *mut GstPad, mode: GstPadMode,
                                 active: gboolean) -> gboolean;
    pub fn gst_pad_add_probe(pad: *mut GstPad, mask: GstPadProbeType,
                             callback: GstPadProbeCallback,
                             user_data: gpointer,
                             destroy_data: GDestroyNotify) -> gulong;
    pub fn gst_pad_remove_probe(pad: *mut GstPad, id: gulong);
    pub fn gst_pad_is_blocked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_blocking(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_mark_reconfigure(pad: *mut GstPad);
    pub fn gst_pad_needs_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_check_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_set_element_private(pad: *mut GstPad, _priv: gpointer);
    pub fn gst_pad_get_element_private(pad: *mut GstPad) -> gpointer;
    pub fn gst_pad_get_pad_template(pad: *mut GstPad) -> *mut GstPadTemplate;
    pub fn gst_pad_store_sticky_event(pad: *mut GstPad, event: *mut GstEvent)
     -> GstFlowReturn;
    pub fn gst_pad_get_sticky_event(pad: *mut GstPad,
                                    event_type: GstEventType, idx: guint)
     -> *mut GstEvent;
    pub fn gst_pad_sticky_events_foreach(pad: *mut GstPad,
                                         foreach_func:
                                             GstPadStickyEventsForeachFunction,
                                         user_data: gpointer);
    pub fn gst_pad_set_activate_function_full(pad: *mut GstPad,
                                              activate:
                                                  GstPadActivateFunction,
                                              user_data: gpointer,
                                              notify: GDestroyNotify);
    pub fn gst_pad_set_activatemode_function_full(pad: *mut GstPad,
                                                  activatemode:
                                                      GstPadActivateModeFunction,
                                                  user_data: gpointer,
                                                  notify: GDestroyNotify);
    pub fn gst_pad_set_chain_function_full(pad: *mut GstPad,
                                           chain: GstPadChainFunction,
                                           user_data: gpointer,
                                           notify: GDestroyNotify);
    pub fn gst_pad_set_chain_list_function_full(pad: *mut GstPad,
                                                chainlist:
                                                    GstPadChainListFunction,
                                                user_data: gpointer,
                                                notify: GDestroyNotify);
    pub fn gst_pad_set_getrange_function_full(pad: *mut GstPad,
                                              get: GstPadGetRangeFunction,
                                              user_data: gpointer,
                                              notify: GDestroyNotify);
    pub fn gst_pad_set_event_function_full(pad: *mut GstPad,
                                           event: GstPadEventFunction,
                                           user_data: gpointer,
                                           notify: GDestroyNotify);
    pub fn gst_pad_set_link_function_full(pad: *mut GstPad,
                                          link: GstPadLinkFunction,
                                          user_data: gpointer,
                                          notify: GDestroyNotify);
    pub fn gst_pad_set_unlink_function_full(pad: *mut GstPad,
                                            unlink: GstPadUnlinkFunction,
                                            user_data: gpointer,
                                            notify: GDestroyNotify);
    pub fn gst_pad_can_link(srcpad: *mut GstPad, sinkpad: *mut GstPad)
     -> gboolean;
    pub fn gst_pad_link(srcpad: *mut GstPad, sinkpad: *mut GstPad)
     -> GstPadLinkReturn;
    pub fn gst_pad_link_full(srcpad: *mut GstPad, sinkpad: *mut GstPad,
                             flags: GstPadLinkCheck) -> GstPadLinkReturn;
    pub fn gst_pad_unlink(srcpad: *mut GstPad, sinkpad: *mut GstPad)
     -> gboolean;
    pub fn gst_pad_is_linked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_get_peer(pad: *mut GstPad) -> *mut GstPad;
    pub fn gst_pad_get_pad_template_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_current_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_has_current_caps(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_get_allowed_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_offset(pad: *mut GstPad) -> gint64;
    pub fn gst_pad_set_offset(pad: *mut GstPad, offset: gint64);
    pub fn gst_pad_push(pad: *mut GstPad, buffer: *mut GstBuffer)
     -> GstFlowReturn;
    pub fn gst_pad_push_list(pad: *mut GstPad, list: *mut GstBufferList)
     -> GstFlowReturn;
    pub fn gst_pad_pull_range(pad: *mut GstPad, offset: guint64, size: guint,
                              buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_push_event(pad: *mut GstPad, event: *mut GstEvent)
     -> gboolean;
    pub fn gst_pad_event_default(pad: *mut GstPad, parent: *mut GstObject,
                                 event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_get_last_flow_return(pad: *mut GstPad) -> GstFlowReturn;
    pub fn gst_pad_chain(pad: *mut GstPad, buffer: *mut GstBuffer)
     -> GstFlowReturn;
    pub fn gst_pad_chain_list(pad: *mut GstPad, list: *mut GstBufferList)
     -> GstFlowReturn;
    pub fn gst_pad_get_range(pad: *mut GstPad, offset: guint64, size: guint,
                             buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_send_event(pad: *mut GstPad, event: *mut GstEvent)
     -> gboolean;
    pub fn gst_pad_start_task(pad: *mut GstPad, func: GstTaskFunction,
                              user_data: gpointer, notify: GDestroyNotify)
     -> gboolean;
    pub fn gst_pad_pause_task(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_stop_task(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_set_iterate_internal_links_function_full(pad: *mut GstPad,
                                                            iterintlink:
                                                                GstPadIterIntLinkFunction,
                                                            user_data:
                                                                gpointer,
                                                            notify:
                                                                GDestroyNotify);
    pub fn gst_pad_iterate_internal_links(pad: *mut GstPad)
     -> *mut GstIterator;
    pub fn gst_pad_iterate_internal_links_default(pad: *mut GstPad,
                                                  parent: *mut GstObject)
     -> *mut GstIterator;
    pub fn gst_pad_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_peer_query(pad: *mut GstPad, query: *mut GstQuery)
     -> gboolean;
    pub fn gst_pad_set_query_function_full(pad: *mut GstPad,
                                           query: GstPadQueryFunction,
                                           user_data: gpointer,
                                           notify: GDestroyNotify);
    pub fn gst_pad_query_default(pad: *mut GstPad, parent: *mut GstObject,
                                 query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_forward(pad: *mut GstPad, forward: GstPadForwardFunction,
                           user_data: gpointer) -> gboolean;
    pub fn gst_bus_get_type() -> GType;
    pub fn gst_bus_new() -> *mut GstBus;
    pub fn gst_bus_post(bus: *mut GstBus, message: *mut GstMessage)
     -> gboolean;
    pub fn gst_bus_have_pending(bus: *mut GstBus) -> gboolean;
    pub fn gst_bus_peek(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_pop(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_pop_filtered(bus: *mut GstBus, types: GstMessageType)
     -> *mut GstMessage;
    pub fn gst_bus_timed_pop(bus: *mut GstBus, timeout: GstClockTime)
     -> *mut GstMessage;
    pub fn gst_bus_timed_pop_filtered(bus: *mut GstBus, timeout: GstClockTime,
                                      types: GstMessageType)
     -> *mut GstMessage;
    pub fn gst_bus_set_flushing(bus: *mut GstBus, flushing: gboolean);
    pub fn gst_bus_set_sync_handler(bus: *mut GstBus, func: GstBusSyncHandler,
                                    user_data: gpointer,
                                    notify: GDestroyNotify);
    pub fn gst_bus_create_watch(bus: *mut GstBus) -> *mut GSource;
    pub fn gst_bus_add_watch_full(bus: *mut GstBus, priority: gint,
                                  func: GstBusFunc, user_data: gpointer,
                                  notify: GDestroyNotify) -> guint;
    pub fn gst_bus_add_watch(bus: *mut GstBus, func: GstBusFunc,
                             user_data: gpointer) -> guint;
    pub fn gst_bus_poll(bus: *mut GstBus, events: GstMessageType,
                        timeout: GstClockTime) -> *mut GstMessage;
    pub fn gst_bus_async_signal_func(bus: *mut GstBus,
                                     message: *mut GstMessage, data: gpointer)
     -> gboolean;
    pub fn gst_bus_sync_signal_handler(bus: *mut GstBus,
                                       message: *mut GstMessage,
                                       data: gpointer) -> GstBusSyncReply;
    pub fn gst_bus_add_signal_watch(bus: *mut GstBus);
    pub fn gst_bus_add_signal_watch_full(bus: *mut GstBus, priority: gint);
    pub fn gst_bus_remove_signal_watch(bus: *mut GstBus);
    pub fn gst_bus_enable_sync_message_emission(bus: *mut GstBus);
    pub fn gst_bus_disable_sync_message_emission(bus: *mut GstBus);
    pub fn gst_plugin_error_quark() -> GQuark;
    pub fn gst_plugin_get_type() -> GType;
    pub fn gst_plugin_register_static(major_version: gint,
                                      minor_version: gint, name: *const gchar,
                                      description: *const gchar,
                                      init_func: GstPluginInitFunc,
                                      version: *const gchar,
                                      license: *const gchar,
                                      source: *const gchar,
                                      package: *const gchar,
                                      origin: *const gchar) -> gboolean;
    pub fn gst_plugin_register_static_full(major_version: gint,
                                           minor_version: gint,
                                           name: *const gchar,
                                           description: *const gchar,
                                           init_full_func:
                                               GstPluginInitFullFunc,
                                           version: *const gchar,
                                           license: *const gchar,
                                           source: *const gchar,
                                           package: *const gchar,
                                           origin: *const gchar,
                                           user_data: gpointer) -> gboolean;
    pub fn gst_plugin_get_name(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_description(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_filename(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_version(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_license(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_source(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_package(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_origin(plugin: *mut GstPlugin) -> *const gchar;
    pub fn gst_plugin_get_release_date_string(plugin: *mut GstPlugin)
     -> *const gchar;
    pub fn gst_plugin_get_cache_data(plugin: *mut GstPlugin)
     -> *const GstStructure;
    pub fn gst_plugin_set_cache_data(plugin: *mut GstPlugin,
                                     cache_data: *mut GstStructure);
    pub fn gst_plugin_is_loaded(plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_plugin_load_file(filename: *const gchar,
                                error: *mut *mut GError) -> *mut GstPlugin;
    pub fn gst_plugin_load(plugin: *mut GstPlugin) -> *mut GstPlugin;
    pub fn gst_plugin_load_by_name(name: *const gchar) -> *mut GstPlugin;
    pub fn gst_plugin_add_dependency(plugin: *mut GstPlugin,
                                     env_vars: *mut *const gchar,
                                     paths: *mut *const gchar,
                                     names: *mut *const gchar,
                                     flags: GstPluginDependencyFlags);
    pub fn gst_plugin_add_dependency_simple(plugin: *mut GstPlugin,
                                            env_vars: *const gchar,
                                            paths: *const gchar,
                                            names: *const gchar,
                                            flags: GstPluginDependencyFlags);
    pub fn gst_plugin_list_free(list: *mut GList);
    pub fn gst_plugin_feature_get_type() -> GType;
    pub fn gst_plugin_feature_load(feature: *mut GstPluginFeature)
     -> *mut GstPluginFeature;
    pub fn gst_plugin_feature_set_rank(feature: *mut GstPluginFeature,
                                       rank: guint);
    pub fn gst_plugin_feature_get_rank(feature: *mut GstPluginFeature)
     -> guint;
    pub fn gst_plugin_feature_get_plugin(feature: *mut GstPluginFeature)
     -> *mut GstPlugin;
    pub fn gst_plugin_feature_get_plugin_name(feature: *mut GstPluginFeature)
     -> *const gchar;
    pub fn gst_plugin_feature_list_free(list: *mut GList);
    pub fn gst_plugin_feature_list_copy(list: *mut GList) -> *mut GList;
    pub fn gst_plugin_feature_list_debug(list: *mut GList);
    pub fn gst_plugin_feature_check_version(feature: *mut GstPluginFeature,
                                            min_major: guint,
                                            min_minor: guint,
                                            min_micro: guint) -> gboolean;
    pub fn gst_plugin_feature_rank_compare_func(p1: gconstpointer,
                                                p2: gconstpointer) -> gint;
    pub fn gst_uri_error_quark() -> GQuark;
    pub fn gst_uri_protocol_is_valid(protocol: *const gchar) -> gboolean;
    pub fn gst_uri_protocol_is_supported(_type: GstURIType,
                                         protocol: *const gchar) -> gboolean;
    pub fn gst_uri_is_valid(uri: *const gchar) -> gboolean;
    pub fn gst_uri_get_protocol(uri: *const gchar) -> *mut gchar;
    pub fn gst_uri_has_protocol(uri: *const gchar, protocol: *const gchar)
     -> gboolean;
    pub fn gst_uri_get_location(uri: *const gchar) -> *mut gchar;
    pub fn gst_uri_construct(protocol: *const gchar, location: *const gchar)
     -> *mut gchar;
    pub fn gst_filename_to_uri(filename: *const gchar,
                               error: *mut *mut GError) -> *mut gchar;
    pub fn gst_element_make_from_uri(_type: GstURIType, uri: *const gchar,
                                     elementname: *const gchar,
                                     error: *mut *mut GError)
     -> *mut GstElement;
    pub fn gst_uri_handler_get_type() -> GType;
    pub fn gst_uri_handler_get_uri_type(handler: *mut GstURIHandler)
     -> GstURIType;
    pub fn gst_uri_handler_get_protocols(handler: *mut GstURIHandler)
     -> *const *const gchar;
    pub fn gst_uri_handler_get_uri(handler: *mut GstURIHandler) -> *mut gchar;
    pub fn gst_uri_handler_set_uri(handler: *mut GstURIHandler,
                                   uri: *const gchar, error: *mut *mut GError)
     -> gboolean;
    pub fn gst_element_factory_get_type() -> GType;
    pub fn gst_element_factory_find(name: *const gchar)
     -> *mut GstElementFactory;
    pub fn gst_element_factory_get_element_type(factory:
                                                    *mut GstElementFactory)
     -> GType;
    pub fn gst_element_factory_get_metadata(factory: *mut GstElementFactory,
                                            key: *const gchar)
     -> *const gchar;
    pub fn gst_element_factory_get_metadata_keys(factory:
                                                     *mut GstElementFactory)
     -> *mut *mut gchar;
    pub fn gst_element_factory_get_num_pad_templates(factory:
                                                         *mut GstElementFactory)
     -> guint;
    pub fn gst_element_factory_get_static_pad_templates(factory:
                                                            *mut GstElementFactory)
     -> *const GList;
    pub fn gst_element_factory_get_uri_type(factory: *mut GstElementFactory)
     -> GstURIType;
    pub fn gst_element_factory_get_uri_protocols(factory:
                                                     *mut GstElementFactory)
     -> *const *const gchar;
    pub fn gst_element_factory_has_interface(factory: *mut GstElementFactory,
                                             interfacename: *const gchar)
     -> gboolean;
    pub fn gst_element_factory_create(factory: *mut GstElementFactory,
                                      name: *const gchar) -> *mut GstElement;
    pub fn gst_element_factory_make(factoryname: *const gchar,
                                    name: *const gchar) -> *mut GstElement;
    pub fn gst_element_register(plugin: *mut GstPlugin, name: *const gchar,
                                rank: guint, _type: GType) -> gboolean;
    pub fn gst_element_factory_list_is_type(factory: *mut GstElementFactory,
                                            _type: GstElementFactoryListType)
     -> gboolean;
    pub fn gst_element_factory_list_get_elements(_type:
                                                     GstElementFactoryListType,
                                                 minrank: GstRank)
     -> *mut GList;
    pub fn gst_element_factory_list_filter(list: *mut GList,
                                           caps: *const GstCaps,
                                           direction: GstPadDirection,
                                           subsetonly: gboolean)
     -> *mut GList;
    pub fn gst_element_class_add_pad_template(klass: *mut GstElementClass,
                                              templ: *mut GstPadTemplate);
    pub fn gst_element_class_get_pad_template(element_class:
                                                  *mut GstElementClass,
                                              name: *const gchar)
     -> *mut GstPadTemplate;
    pub fn gst_element_class_get_pad_template_list(element_class:
                                                       *mut GstElementClass)
     -> *mut GList;
    pub fn gst_element_class_set_metadata(klass: *mut GstElementClass,
                                          longname: *const gchar,
                                          classification: *const gchar,
                                          description: *const gchar,
                                          author: *const gchar);
    pub fn gst_element_class_set_static_metadata(klass: *mut GstElementClass,
                                                 longname: *const gchar,
                                                 classification: *const gchar,
                                                 description: *const gchar,
                                                 author: *const gchar);
    pub fn gst_element_class_add_metadata(klass: *mut GstElementClass,
                                          key: *const gchar,
                                          value: *const gchar);
    pub fn gst_element_class_add_static_metadata(klass: *mut GstElementClass,
                                                 key: *const gchar,
                                                 value: *const gchar);
    pub fn gst_element_class_get_metadata(klass: *mut GstElementClass,
                                          key: *const gchar) -> *const gchar;
    pub fn gst_element_get_type() -> GType;
    pub fn gst_element_provide_clock(element: *mut GstElement)
     -> *mut GstClock;
    pub fn gst_element_get_clock(element: *mut GstElement) -> *mut GstClock;
    pub fn gst_element_set_clock(element: *mut GstElement,
                                 clock: *mut GstClock) -> gboolean;
    pub fn gst_element_set_base_time(element: *mut GstElement,
                                     time: GstClockTime);
    pub fn gst_element_get_base_time(element: *mut GstElement)
     -> GstClockTime;
    pub fn gst_element_set_start_time(element: *mut GstElement,
                                      time: GstClockTime);
    pub fn gst_element_get_start_time(element: *mut GstElement)
     -> GstClockTime;
    pub fn gst_element_set_bus(element: *mut GstElement, bus: *mut GstBus);
    pub fn gst_element_get_bus(element: *mut GstElement) -> *mut GstBus;
    pub fn gst_element_set_context(element: *mut GstElement,
                                   context: *mut GstContext);
    pub fn gst_element_add_pad(element: *mut GstElement, pad: *mut GstPad)
     -> gboolean;
    pub fn gst_element_remove_pad(element: *mut GstElement, pad: *mut GstPad)
     -> gboolean;
    pub fn gst_element_no_more_pads(element: *mut GstElement);
    pub fn gst_element_get_static_pad(element: *mut GstElement,
                                      name: *const gchar) -> *mut GstPad;
    pub fn gst_element_get_request_pad(element: *mut GstElement,
                                       name: *const gchar) -> *mut GstPad;
    pub fn gst_element_request_pad(element: *mut GstElement,
                                   templ: *mut GstPadTemplate,
                                   name: *const gchar, caps: *const GstCaps)
     -> *mut GstPad;
    pub fn gst_element_release_request_pad(element: *mut GstElement,
                                           pad: *mut GstPad);
    pub fn gst_element_iterate_pads(element: *mut GstElement)
     -> *mut GstIterator;
    pub fn gst_element_iterate_src_pads(element: *mut GstElement)
     -> *mut GstIterator;
    pub fn gst_element_iterate_sink_pads(element: *mut GstElement)
     -> *mut GstIterator;
    pub fn gst_element_send_event(element: *mut GstElement,
                                  event: *mut GstEvent) -> gboolean;
    pub fn gst_element_seek(element: *mut GstElement, rate: gdouble,
                            format: GstFormat, flags: GstSeekFlags,
                            start_type: GstSeekType, start: gint64,
                            stop_type: GstSeekType, stop: gint64) -> gboolean;
    pub fn gst_element_query(element: *mut GstElement, query: *mut GstQuery)
     -> gboolean;
    pub fn gst_element_post_message(element: *mut GstElement,
                                    message: *mut GstMessage) -> gboolean;
    pub fn _gst_element_error_printf(format: *const gchar, ...) -> *mut gchar;
    pub fn gst_element_message_full(element: *mut GstElement,
                                    _type: GstMessageType, domain: GQuark,
                                    code: gint, text: *mut gchar,
                                    debug: *mut gchar, file: *const gchar,
                                    function: *const gchar, line: gint);
    pub fn gst_element_is_locked_state(element: *mut GstElement) -> gboolean;
    pub fn gst_element_set_locked_state(element: *mut GstElement,
                                        locked_state: gboolean) -> gboolean;
    pub fn gst_element_sync_state_with_parent(element: *mut GstElement)
     -> gboolean;
    pub fn gst_element_get_state(element: *mut GstElement,
                                 state: *mut GstState, pending: *mut GstState,
                                 timeout: GstClockTime)
     -> GstStateChangeReturn;
    pub fn gst_element_set_state(element: *mut GstElement, state: GstState)
     -> GstStateChangeReturn;
    pub fn gst_element_abort_state(element: *mut GstElement);
    pub fn gst_element_change_state(element: *mut GstElement,
                                    transition: GstStateChange)
     -> GstStateChangeReturn;
    pub fn gst_element_continue_state(element: *mut GstElement,
                                      ret: GstStateChangeReturn)
     -> GstStateChangeReturn;
    pub fn gst_element_lost_state(element: *mut GstElement);
    pub fn gst_element_get_factory(element: *mut GstElement)
     -> *mut GstElementFactory;
    pub fn gst_bin_get_type() -> GType;
    pub fn gst_bin_new(name: *const gchar) -> *mut GstElement;
    pub fn gst_bin_add(bin: *mut GstBin, element: *mut GstElement)
     -> gboolean;
    pub fn gst_bin_remove(bin: *mut GstBin, element: *mut GstElement)
     -> gboolean;
    pub fn gst_bin_get_by_name(bin: *mut GstBin, name: *const gchar)
     -> *mut GstElement;
    pub fn gst_bin_get_by_name_recurse_up(bin: *mut GstBin,
                                          name: *const gchar)
     -> *mut GstElement;
    pub fn gst_bin_get_by_interface(bin: *mut GstBin, iface: GType)
     -> *mut GstElement;
    pub fn gst_bin_iterate_elements(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sorted(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_recurse(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sinks(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sources(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_all_by_interface(bin: *mut GstBin, iface: GType)
     -> *mut GstIterator;
    pub fn gst_bin_recalculate_latency(bin: *mut GstBin) -> gboolean;
    pub fn gst_buffer_pool_get_type() -> GType;
    pub fn gst_buffer_pool_new() -> *mut GstBufferPool;
    pub fn gst_buffer_pool_set_active(pool: *mut GstBufferPool,
                                      active: gboolean) -> gboolean;
    pub fn gst_buffer_pool_is_active(pool: *mut GstBufferPool) -> gboolean;
    pub fn gst_buffer_pool_set_config(pool: *mut GstBufferPool,
                                      config: *mut GstStructure) -> gboolean;
    pub fn gst_buffer_pool_get_config(pool: *mut GstBufferPool)
     -> *mut GstStructure;
    pub fn gst_buffer_pool_get_options(pool: *mut GstBufferPool)
     -> *mut *const gchar;
    pub fn gst_buffer_pool_has_option(pool: *mut GstBufferPool,
                                      option: *const gchar) -> gboolean;
    pub fn gst_buffer_pool_set_flushing(pool: *mut GstBufferPool,
                                        flushing: gboolean);
    pub fn gst_buffer_pool_config_set_params(config: *mut GstStructure,
                                             caps: *mut GstCaps, size: guint,
                                             min_buffers: guint,
                                             max_buffers: guint);
    pub fn gst_buffer_pool_config_get_params(config: *mut GstStructure,
                                             caps: *mut *mut GstCaps,
                                             size: *mut guint,
                                             min_buffers: *mut guint,
                                             max_buffers: *mut guint)
     -> gboolean;
    pub fn gst_buffer_pool_config_set_allocator(config: *mut GstStructure,
                                                allocator: *mut GstAllocator,
                                                params:
                                                    *const GstAllocationParams);
    pub fn gst_buffer_pool_config_get_allocator(config: *mut GstStructure,
                                                allocator:
                                                    *mut *mut GstAllocator,
                                                params:
                                                    *mut GstAllocationParams)
     -> gboolean;
    pub fn gst_buffer_pool_config_n_options(config: *mut GstStructure)
     -> guint;
    pub fn gst_buffer_pool_config_add_option(config: *mut GstStructure,
                                             option: *const gchar);
    pub fn gst_buffer_pool_config_get_option(config: *mut GstStructure,
                                             index: guint) -> *const gchar;
    pub fn gst_buffer_pool_config_has_option(config: *mut GstStructure,
                                             option: *const gchar)
     -> gboolean;
    pub fn gst_buffer_pool_config_validate_params(config: *mut GstStructure,
                                                  caps: *mut GstCaps,
                                                  size: guint,
                                                  min_buffers: guint,
                                                  max_buffers: guint)
     -> gboolean;
    pub fn gst_buffer_pool_acquire_buffer(pool: *mut GstBufferPool,
                                          buffer: *mut *mut GstBuffer,
                                          params:
                                              *mut GstBufferPoolAcquireParams)
     -> GstFlowReturn;
    pub fn gst_buffer_pool_release_buffer(pool: *mut GstBufferPool,
                                          buffer: *mut GstBuffer);
    pub fn gst_child_proxy_get_type() -> GType;
    pub fn gst_child_proxy_get_child_by_name(parent: *mut GstChildProxy,
                                             name: *const gchar)
     -> *mut GObject;
    pub fn gst_child_proxy_get_children_count(parent: *mut GstChildProxy)
     -> guint;
    pub fn gst_child_proxy_get_child_by_index(parent: *mut GstChildProxy,
                                              index: guint) -> *mut GObject;
    pub fn gst_child_proxy_lookup(object: *mut GstChildProxy,
                                  name: *const gchar,
                                  target: *mut *mut GObject,
                                  pspec: *mut *mut GParamSpec) -> gboolean;
    pub fn gst_child_proxy_get_property(object: *mut GstChildProxy,
                                        name: *const gchar,
                                        value: *mut GValue);
    pub fn gst_child_proxy_get_valist(object: *mut GstChildProxy,
                                      first_property_name: *const gchar,
                                      var_args: va_list);
    pub fn gst_child_proxy_get(object: *mut GstChildProxy,
                               first_property_name: *const gchar, ...);
    pub fn gst_child_proxy_set_property(object: *mut GstChildProxy,
                                        name: *const gchar,
                                        value: *const GValue);
    pub fn gst_child_proxy_set_valist(object: *mut GstChildProxy,
                                      first_property_name: *const gchar,
                                      var_args: va_list);
    pub fn gst_child_proxy_set(object: *mut GstChildProxy,
                               first_property_name: *const gchar, ...);
    pub fn gst_child_proxy_child_added(parent: *mut GstChildProxy,
                                       child: *mut GObject,
                                       name: *const gchar);
    pub fn gst_child_proxy_child_removed(parent: *mut GstChildProxy,
                                         child: *mut GObject,
                                         name: *const gchar);
    pub fn gst_debug_bin_to_dot_file(bin: *mut GstBin,
                                     details: GstDebugGraphDetails,
                                     file_name: *const gchar);
    pub fn gst_debug_bin_to_dot_file_with_ts(bin: *mut GstBin,
                                             details: GstDebugGraphDetails,
                                             file_name: *const gchar);
    pub fn gst_device_provider_get_type() -> GType;
    pub fn gst_device_provider_get_devices(provider: *mut GstDeviceProvider)
     -> *mut GList;
    pub fn gst_device_provider_start(provider: *mut GstDeviceProvider)
     -> gboolean;
    pub fn gst_device_provider_stop(provider: *mut GstDeviceProvider);
    pub fn gst_device_provider_can_monitor(provider: *mut GstDeviceProvider)
     -> gboolean;
    pub fn gst_device_provider_get_bus(provider: *mut GstDeviceProvider)
     -> *mut GstBus;
    pub fn gst_device_provider_device_add(provider: *mut GstDeviceProvider,
                                          device: *mut GstDevice);
    pub fn gst_device_provider_device_remove(provider: *mut GstDeviceProvider,
                                             device: *mut GstDevice);
    pub fn gst_device_provider_class_set_metadata(klass:
                                                      *mut GstDeviceProviderClass,
                                                  longname: *const gchar,
                                                  classification:
                                                      *const gchar,
                                                  description: *const gchar,
                                                  author: *const gchar);
    pub fn gst_device_provider_class_set_static_metadata(klass:
                                                             *mut GstDeviceProviderClass,
                                                         longname:
                                                             *const gchar,
                                                         classification:
                                                             *const gchar,
                                                         description:
                                                             *const gchar,
                                                         author:
                                                             *const gchar);
    pub fn gst_device_provider_class_add_metadata(klass:
                                                      *mut GstDeviceProviderClass,
                                                  key: *const gchar,
                                                  value: *const gchar);
    pub fn gst_device_provider_class_add_static_metadata(klass:
                                                             *mut GstDeviceProviderClass,
                                                         key: *const gchar,
                                                         value: *const gchar);
    pub fn gst_device_provider_class_get_metadata(klass:
                                                      *mut GstDeviceProviderClass,
                                                  key: *const gchar)
     -> *const gchar;
    pub fn gst_device_provider_get_factory(provider: *mut GstDeviceProvider)
     -> *mut GstDeviceProviderFactory;
    pub fn gst_device_provider_factory_get_type() -> GType;
    pub fn gst_device_provider_factory_find(name: *const gchar)
     -> *mut GstDeviceProviderFactory;
    pub fn gst_device_provider_factory_get_device_provider_type(factory:
                                                                    *mut GstDeviceProviderFactory)
     -> GType;
    pub fn gst_device_provider_factory_get_metadata(factory:
                                                        *mut GstDeviceProviderFactory,
                                                    key: *const gchar)
     -> *const gchar;
    pub fn gst_device_provider_factory_get_metadata_keys(factory:
                                                             *mut GstDeviceProviderFactory)
     -> *mut *mut gchar;
    pub fn gst_device_provider_factory_get(factory:
                                               *mut GstDeviceProviderFactory)
     -> *mut GstDeviceProvider;
    pub fn gst_device_provider_factory_get_by_name(factoryname: *const gchar)
     -> *mut GstDeviceProvider;
    pub fn gst_device_provider_register(plugin: *mut GstPlugin,
                                        name: *const gchar, rank: guint,
                                        _type: GType) -> gboolean;
    pub fn gst_device_provider_factory_has_classesv(factory:
                                                        *mut GstDeviceProviderFactory,
                                                    classes: *mut *mut gchar)
     -> gboolean;
    pub fn gst_device_provider_factory_has_classes(factory:
                                                       *mut GstDeviceProviderFactory,
                                                   classes: *const gchar)
     -> gboolean;
    pub fn gst_device_provider_factory_list_get_device_providers(minrank:
                                                                     GstRank)
     -> *mut GList;
    pub fn __errno_location() -> *mut ::libc::c_int;
    pub fn gst_error_get_message(domain: GQuark, code: gint) -> *mut gchar;
    pub fn gst_stream_error_quark() -> GQuark;
    pub fn gst_core_error_quark() -> GQuark;
    pub fn gst_resource_error_quark() -> GQuark;
    pub fn gst_library_error_quark() -> GQuark;
    pub fn gst_proxy_pad_get_type() -> GType;
    pub fn gst_proxy_pad_get_internal(pad: *mut GstProxyPad)
     -> *mut GstProxyPad;
    pub fn gst_proxy_pad_iterate_internal_links_default(pad: *mut GstPad,
                                                        parent:
                                                            *mut GstObject)
     -> *mut GstIterator;
    pub fn gst_proxy_pad_chain_default(pad: *mut GstPad,
                                       parent: *mut GstObject,
                                       buffer: *mut GstBuffer)
     -> GstFlowReturn;
    pub fn gst_proxy_pad_chain_list_default(pad: *mut GstPad,
                                            parent: *mut GstObject,
                                            list: *mut GstBufferList)
     -> GstFlowReturn;
    pub fn gst_proxy_pad_getrange_default(pad: *mut GstPad,
                                          parent: *mut GstObject,
                                          offset: guint64, size: guint,
                                          buffer: *mut *mut GstBuffer)
     -> GstFlowReturn;
    pub fn gst_ghost_pad_get_type() -> GType;
    pub fn gst_ghost_pad_new(name: *const gchar, target: *mut GstPad)
     -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target(name: *const gchar,
                                       dir: GstPadDirection) -> *mut GstPad;
    pub fn gst_ghost_pad_new_from_template(name: *const gchar,
                                           target: *mut GstPad,
                                           templ: *mut GstPadTemplate)
     -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target_from_template(name: *const gchar,
                                                     templ:
                                                         *mut GstPadTemplate)
     -> *mut GstPad;
    pub fn gst_ghost_pad_get_target(gpad: *mut GstGhostPad) -> *mut GstPad;
    pub fn gst_ghost_pad_set_target(gpad: *mut GstGhostPad,
                                    newtarget: *mut GstPad) -> gboolean;
    pub fn gst_ghost_pad_construct(gpad: *mut GstGhostPad) -> gboolean;
    pub fn gst_ghost_pad_activate_mode_default(pad: *mut GstPad,
                                               parent: *mut GstObject,
                                               mode: GstPadMode,
                                               active: gboolean) -> gboolean;
    pub fn gst_ghost_pad_internal_activate_mode_default(pad: *mut GstPad,
                                                        parent:
                                                            *mut GstObject,
                                                        mode: GstPadMode,
                                                        active: gboolean)
     -> gboolean;
    pub fn gst_device_monitor_get_type() -> GType;
    pub fn gst_device_monitor_new() -> *mut GstDeviceMonitor;
    pub fn gst_device_monitor_get_bus(monitor: *mut GstDeviceMonitor)
     -> *mut GstBus;
    pub fn gst_device_monitor_get_devices(monitor: *mut GstDeviceMonitor)
     -> *mut GList;
    pub fn gst_device_monitor_start(monitor: *mut GstDeviceMonitor)
     -> gboolean;
    pub fn gst_device_monitor_stop(monitor: *mut GstDeviceMonitor);
    pub fn gst_device_monitor_add_filter(monitor: *mut GstDeviceMonitor,
                                         classes: *const gchar,
                                         caps: *mut GstCaps) -> guint;
    pub fn gst_device_monitor_remove_filter(monitor: *mut GstDeviceMonitor,
                                            filter_id: guint) -> gboolean;
    pub fn gst_debug_log(category: *mut GstDebugCategory,
                         level: GstDebugLevel, file: *const gchar,
                         function: *const gchar, line: gint,
                         object: *mut GObject, format: *const gchar, ...);
    pub fn gst_debug_log_valist(category: *mut GstDebugCategory,
                                level: GstDebugLevel, file: *const gchar,
                                function: *const gchar, line: gint,
                                object: *mut GObject, format: *const gchar,
                                args: va_list);
    pub fn _gst_debug_category_new(name: *const gchar, color: guint,
                                   description: *const gchar)
     -> *mut GstDebugCategory;
    pub fn _gst_debug_get_category(name: *const gchar)
     -> *mut GstDebugCategory;
    pub fn _gst_debug_dump_mem(cat: *mut GstDebugCategory, file: *const gchar,
                               func: *const gchar, line: gint,
                               obj: *mut GObject, msg: *const gchar,
                               data: *const guint8, length: guint);
    pub fn _gst_debug_register_funcptr(func: GstDebugFuncPtr,
                                       ptrname: *const gchar);
    pub fn _gst_debug_nameof_funcptr(func: GstDebugFuncPtr) -> *const gchar;
    pub fn gst_debug_message_get(message: *mut GstDebugMessage)
     -> *const gchar;
    pub fn gst_debug_log_default(category: *mut GstDebugCategory,
                                 level: GstDebugLevel, file: *const gchar,
                                 function: *const gchar, line: gint,
                                 object: *mut GObject,
                                 message: *mut GstDebugMessage,
                                 unused: gpointer);
    pub fn gst_debug_level_get_name(level: GstDebugLevel) -> *const gchar;
    pub fn gst_debug_add_log_function(func: GstLogFunction,
                                      user_data: gpointer,
                                      notify: GDestroyNotify);
    pub fn gst_debug_remove_log_function(func: GstLogFunction) -> guint;
    pub fn gst_debug_remove_log_function_by_data(data: gpointer) -> guint;
    pub fn gst_debug_set_active(active: gboolean);
    pub fn gst_debug_is_active() -> gboolean;
    pub fn gst_debug_set_colored(colored: gboolean);
    pub fn gst_debug_set_color_mode(mode: GstDebugColorMode);
    pub fn gst_debug_set_color_mode_from_string(mode: *const gchar);
    pub fn gst_debug_is_colored() -> gboolean;
    pub fn gst_debug_get_color_mode() -> GstDebugColorMode;
    pub fn gst_debug_set_default_threshold(level: GstDebugLevel);
    pub fn gst_debug_get_default_threshold() -> GstDebugLevel;
    pub fn gst_debug_set_threshold_for_name(name: *const gchar,
                                            level: GstDebugLevel);
    pub fn gst_debug_set_threshold_from_string(list: *const gchar,
                                               reset: gboolean);
    pub fn gst_debug_unset_threshold_for_name(name: *const gchar);
    pub fn gst_debug_category_free(category: *mut GstDebugCategory);
    pub fn gst_debug_category_set_threshold(category: *mut GstDebugCategory,
                                            level: GstDebugLevel);
    pub fn gst_debug_category_reset_threshold(category:
                                                  *mut GstDebugCategory);
    pub fn gst_debug_category_get_threshold(category: *mut GstDebugCategory)
     -> GstDebugLevel;
    pub fn gst_debug_category_get_name(category: *mut GstDebugCategory)
     -> *const gchar;
    pub fn gst_debug_category_get_color(category: *mut GstDebugCategory)
     -> guint;
    pub fn gst_debug_category_get_description(category: *mut GstDebugCategory)
     -> *const gchar;
    pub fn gst_debug_get_all_categories() -> *mut GSList;
    pub fn gst_debug_construct_term_color(colorinfo: guint) -> *mut gchar;
    pub fn gst_debug_construct_win_color(colorinfo: guint) -> gint;
    pub fn gst_debug_print_stack_trace();
    pub fn gst_int_range_get_type() -> GType;
    pub fn gst_int64_range_get_type() -> GType;
    pub fn gst_double_range_get_type() -> GType;
    pub fn gst_fraction_range_get_type() -> GType;
    pub fn gst_fraction_get_type() -> GType;
    pub fn gst_value_list_get_type() -> GType;
    pub fn gst_value_array_get_type() -> GType;
    pub fn gst_bitmask_get_type() -> GType;
    pub fn gst_g_thread_get_type() -> GType;
    pub fn gst_value_register(table: *const GstValueTable);
    pub fn gst_value_init_and_copy(dest: *mut GValue, src: *const GValue);
    pub fn gst_value_serialize(value: *const GValue) -> *mut gchar;
    pub fn gst_value_deserialize(dest: *mut GValue, src: *const gchar)
     -> gboolean;
    pub fn gst_value_list_append_value(value: *mut GValue,
                                       append_value: *const GValue);
    pub fn gst_value_list_append_and_take_value(value: *mut GValue,
                                                append_value: *mut GValue);
    pub fn gst_value_list_prepend_value(value: *mut GValue,
                                        prepend_value: *const GValue);
    pub fn gst_value_list_concat(dest: *mut GValue, value1: *const GValue,
                                 value2: *const GValue);
    pub fn gst_value_list_merge(dest: *mut GValue, value1: *const GValue,
                                value2: *const GValue);
    pub fn gst_value_list_get_size(value: *const GValue) -> guint;
    pub fn gst_value_list_get_value(value: *const GValue, index: guint)
     -> *const GValue;
    pub fn gst_value_array_append_value(value: *mut GValue,
                                        append_value: *const GValue);
    pub fn gst_value_array_append_and_take_value(value: *mut GValue,
                                                 append_value: *mut GValue);
    pub fn gst_value_array_prepend_value(value: *mut GValue,
                                         prepend_value: *const GValue);
    pub fn gst_value_array_get_size(value: *const GValue) -> guint;
    pub fn gst_value_array_get_value(value: *const GValue, index: guint)
     -> *const GValue;
    pub fn gst_value_set_int_range(value: *mut GValue, start: gint,
                                   end: gint);
    pub fn gst_value_set_int_range_step(value: *mut GValue, start: gint,
                                        end: gint, step: gint);
    pub fn gst_value_get_int_range_min(value: *const GValue) -> gint;
    pub fn gst_value_get_int_range_max(value: *const GValue) -> gint;
    pub fn gst_value_get_int_range_step(value: *const GValue) -> gint;
    pub fn gst_value_set_int64_range(value: *mut GValue, start: gint64,
                                     end: gint64);
    pub fn gst_value_set_int64_range_step(value: *mut GValue, start: gint64,
                                          end: gint64, step: gint64);
    pub fn gst_value_get_int64_range_min(value: *const GValue) -> gint64;
    pub fn gst_value_get_int64_range_max(value: *const GValue) -> gint64;
    pub fn gst_value_get_int64_range_step(value: *const GValue) -> gint64;
    pub fn gst_value_set_double_range(value: *mut GValue, start: gdouble,
                                      end: gdouble);
    pub fn gst_value_get_double_range_min(value: *const GValue) -> gdouble;
    pub fn gst_value_get_double_range_max(value: *const GValue) -> gdouble;
    pub fn gst_value_get_caps(value: *const GValue) -> *const GstCaps;
    pub fn gst_value_set_caps(value: *mut GValue, caps: *const GstCaps);
    pub fn gst_value_get_structure(value: *const GValue)
     -> *const GstStructure;
    pub fn gst_value_set_structure(value: *mut GValue,
                                   structure: *const GstStructure);
    pub fn gst_value_get_caps_features(value: *const GValue)
     -> *const GstCapsFeatures;
    pub fn gst_value_set_caps_features(value: *mut GValue,
                                       features: *const GstCapsFeatures);
    pub fn gst_value_set_fraction(value: *mut GValue, numerator: gint,
                                  denominator: gint);
    pub fn gst_value_get_fraction_numerator(value: *const GValue) -> gint;
    pub fn gst_value_get_fraction_denominator(value: *const GValue) -> gint;
    pub fn gst_value_fraction_multiply(product: *mut GValue,
                                       factor1: *const GValue,
                                       factor2: *const GValue) -> gboolean;
    pub fn gst_value_fraction_subtract(dest: *mut GValue,
                                       minuend: *const GValue,
                                       subtrahend: *const GValue) -> gboolean;
    pub fn gst_value_set_fraction_range(value: *mut GValue,
                                        start: *const GValue,
                                        end: *const GValue);
    pub fn gst_value_set_fraction_range_full(value: *mut GValue,
                                             numerator_start: gint,
                                             denominator_start: gint,
                                             numerator_end: gint,
                                             denominator_end: gint);
    pub fn gst_value_get_fraction_range_min(value: *const GValue)
     -> *const GValue;
    pub fn gst_value_get_fraction_range_max(value: *const GValue)
     -> *const GValue;
    pub fn gst_value_get_bitmask(value: *const GValue) -> guint64;
    pub fn gst_value_set_bitmask(value: *mut GValue, bitmask: guint64);
    pub fn gst_value_compare(value1: *const GValue, value2: *const GValue)
     -> gint;
    pub fn gst_value_can_compare(value1: *const GValue, value2: *const GValue)
     -> gboolean;
    pub fn gst_value_is_subset(value1: *const GValue, value2: *const GValue)
     -> gboolean;
    pub fn gst_value_union(dest: *mut GValue, value1: *const GValue,
                           value2: *const GValue) -> gboolean;
    pub fn gst_value_can_union(value1: *const GValue, value2: *const GValue)
     -> gboolean;
    pub fn gst_value_intersect(dest: *mut GValue, value1: *const GValue,
                               value2: *const GValue) -> gboolean;
    pub fn gst_value_can_intersect(value1: *const GValue,
                                   value2: *const GValue) -> gboolean;
    pub fn gst_value_subtract(dest: *mut GValue, minuend: *const GValue,
                              subtrahend: *const GValue) -> gboolean;
    pub fn gst_value_can_subtract(minuend: *const GValue,
                                  subtrahend: *const GValue) -> gboolean;
    pub fn gst_value_is_fixed(value: *const GValue) -> gboolean;
    pub fn gst_value_fixate(dest: *mut GValue, src: *const GValue)
     -> gboolean;
    pub fn gst_param_spec_fraction_get_type() -> GType;
    pub fn gst_param_spec_fraction(name: *const gchar, nick: *const gchar,
                                   blurb: *const gchar, min_num: gint,
                                   min_denom: gint, max_num: gint,
                                   max_denom: gint, default_num: gint,
                                   default_denom: gint, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn gst_pipeline_get_type() -> GType;
    pub fn gst_pipeline_new(name: *const gchar) -> *mut GstElement;
    pub fn gst_pipeline_get_bus(pipeline: *mut GstPipeline) -> *mut GstBus;
    pub fn gst_pipeline_use_clock(pipeline: *mut GstPipeline,
                                  clock: *mut GstClock);
    pub fn gst_pipeline_set_clock(pipeline: *mut GstPipeline,
                                  clock: *mut GstClock) -> gboolean;
    pub fn gst_pipeline_get_clock(pipeline: *mut GstPipeline)
     -> *mut GstClock;
    pub fn gst_pipeline_auto_clock(pipeline: *mut GstPipeline);
    pub fn gst_pipeline_set_delay(pipeline: *mut GstPipeline,
                                  delay: GstClockTime);
    pub fn gst_pipeline_get_delay(pipeline: *mut GstPipeline) -> GstClockTime;
    pub fn gst_pipeline_set_auto_flush_bus(pipeline: *mut GstPipeline,
                                           auto_flush: gboolean);
    pub fn gst_pipeline_get_auto_flush_bus(pipeline: *mut GstPipeline)
     -> gboolean;
    pub fn gst_poll_new(controllable: gboolean) -> *mut GstPoll;
    pub fn gst_poll_new_timer() -> *mut GstPoll;
    pub fn gst_poll_free(set: *mut GstPoll);
    pub fn gst_poll_get_read_gpollfd(set: *mut GstPoll, fd: *mut GPollFD);
    pub fn gst_poll_fd_init(fd: *mut GstPollFD);
    pub fn gst_poll_add_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_remove_fd(set: *mut GstPoll, fd: *mut GstPollFD)
     -> gboolean;
    pub fn gst_poll_fd_ctl_write(set: *mut GstPoll, fd: *mut GstPollFD,
                                 active: gboolean) -> gboolean;
    pub fn gst_poll_fd_ctl_read(set: *mut GstPoll, fd: *mut GstPollFD,
                                active: gboolean) -> gboolean;
    pub fn gst_poll_fd_ignored(set: *mut GstPoll, fd: *mut GstPollFD);
    pub fn gst_poll_fd_has_closed(set: *const GstPoll, fd: *mut GstPollFD)
     -> gboolean;
    pub fn gst_poll_fd_has_error(set: *const GstPoll, fd: *mut GstPollFD)
     -> gboolean;
    pub fn gst_poll_fd_can_read(set: *const GstPoll, fd: *mut GstPollFD)
     -> gboolean;
    pub fn gst_poll_fd_can_write(set: *const GstPoll, fd: *mut GstPollFD)
     -> gboolean;
    pub fn gst_poll_wait(set: *mut GstPoll, timeout: GstClockTime) -> gint;
    pub fn gst_poll_set_controllable(set: *mut GstPoll,
                                     controllable: gboolean) -> gboolean;
    pub fn gst_poll_restart(set: *mut GstPoll);
    pub fn gst_poll_set_flushing(set: *mut GstPoll, flushing: gboolean);
    pub fn gst_poll_write_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_poll_read_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_preset_get_type() -> GType;
    pub fn gst_preset_get_preset_names(preset: *mut GstPreset)
     -> *mut *mut gchar;
    pub fn gst_preset_get_property_names(preset: *mut GstPreset)
     -> *mut *mut gchar;
    pub fn gst_preset_load_preset(preset: *mut GstPreset, name: *const gchar)
     -> gboolean;
    pub fn gst_preset_save_preset(preset: *mut GstPreset, name: *const gchar)
     -> gboolean;
    pub fn gst_preset_rename_preset(preset: *mut GstPreset,
                                    old_name: *const gchar,
                                    new_name: *const gchar) -> gboolean;
    pub fn gst_preset_delete_preset(preset: *mut GstPreset,
                                    name: *const gchar) -> gboolean;
    pub fn gst_preset_set_meta(preset: *mut GstPreset, name: *const gchar,
                               tag: *const gchar, value: *const gchar)
     -> gboolean;
    pub fn gst_preset_get_meta(preset: *mut GstPreset, name: *const gchar,
                               tag: *const gchar, value: *mut *mut gchar)
     -> gboolean;
    pub fn gst_preset_set_app_dir(app_dir: *const gchar) -> gboolean;
    pub fn gst_preset_get_app_dir() -> *const gchar;
    pub fn gst_registry_get_type() -> GType;
    pub fn gst_registry_get() -> *mut GstRegistry;
    pub fn gst_registry_scan_path(registry: *mut GstRegistry,
                                  path: *const gchar) -> gboolean;
    pub fn gst_registry_add_plugin(registry: *mut GstRegistry,
                                   plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_registry_remove_plugin(registry: *mut GstRegistry,
                                      plugin: *mut GstPlugin);
    pub fn gst_registry_add_feature(registry: *mut GstRegistry,
                                    feature: *mut GstPluginFeature)
     -> gboolean;
    pub fn gst_registry_remove_feature(registry: *mut GstRegistry,
                                       feature: *mut GstPluginFeature);
    pub fn gst_registry_get_plugin_list(registry: *mut GstRegistry)
     -> *mut GList;
    pub fn gst_registry_plugin_filter(registry: *mut GstRegistry,
                                      filter: GstPluginFilter,
                                      first: gboolean, user_data: gpointer)
     -> *mut GList;
    pub fn gst_registry_feature_filter(registry: *mut GstRegistry,
                                       filter: GstPluginFeatureFilter,
                                       first: gboolean, user_data: gpointer)
     -> *mut GList;
    pub fn gst_registry_get_feature_list(registry: *mut GstRegistry,
                                         _type: GType) -> *mut GList;
    pub fn gst_registry_get_feature_list_by_plugin(registry: *mut GstRegistry,
                                                   name: *const gchar)
     -> *mut GList;
    pub fn gst_registry_get_feature_list_cookie(registry: *mut GstRegistry)
     -> guint32;
    pub fn gst_registry_find_plugin(registry: *mut GstRegistry,
                                    name: *const gchar) -> *mut GstPlugin;
    pub fn gst_registry_find_feature(registry: *mut GstRegistry,
                                     name: *const gchar, _type: GType)
     -> *mut GstPluginFeature;
    pub fn gst_registry_lookup(registry: *mut GstRegistry,
                               filename: *const ::libc::c_char)
     -> *mut GstPlugin;
    pub fn gst_registry_lookup_feature(registry: *mut GstRegistry,
                                       name: *const ::libc::c_char)
     -> *mut GstPluginFeature;
    pub fn gst_registry_check_feature_version(registry: *mut GstRegistry,
                                              feature_name: *const gchar,
                                              min_major: guint,
                                              min_minor: guint,
                                              min_micro: guint) -> gboolean;
    pub fn gst_system_clock_get_type() -> GType;
    pub fn gst_system_clock_obtain() -> *mut GstClock;
    pub fn gst_system_clock_set_default(new_clock: *mut GstClock);
    pub fn gst_tag_setter_get_type() -> GType;
    pub fn gst_tag_setter_reset_tags(setter: *mut GstTagSetter);
    pub fn gst_tag_setter_merge_tags(setter: *mut GstTagSetter,
                                     list: *const GstTagList,
                                     mode: GstTagMergeMode);
    pub fn gst_tag_setter_add_tags(setter: *mut GstTagSetter,
                                   mode: GstTagMergeMode,
                                   tag: *const gchar, ...);
    pub fn gst_tag_setter_add_tag_values(setter: *mut GstTagSetter,
                                         mode: GstTagMergeMode,
                                         tag: *const gchar, ...);
    pub fn gst_tag_setter_add_tag_valist(setter: *mut GstTagSetter,
                                         mode: GstTagMergeMode,
                                         tag: *const gchar,
                                         var_args: va_list);
    pub fn gst_tag_setter_add_tag_valist_values(setter: *mut GstTagSetter,
                                                mode: GstTagMergeMode,
                                                tag: *const gchar,
                                                var_args: va_list);
    pub fn gst_tag_setter_add_tag_value(setter: *mut GstTagSetter,
                                        mode: GstTagMergeMode,
                                        tag: *const gchar,
                                        value: *const GValue);
    pub fn gst_tag_setter_get_tag_list(setter: *mut GstTagSetter)
     -> *const GstTagList;
    pub fn gst_tag_setter_set_tag_merge_mode(setter: *mut GstTagSetter,
                                             mode: GstTagMergeMode);
    pub fn gst_tag_setter_get_tag_merge_mode(setter: *mut GstTagSetter)
     -> GstTagMergeMode;
    pub fn gst_toc_setter_get_type() -> GType;
    pub fn gst_toc_setter_reset(setter: *mut GstTocSetter);
    pub fn gst_toc_setter_get_toc(setter: *mut GstTocSetter) -> *mut GstToc;
    pub fn gst_toc_setter_set_toc(setter: *mut GstTocSetter,
                                  toc: *mut GstToc);
    pub fn gst_type_find_get_type() -> GType;
    pub fn gst_type_find_peek(find: *mut GstTypeFind, offset: gint64,
                              size: guint) -> *const guint8;
    pub fn gst_type_find_suggest(find: *mut GstTypeFind, probability: guint,
                                 caps: *mut GstCaps);
    pub fn gst_type_find_suggest_simple(find: *mut GstTypeFind,
                                        probability: guint,
                                        media_type: *const ::libc::c_char,
                                        fieldname:
                                            *const ::libc::c_char, ...);
    pub fn gst_type_find_get_length(find: *mut GstTypeFind) -> guint64;
    pub fn gst_type_find_register(plugin: *mut GstPlugin, name: *const gchar,
                                  rank: guint, func: GstTypeFindFunction,
                                  extensions: *const gchar,
                                  possible_caps: *mut GstCaps, data: gpointer,
                                  data_notify: GDestroyNotify) -> gboolean;
    pub fn gst_type_find_factory_get_type() -> GType;
    pub fn gst_type_find_factory_get_list() -> *mut GList;
    pub fn gst_type_find_factory_get_extensions(factory:
                                                    *mut GstTypeFindFactory)
     -> *const *const gchar;
    pub fn gst_type_find_factory_get_caps(factory: *mut GstTypeFindFactory)
     -> *mut GstCaps;
    pub fn gst_type_find_factory_has_function(factory:
                                                  *mut GstTypeFindFactory)
     -> gboolean;
    pub fn gst_type_find_factory_call_function(factory:
                                                   *mut GstTypeFindFactory,
                                               find: *mut GstTypeFind);
    pub fn gst_parse_error_quark() -> GQuark;
    pub fn gst_parse_context_get_type() -> GType;
    pub fn gst_parse_context_new() -> *mut GstParseContext;
    pub fn gst_parse_context_get_missing_elements(context:
                                                      *mut GstParseContext)
     -> *mut *mut gchar;
    pub fn gst_parse_context_free(context: *mut GstParseContext);
    pub fn gst_parse_launch(pipeline_description: *const gchar,
                            error: *mut *mut GError) -> *mut GstElement;
    pub fn gst_parse_launchv(argv: *mut *const gchar, error: *mut *mut GError)
     -> *mut GstElement;
    pub fn gst_parse_launch_full(pipeline_description: *const gchar,
                                 context: *mut GstParseContext,
                                 flags: GstParseFlags,
                                 error: *mut *mut GError) -> *mut GstElement;
    pub fn gst_parse_launchv_full(argv: *mut *const gchar,
                                  context: *mut GstParseContext,
                                  flags: GstParseFlags,
                                  error: *mut *mut GError) -> *mut GstElement;
    pub fn gst_util_set_value_from_string(value: *mut GValue,
                                          value_str: *const gchar);
    pub fn gst_util_set_object_arg(object: *mut GObject, name: *const gchar,
                                   value: *const gchar);
    pub fn gst_util_dump_mem(mem: *const guchar, size: guint);
    pub fn gst_util_gdouble_to_guint64(value: gdouble) -> guint64;
    pub fn gst_util_guint64_to_gdouble(value: guint64) -> gdouble;
    pub fn gst_util_uint64_scale(val: guint64, num: guint64, denom: guint64)
     -> guint64;
    pub fn gst_util_uint64_scale_round(val: guint64, num: guint64,
                                       denom: guint64) -> guint64;
    pub fn gst_util_uint64_scale_ceil(val: guint64, num: guint64,
                                      denom: guint64) -> guint64;
    pub fn gst_util_uint64_scale_int(val: guint64, num: gint, denom: gint)
     -> guint64;
    pub fn gst_util_uint64_scale_int_round(val: guint64, num: gint,
                                           denom: gint) -> guint64;
    pub fn gst_util_uint64_scale_int_ceil(val: guint64, num: gint,
                                          denom: gint) -> guint64;
    pub fn gst_util_seqnum_next() -> guint32;
    pub fn gst_util_seqnum_compare(s1: guint32, s2: guint32) -> gint32;
    pub fn gst_util_group_id_next() -> guint;
    pub fn gst_object_default_error(source: *mut GstObject,
                                    error: *const GError,
                                    debug: *const gchar);
    pub fn gst_element_create_all_pads(element: *mut GstElement);
    pub fn gst_element_get_compatible_pad(element: *mut GstElement,
                                          pad: *mut GstPad,
                                          caps: *mut GstCaps) -> *mut GstPad;
    pub fn gst_element_get_compatible_pad_template(element: *mut GstElement,
                                                   compattempl:
                                                       *mut GstPadTemplate)
     -> *mut GstPadTemplate;
    pub fn gst_element_state_get_name(state: GstState) -> *const gchar;
    pub fn gst_element_state_change_return_get_name(state_ret:
                                                        GstStateChangeReturn)
     -> *const gchar;
    pub fn gst_element_link(src: *mut GstElement, dest: *mut GstElement)
     -> gboolean;
    pub fn gst_element_link_many(element_1: *mut GstElement,
                                 element_2: *mut GstElement, ...) -> gboolean;
    pub fn gst_element_link_filtered(src: *mut GstElement,
                                     dest: *mut GstElement,
                                     filter: *mut GstCaps) -> gboolean;
    pub fn gst_element_unlink(src: *mut GstElement, dest: *mut GstElement);
    pub fn gst_element_unlink_many(element_1: *mut GstElement,
                                   element_2: *mut GstElement, ...);
    pub fn gst_element_link_pads(src: *mut GstElement,
                                 srcpadname: *const gchar,
                                 dest: *mut GstElement,
                                 destpadname: *const gchar) -> gboolean;
    pub fn gst_element_link_pads_full(src: *mut GstElement,
                                      srcpadname: *const gchar,
                                      dest: *mut GstElement,
                                      destpadname: *const gchar,
                                      flags: GstPadLinkCheck) -> gboolean;
    pub fn gst_element_unlink_pads(src: *mut GstElement,
                                   srcpadname: *const gchar,
                                   dest: *mut GstElement,
                                   destpadname: *const gchar);
    pub fn gst_element_link_pads_filtered(src: *mut GstElement,
                                          srcpadname: *const gchar,
                                          dest: *mut GstElement,
                                          destpadname: *const gchar,
                                          filter: *mut GstCaps) -> gboolean;
    pub fn gst_element_seek_simple(element: *mut GstElement,
                                   format: GstFormat,
                                   seek_flags: GstSeekFlags, seek_pos: gint64)
     -> gboolean;
    pub fn gst_element_factory_can_sink_all_caps(factory:
                                                     *mut GstElementFactory,
                                                 caps: *const GstCaps)
     -> gboolean;
    pub fn gst_element_factory_can_src_all_caps(factory:
                                                    *mut GstElementFactory,
                                                caps: *const GstCaps)
     -> gboolean;
    pub fn gst_element_factory_can_sink_any_caps(factory:
                                                     *mut GstElementFactory,
                                                 caps: *const GstCaps)
     -> gboolean;
    pub fn gst_element_factory_can_src_any_caps(factory:
                                                    *mut GstElementFactory,
                                                caps: *const GstCaps)
     -> gboolean;
    pub fn gst_element_query_position(element: *mut GstElement,
                                      format: GstFormat, cur: *mut gint64)
     -> gboolean;
    pub fn gst_element_query_duration(element: *mut GstElement,
                                      format: GstFormat,
                                      duration: *mut gint64) -> gboolean;
    pub fn gst_element_query_convert(element: *mut GstElement,
                                     src_format: GstFormat, src_val: gint64,
                                     dest_format: GstFormat,
                                     dest_val: *mut gint64) -> gboolean;
    pub fn gst_pad_use_fixed_caps(pad: *mut GstPad);
    pub fn gst_pad_get_parent_element(pad: *mut GstPad) -> *mut GstElement;
    pub fn gst_pad_proxy_query_accept_caps(pad: *mut GstPad,
                                           query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_proxy_query_caps(pad: *mut GstPad, query: *mut GstQuery)
     -> gboolean;
    pub fn gst_pad_query_position(pad: *mut GstPad, format: GstFormat,
                                  cur: *mut gint64) -> gboolean;
    pub fn gst_pad_query_duration(pad: *mut GstPad, format: GstFormat,
                                  duration: *mut gint64) -> gboolean;
    pub fn gst_pad_query_convert(pad: *mut GstPad, src_format: GstFormat,
                                 src_val: gint64, dest_format: GstFormat,
                                 dest_val: *mut gint64) -> gboolean;
    pub fn gst_pad_query_caps(pad: *mut GstPad, filter: *mut GstCaps)
     -> *mut GstCaps;
    pub fn gst_pad_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps)
     -> gboolean;
    pub fn gst_pad_peer_query_position(pad: *mut GstPad, format: GstFormat,
                                       cur: *mut gint64) -> gboolean;
    pub fn gst_pad_peer_query_duration(pad: *mut GstPad, format: GstFormat,
                                       duration: *mut gint64) -> gboolean;
    pub fn gst_pad_peer_query_convert(pad: *mut GstPad, src_format: GstFormat,
                                      src_val: gint64, dest_format: GstFormat,
                                      dest_val: *mut gint64) -> gboolean;
    pub fn gst_pad_peer_query_caps(pad: *mut GstPad, filter: *mut GstCaps)
     -> *mut GstCaps;
    pub fn gst_pad_peer_query_accept_caps(pad: *mut GstPad,
                                          caps: *mut GstCaps) -> gboolean;
    pub fn gst_pad_create_stream_id(pad: *mut GstPad, parent: *mut GstElement,
                                    stream_id: *const gchar) -> *mut gchar;
    pub fn gst_pad_create_stream_id_printf(pad: *mut GstPad,
                                           parent: *mut GstElement,
                                           stream_id: *const gchar, ...)
     -> *mut gchar;
    pub fn gst_pad_create_stream_id_printf_valist(pad: *mut GstPad,
                                                  parent: *mut GstElement,
                                                  stream_id: *const gchar,
                                                  var_args: va_list)
     -> *mut gchar;
    pub fn gst_pad_get_stream_id(pad: *mut GstPad) -> *mut gchar;
    pub fn gst_bin_add_many(bin: *mut GstBin,
                            element_1: *mut GstElement, ...);
    pub fn gst_bin_remove_many(bin: *mut GstBin,
                               element_1: *mut GstElement, ...);
    pub fn gst_bin_find_unlinked_pad(bin: *mut GstBin,
                                     direction: GstPadDirection)
     -> *mut GstPad;
    pub fn gst_parse_bin_from_description(bin_description: *const gchar,
                                          ghost_unlinked_pads: gboolean,
                                          err: *mut *mut GError)
     -> *mut GstElement;
    pub fn gst_parse_bin_from_description_full(bin_description: *const gchar,
                                               ghost_unlinked_pads: gboolean,
                                               context: *mut GstParseContext,
                                               flags: GstParseFlags,
                                               err: *mut *mut GError)
     -> *mut GstElement;
    pub fn gst_util_get_timestamp() -> GstClockTime;
    pub fn gst_util_array_binary_search(array: gpointer, num_elements: guint,
                                        element_size: gsize,
                                        search_func: GCompareDataFunc,
                                        mode: GstSearchMode,
                                        search_data: gconstpointer,
                                        user_data: gpointer) -> gpointer;
    pub fn gst_util_greatest_common_divisor(a: gint, b: gint) -> gint;
    pub fn gst_util_greatest_common_divisor_int64(a: gint64, b: gint64)
     -> gint64;
    pub fn gst_util_fraction_to_double(src_n: gint, src_d: gint,
                                       dest: *mut gdouble);
    pub fn gst_util_double_to_fraction(src: gdouble, dest_n: *mut gint,
                                       dest_d: *mut gint);
    pub fn gst_util_fraction_multiply(a_n: gint, a_d: gint, b_n: gint,
                                      b_d: gint, res_n: *mut gint,
                                      res_d: *mut gint) -> gboolean;
    pub fn gst_util_fraction_add(a_n: gint, a_d: gint, b_n: gint, b_d: gint,
                                 res_n: *mut gint, res_d: *mut gint)
     -> gboolean;
    pub fn gst_util_fraction_compare(a_n: gint, a_d: gint, b_n: gint,
                                     b_d: gint) -> gint;
    pub fn gst_init(argc: *mut ::libc::c_int,
                    argv: *mut *mut *mut ::libc::c_char);
    pub fn gst_init_check(argc: *mut ::libc::c_int,
                          argv: *mut *mut *mut ::libc::c_char,
                          err: *mut *mut GError) -> gboolean;
    pub fn gst_is_initialized() -> gboolean;
    pub fn gst_init_get_option_group() -> *mut GOptionGroup;
    pub fn gst_deinit();
    pub fn gst_version(major: *mut guint, minor: *mut guint,
                       micro: *mut guint, nano: *mut guint);
    pub fn gst_version_string() -> *mut gchar;
    pub fn gst_segtrap_is_enabled() -> gboolean;
    pub fn gst_segtrap_set_enabled(enabled: gboolean);
    pub fn gst_registry_fork_is_enabled() -> gboolean;
    pub fn gst_registry_fork_set_enabled(enabled: gboolean);
    pub fn gst_update_registry() -> gboolean;
    pub fn gst_base_sink_get_type() -> GType;
    pub fn gst_base_sink_do_preroll(sink: *mut GstBaseSink,
                                    obj: *mut GstMiniObject) -> GstFlowReturn;
    pub fn gst_base_sink_wait_preroll(sink: *mut GstBaseSink)
     -> GstFlowReturn;
    pub fn gst_base_sink_set_sync(sink: *mut GstBaseSink, sync: gboolean);
    pub fn gst_base_sink_get_sync(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_set_max_lateness(sink: *mut GstBaseSink,
                                          max_lateness: gint64);
    pub fn gst_base_sink_get_max_lateness(sink: *mut GstBaseSink) -> gint64;
    pub fn gst_base_sink_set_qos_enabled(sink: *mut GstBaseSink,
                                         enabled: gboolean);
    pub fn gst_base_sink_is_qos_enabled(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_set_async_enabled(sink: *mut GstBaseSink,
                                           enabled: gboolean);
    pub fn gst_base_sink_is_async_enabled(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_set_ts_offset(sink: *mut GstBaseSink,
                                       offset: GstClockTimeDiff);
    pub fn gst_base_sink_get_ts_offset(sink: *mut GstBaseSink)
     -> GstClockTimeDiff;
    pub fn gst_base_sink_get_last_sample(sink: *mut GstBaseSink)
     -> *mut GstSample;
    pub fn gst_base_sink_set_last_sample_enabled(sink: *mut GstBaseSink,
                                                 enabled: gboolean);
    pub fn gst_base_sink_is_last_sample_enabled(sink: *mut GstBaseSink)
     -> gboolean;
    pub fn gst_base_sink_query_latency(sink: *mut GstBaseSink,
                                       live: *mut gboolean,
                                       upstream_live: *mut gboolean,
                                       min_latency: *mut GstClockTime,
                                       max_latency: *mut GstClockTime)
     -> gboolean;
    pub fn gst_base_sink_get_latency(sink: *mut GstBaseSink) -> GstClockTime;
    pub fn gst_base_sink_set_render_delay(sink: *mut GstBaseSink,
                                          delay: GstClockTime);
    pub fn gst_base_sink_get_render_delay(sink: *mut GstBaseSink)
     -> GstClockTime;
    pub fn gst_base_sink_set_blocksize(sink: *mut GstBaseSink,
                                       blocksize: guint);
    pub fn gst_base_sink_get_blocksize(sink: *mut GstBaseSink) -> guint;
    pub fn gst_base_sink_set_throttle_time(sink: *mut GstBaseSink,
                                           throttle: guint64);
    pub fn gst_base_sink_get_throttle_time(sink: *mut GstBaseSink) -> guint64;
    pub fn gst_base_sink_set_max_bitrate(sink: *mut GstBaseSink,
                                         max_bitrate: guint64);
    pub fn gst_base_sink_get_max_bitrate(sink: *mut GstBaseSink) -> guint64;
    pub fn gst_base_sink_wait_clock(sink: *mut GstBaseSink,
                                    time: GstClockTime,
                                    jitter: *mut GstClockTimeDiff)
     -> GstClockReturn;
    pub fn gst_base_sink_wait(sink: *mut GstBaseSink, time: GstClockTime,
                              jitter: *mut GstClockTimeDiff) -> GstFlowReturn;
    pub fn gst_app_sink_get_type() -> GType;
    pub fn gst_app_sink_set_caps(appsink: *mut GstAppSink,
                                 caps: *const GstCaps);
    pub fn gst_app_sink_get_caps(appsink: *mut GstAppSink) -> *mut GstCaps;
    pub fn gst_app_sink_is_eos(appsink: *mut GstAppSink) -> gboolean;
    pub fn gst_app_sink_set_emit_signals(appsink: *mut GstAppSink,
                                         emit: gboolean);
    pub fn gst_app_sink_get_emit_signals(appsink: *mut GstAppSink)
     -> gboolean;
    pub fn gst_app_sink_set_max_buffers(appsink: *mut GstAppSink, max: guint);
    pub fn gst_app_sink_get_max_buffers(appsink: *mut GstAppSink) -> guint;
    pub fn gst_app_sink_set_drop(appsink: *mut GstAppSink, drop: gboolean);
    pub fn gst_app_sink_get_drop(appsink: *mut GstAppSink) -> gboolean;
    pub fn gst_app_sink_pull_preroll(appsink: *mut GstAppSink)
     -> *mut GstSample;
    pub fn gst_app_sink_pull_sample(appsink: *mut GstAppSink)
     -> *mut GstSample;
    pub fn gst_app_sink_set_callbacks(appsink: *mut GstAppSink,
                                      callbacks: *mut GstAppSinkCallbacks,
                                      user_data: gpointer,
                                      notify: GDestroyNotify);
    pub fn gst_base_src_get_type() -> GType;
    pub fn gst_base_src_wait_playing(src: *mut GstBaseSrc) -> GstFlowReturn;
    pub fn gst_base_src_set_live(src: *mut GstBaseSrc, live: gboolean);
    pub fn gst_base_src_is_live(src: *mut GstBaseSrc) -> gboolean;
    pub fn gst_base_src_set_format(src: *mut GstBaseSrc, format: GstFormat);
    pub fn gst_base_src_set_dynamic_size(src: *mut GstBaseSrc,
                                         dynamic: gboolean);
    pub fn gst_base_src_set_automatic_eos(src: *mut GstBaseSrc,
                                          automatic_eos: gboolean);
    pub fn gst_base_src_set_async(src: *mut GstBaseSrc, async: gboolean);
    pub fn gst_base_src_is_async(src: *mut GstBaseSrc) -> gboolean;
    pub fn gst_base_src_start_complete(basesrc: *mut GstBaseSrc,
                                       ret: GstFlowReturn);
    pub fn gst_base_src_start_wait(basesrc: *mut GstBaseSrc) -> GstFlowReturn;
    pub fn gst_base_src_query_latency(src: *mut GstBaseSrc,
                                      live: *mut gboolean,
                                      min_latency: *mut GstClockTime,
                                      max_latency: *mut GstClockTime)
     -> gboolean;
    pub fn gst_base_src_set_blocksize(src: *mut GstBaseSrc, blocksize: guint);
    pub fn gst_base_src_get_blocksize(src: *mut GstBaseSrc) -> guint;
    pub fn gst_base_src_set_do_timestamp(src: *mut GstBaseSrc,
                                         timestamp: gboolean);
    pub fn gst_base_src_get_do_timestamp(src: *mut GstBaseSrc) -> gboolean;
    pub fn gst_base_src_new_seamless_segment(src: *mut GstBaseSrc,
                                             start: gint64, stop: gint64,
                                             time: gint64) -> gboolean;
    pub fn gst_base_src_set_caps(src: *mut GstBaseSrc, caps: *mut GstCaps)
     -> gboolean;
    pub fn gst_base_src_get_buffer_pool(src: *mut GstBaseSrc)
     -> *mut GstBufferPool;
    pub fn gst_base_src_get_allocator(src: *mut GstBaseSrc,
                                      allocator: *mut *mut GstAllocator,
                                      params: *mut GstAllocationParams);
    pub fn gst_push_src_get_type() -> GType;
    pub fn gst_app_src_get_type() -> GType;
    pub fn gst_app_stream_type_get_type() -> GType;
    pub fn gst_app_src_set_caps(appsrc: *mut GstAppSrc, caps: *const GstCaps);
    pub fn gst_app_src_get_caps(appsrc: *mut GstAppSrc) -> *mut GstCaps;
    pub fn gst_app_src_set_size(appsrc: *mut GstAppSrc, size: gint64);
    pub fn gst_app_src_get_size(appsrc: *mut GstAppSrc) -> gint64;
    pub fn gst_app_src_set_stream_type(appsrc: *mut GstAppSrc,
                                       _type: GstAppStreamType);
    pub fn gst_app_src_get_stream_type(appsrc: *mut GstAppSrc)
     -> GstAppStreamType;
    pub fn gst_app_src_set_max_bytes(appsrc: *mut GstAppSrc, max: guint64);
    pub fn gst_app_src_get_max_bytes(appsrc: *mut GstAppSrc) -> guint64;
    pub fn gst_app_src_get_current_level_bytes(appsrc: *mut GstAppSrc)
     -> guint64;
    pub fn gst_app_src_set_latency(appsrc: *mut GstAppSrc, min: guint64,
                                   max: guint64);
    pub fn gst_app_src_get_latency(appsrc: *mut GstAppSrc, min: *mut guint64,
                                   max: *mut guint64);
    pub fn gst_app_src_set_emit_signals(appsrc: *mut GstAppSrc,
                                        emit: gboolean);
    pub fn gst_app_src_get_emit_signals(appsrc: *mut GstAppSrc) -> gboolean;
    pub fn gst_app_src_push_buffer(appsrc: *mut GstAppSrc,
                                   buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_app_src_end_of_stream(appsrc: *mut GstAppSrc) -> GstFlowReturn;
    pub fn gst_app_src_set_callbacks(appsrc: *mut GstAppSrc,
                                     callbacks: *mut GstAppSrcCallbacks,
                                     user_data: gpointer,
                                     notify: GDestroyNotify);
    pub fn gst_video_format_get_type() -> GType;
    pub fn gst_video_format_flags_get_type() -> GType;
    pub fn gst_video_pack_flags_get_type() -> GType;
    pub fn gst_video_color_range_get_type() -> GType;
    pub fn gst_video_color_matrix_get_type() -> GType;
    pub fn gst_video_transfer_function_get_type() -> GType;
    pub fn gst_video_color_primaries_get_type() -> GType;
    pub fn gst_video_interlace_mode_get_type() -> GType;
    pub fn gst_video_flags_get_type() -> GType;
    pub fn gst_color_balance_type_get_type() -> GType;
    pub fn gst_navigation_command_get_type() -> GType;
    pub fn gst_navigation_query_type_get_type() -> GType;
    pub fn gst_navigation_message_type_get_type() -> GType;
    pub fn gst_navigation_event_type_get_type() -> GType;
    pub fn gst_video_chroma_site_get_type() -> GType;
    pub fn gst_video_chroma_method_get_type() -> GType;
    pub fn gst_video_chroma_flags_get_type() -> GType;
    pub fn gst_video_tile_type_get_type() -> GType;
    pub fn gst_video_tile_mode_get_type() -> GType;
    pub fn gst_video_tile_get_index(mode: GstVideoTileMode, x: gint, y: gint,
                                    x_tiles: gint, y_tiles: gint) -> guint;
    pub fn gst_video_chroma_from_string(s: *const gchar)
     -> GstVideoChromaSite;
    pub fn gst_video_chroma_to_string(site: GstVideoChromaSite)
     -> *const gchar;
    pub fn gst_video_chroma_resample_new(method: GstVideoChromaMethod,
                                         site: GstVideoChromaSite,
                                         flags: GstVideoChromaFlags,
                                         format: GstVideoFormat,
                                         h_factor: gint, v_factor: gint)
     -> *mut GstVideoChromaResample;
    pub fn gst_video_chroma_resample_free(resample:
                                              *mut GstVideoChromaResample);
    pub fn gst_video_chroma_resample_get_info(resample:
                                                  *mut GstVideoChromaResample,
                                              n_lines: *mut guint,
                                              offset: *mut gint);
    pub fn gst_video_chroma_resample(resample: *mut GstVideoChromaResample,
                                     lines: *mut gpointer, width: gint);
    pub fn gst_video_format_from_masks(depth: gint, bpp: gint,
                                       endianness: gint, red_mask: guint,
                                       green_mask: guint, blue_mask: guint,
                                       alpha_mask: guint) -> GstVideoFormat;
    pub fn gst_video_format_from_fourcc(fourcc: guint32) -> GstVideoFormat;
    pub fn gst_video_format_from_string(format: *const gchar)
     -> GstVideoFormat;
    pub fn gst_video_format_to_fourcc(format: GstVideoFormat) -> guint32;
    pub fn gst_video_format_to_string(format: GstVideoFormat) -> *const gchar;
    pub fn gst_video_format_get_info(format: GstVideoFormat)
     -> *const GstVideoFormatInfo;
    pub fn gst_video_format_get_palette(format: GstVideoFormat,
                                        size: *mut gsize) -> gconstpointer;
    pub fn gst_video_colorimetry_matches(cinfo: *mut GstVideoColorimetry,
                                         color: *const gchar) -> gboolean;
    pub fn gst_video_colorimetry_from_string(cinfo: *mut GstVideoColorimetry,
                                             color: *const gchar) -> gboolean;
    pub fn gst_video_colorimetry_to_string(cinfo: *mut GstVideoColorimetry)
     -> *mut gchar;
    pub fn gst_video_color_range_offsets(range: GstVideoColorRange,
                                         info: *const GstVideoFormatInfo,
                                         offset: *mut gint, scale: *mut gint);
    pub fn gst_video_info_init(info: *mut GstVideoInfo);
    pub fn gst_video_info_set_format(info: *mut GstVideoInfo,
                                     format: GstVideoFormat, width: guint,
                                     height: guint);
    pub fn gst_video_info_from_caps(info: *mut GstVideoInfo,
                                    caps: *const GstCaps) -> gboolean;
    pub fn gst_video_info_to_caps(info: *mut GstVideoInfo) -> *mut GstCaps;
    pub fn gst_video_info_convert(info: *mut GstVideoInfo,
                                  src_format: GstFormat, src_value: gint64,
                                  dest_format: GstFormat,
                                  dest_value: *mut gint64) -> gboolean;
    pub fn gst_video_info_is_equal(info: *const GstVideoInfo,
                                   other: *const GstVideoInfo) -> gboolean;
    pub fn gst_video_info_align(info: *mut GstVideoInfo,
                                align: *mut GstVideoAlignment);
    pub fn gst_video_frame_map(frame: *mut GstVideoFrame,
                               info: *mut GstVideoInfo,
                               buffer: *mut GstBuffer, flags: GstMapFlags)
     -> gboolean;
    pub fn gst_video_frame_map_id(frame: *mut GstVideoFrame,
                                  info: *mut GstVideoInfo,
                                  buffer: *mut GstBuffer, id: gint,
                                  flags: GstMapFlags) -> gboolean;
    pub fn gst_video_frame_unmap(frame: *mut GstVideoFrame);
    pub fn gst_video_frame_copy(dest: *mut GstVideoFrame,
                                src: *const GstVideoFrame) -> gboolean;
    pub fn gst_video_frame_copy_plane(dest: *mut GstVideoFrame,
                                      src: *const GstVideoFrame, plane: guint)
     -> gboolean;
    pub fn gst_video_alignment_reset(align: *mut GstVideoAlignment);
    pub fn gst_video_calculate_display_ratio(dar_n: *mut guint,
                                             dar_d: *mut guint,
                                             video_width: guint,
                                             video_height: guint,
                                             video_par_n: guint,
                                             video_par_d: guint,
                                             display_par_n: guint,
                                             display_par_d: guint)
     -> gboolean;
    pub fn gst_video_convert_sample_async(sample: *mut GstSample,
                                          to_caps: *const GstCaps,
                                          timeout: GstClockTime,
                                          callback:
                                              GstVideoConvertSampleCallback,
                                          user_data: gpointer,
                                          destroy_notify: GDestroyNotify);
    pub fn gst_video_convert_sample(sample: *mut GstSample,
                                    to_caps: *const GstCaps,
                                    timeout: GstClockTime,
                                    error: *mut *mut GError)
     -> *mut GstSample;
    pub fn gst_color_balance_channel_get_type() -> GType;
    pub fn gst_color_balance_get_type() -> GType;
    pub fn gst_color_balance_list_channels(balance: *mut GstColorBalance)
     -> *const GList;
    pub fn gst_color_balance_set_value(balance: *mut GstColorBalance,
                                       channel: *mut GstColorBalanceChannel,
                                       value: gint);
    pub fn gst_color_balance_get_value(balance: *mut GstColorBalance,
                                       channel: *mut GstColorBalanceChannel)
     -> gint;
    pub fn gst_color_balance_get_balance_type(balance: *mut GstColorBalance)
     -> GstColorBalanceType;
    pub fn gst_color_balance_value_changed(balance: *mut GstColorBalance,
                                           channel:
                                               *mut GstColorBalanceChannel,
                                           value: gint);
    pub fn gst_adapter_get_type() -> GType;
    pub fn gst_adapter_new() -> *mut GstAdapter;
    pub fn gst_adapter_clear(adapter: *mut GstAdapter);
    pub fn gst_adapter_push(adapter: *mut GstAdapter, buf: *mut GstBuffer);
    pub fn gst_adapter_map(adapter: *mut GstAdapter, size: gsize)
     -> gconstpointer;
    pub fn gst_adapter_unmap(adapter: *mut GstAdapter);
    pub fn gst_adapter_copy(adapter: *mut GstAdapter, dest: gpointer,
                            offset: gsize, size: gsize);
    pub fn gst_adapter_copy_bytes(adapter: *mut GstAdapter, offset: gsize,
                                  size: gsize) -> *mut GBytes;
    pub fn gst_adapter_flush(adapter: *mut GstAdapter, flush: gsize);
    pub fn gst_adapter_take(adapter: *mut GstAdapter, nbytes: gsize)
     -> gpointer;
    pub fn gst_adapter_take_buffer(adapter: *mut GstAdapter, nbytes: gsize)
     -> *mut GstBuffer;
    pub fn gst_adapter_take_list(adapter: *mut GstAdapter, nbytes: gsize)
     -> *mut GList;
    pub fn gst_adapter_take_buffer_fast(adapter: *mut GstAdapter,
                                        nbytes: gsize) -> *mut GstBuffer;
    pub fn gst_adapter_available(adapter: *mut GstAdapter) -> gsize;
    pub fn gst_adapter_available_fast(adapter: *mut GstAdapter) -> gsize;
    pub fn gst_adapter_prev_pts(adapter: *mut GstAdapter,
                                distance: *mut guint64) -> GstClockTime;
    pub fn gst_adapter_prev_dts(adapter: *mut GstAdapter,
                                distance: *mut guint64) -> GstClockTime;
    pub fn gst_adapter_prev_pts_at_offset(adapter: *mut GstAdapter,
                                          offset: gsize,
                                          distance: *mut guint64)
     -> GstClockTime;
    pub fn gst_adapter_prev_dts_at_offset(adapter: *mut GstAdapter,
                                          offset: gsize,
                                          distance: *mut guint64)
     -> GstClockTime;
    pub fn gst_adapter_masked_scan_uint32(adapter: *mut GstAdapter,
                                          mask: guint32, pattern: guint32,
                                          offset: gsize, size: gsize)
     -> gssize;
    pub fn gst_adapter_masked_scan_uint32_peek(adapter: *mut GstAdapter,
                                               mask: guint32,
                                               pattern: guint32,
                                               offset: gsize, size: gsize,
                                               value: *mut guint32) -> gssize;
    pub fn gst_video_codec_state_get_type() -> GType;
    pub fn gst_video_codec_state_ref(state: *mut GstVideoCodecState)
     -> *mut GstVideoCodecState;
    pub fn gst_video_codec_state_unref(state: *mut GstVideoCodecState);
    pub fn gst_video_codec_frame_get_type() -> GType;
    pub fn gst_video_codec_frame_ref(frame: *mut GstVideoCodecFrame)
     -> *mut GstVideoCodecFrame;
    pub fn gst_video_codec_frame_unref(frame: *mut GstVideoCodecFrame);
    pub fn gst_video_codec_frame_set_user_data(frame: *mut GstVideoCodecFrame,
                                               user_data: gpointer,
                                               notify: GDestroyNotify);
    pub fn gst_video_codec_frame_get_user_data(frame: *mut GstVideoCodecFrame)
     -> gpointer;
    pub fn _gst_video_decoder_error(dec: *mut GstVideoDecoder, weight: gint,
                                    domain: GQuark, code: gint,
                                    txt: *mut gchar, debug: *mut gchar,
                                    file: *const gchar,
                                    function: *const gchar, line: gint)
     -> GstFlowReturn;
    pub fn gst_video_decoder_get_type() -> GType;
    pub fn gst_video_decoder_set_packetized(decoder: *mut GstVideoDecoder,
                                            packetized: gboolean);
    pub fn gst_video_decoder_get_packetized(decoder: *mut GstVideoDecoder)
     -> gboolean;
    pub fn gst_video_decoder_set_estimate_rate(dec: *mut GstVideoDecoder,
                                               enabled: gboolean);
    pub fn gst_video_decoder_get_estimate_rate(dec: *mut GstVideoDecoder)
     -> gint;
    pub fn gst_video_decoder_set_max_errors(dec: *mut GstVideoDecoder,
                                            num: gint);
    pub fn gst_video_decoder_get_max_errors(dec: *mut GstVideoDecoder)
     -> gint;
    pub fn gst_video_decoder_set_needs_format(dec: *mut GstVideoDecoder,
                                              enabled: gboolean);
    pub fn gst_video_decoder_get_needs_format(dec: *mut GstVideoDecoder)
     -> gboolean;
    pub fn gst_video_decoder_set_latency(decoder: *mut GstVideoDecoder,
                                         min_latency: GstClockTime,
                                         max_latency: GstClockTime);
    pub fn gst_video_decoder_get_latency(decoder: *mut GstVideoDecoder,
                                         min_latency: *mut GstClockTime,
                                         max_latency: *mut GstClockTime);
    pub fn gst_video_decoder_get_allocator(decoder: *mut GstVideoDecoder,
                                           allocator: *mut *mut GstAllocator,
                                           params: *mut GstAllocationParams);
    pub fn gst_video_decoder_get_buffer_pool(decoder: *mut GstVideoDecoder)
     -> *mut GstBufferPool;
    pub fn gst_video_decoder_get_frame(decoder: *mut GstVideoDecoder,
                                       frame_number: ::libc::c_int)
     -> *mut GstVideoCodecFrame;
    pub fn gst_video_decoder_get_oldest_frame(decoder: *mut GstVideoDecoder)
     -> *mut GstVideoCodecFrame;
    pub fn gst_video_decoder_get_frames(decoder: *mut GstVideoDecoder)
     -> *mut GList;
    pub fn gst_video_decoder_add_to_frame(decoder: *mut GstVideoDecoder,
                                          n_bytes: ::libc::c_int);
    pub fn gst_video_decoder_have_frame(decoder: *mut GstVideoDecoder)
     -> GstFlowReturn;
    pub fn gst_video_decoder_get_pending_frame_size(decoder:
                                                        *mut GstVideoDecoder)
     -> gsize;
    pub fn gst_video_decoder_allocate_output_buffer(decoder:
                                                        *mut GstVideoDecoder)
     -> *mut GstBuffer;
    pub fn gst_video_decoder_allocate_output_frame(decoder:
                                                       *mut GstVideoDecoder,
                                                   frame:
                                                       *mut GstVideoCodecFrame)
     -> GstFlowReturn;
    pub fn gst_video_decoder_set_output_state(decoder: *mut GstVideoDecoder,
                                              fmt: GstVideoFormat,
                                              width: guint, height: guint,
                                              reference:
                                                  *mut GstVideoCodecState)
     -> *mut GstVideoCodecState;
    pub fn gst_video_decoder_get_output_state(decoder: *mut GstVideoDecoder)
     -> *mut GstVideoCodecState;
    pub fn gst_video_decoder_negotiate(decoder: *mut GstVideoDecoder)
     -> gboolean;
    pub fn gst_video_decoder_get_max_decode_time(decoder:
                                                     *mut GstVideoDecoder,
                                                 frame:
                                                     *mut GstVideoCodecFrame)
     -> GstClockTimeDiff;
    pub fn gst_video_decoder_get_qos_proportion(decoder: *mut GstVideoDecoder)
     -> gdouble;
    pub fn gst_video_decoder_finish_frame(decoder: *mut GstVideoDecoder,
                                          frame: *mut GstVideoCodecFrame)
     -> GstFlowReturn;
    pub fn gst_video_decoder_drop_frame(dec: *mut GstVideoDecoder,
                                        frame: *mut GstVideoCodecFrame)
     -> GstFlowReturn;
    pub fn gst_video_decoder_release_frame(dec: *mut GstVideoDecoder,
                                           frame: *mut GstVideoCodecFrame);
    pub fn gst_video_decoder_merge_tags(decoder: *mut GstVideoDecoder,
                                        tags: *const GstTagList,
                                        mode: GstTagMergeMode);
    pub fn gst_video_encoder_get_type() -> GType;
    pub fn gst_video_encoder_get_output_state(encoder: *mut GstVideoEncoder)
     -> *mut GstVideoCodecState;
    pub fn gst_video_encoder_set_output_state(encoder: *mut GstVideoEncoder,
                                              caps: *mut GstCaps,
                                              reference:
                                                  *mut GstVideoCodecState)
     -> *mut GstVideoCodecState;
    pub fn gst_video_encoder_negotiate(encoder: *mut GstVideoEncoder)
     -> gboolean;
    pub fn gst_video_encoder_get_frame(encoder: *mut GstVideoEncoder,
                                       frame_number: ::libc::c_int)
     -> *mut GstVideoCodecFrame;
    pub fn gst_video_encoder_get_oldest_frame(encoder: *mut GstVideoEncoder)
     -> *mut GstVideoCodecFrame;
    pub fn gst_video_encoder_get_frames(encoder: *mut GstVideoEncoder)
     -> *mut GList;
    pub fn gst_video_encoder_allocate_output_buffer(encoder:
                                                        *mut GstVideoEncoder,
                                                    size: gsize)
     -> *mut GstBuffer;
    pub fn gst_video_encoder_allocate_output_frame(encoder:
                                                       *mut GstVideoEncoder,
                                                   frame:
                                                       *mut GstVideoCodecFrame,
                                                   size: gsize)
     -> GstFlowReturn;
    pub fn gst_video_encoder_finish_frame(encoder: *mut GstVideoEncoder,
                                          frame: *mut GstVideoCodecFrame)
     -> GstFlowReturn;
    pub fn gst_video_encoder_proxy_getcaps(enc: *mut GstVideoEncoder,
                                           caps: *mut GstCaps,
                                           filter: *mut GstCaps)
     -> *mut GstCaps;
    pub fn gst_video_encoder_set_latency(encoder: *mut GstVideoEncoder,
                                         min_latency: GstClockTime,
                                         max_latency: GstClockTime);
    pub fn gst_video_encoder_get_latency(encoder: *mut GstVideoEncoder,
                                         min_latency: *mut GstClockTime,
                                         max_latency: *mut GstClockTime);
    pub fn gst_video_encoder_set_headers(encoder: *mut GstVideoEncoder,
                                         headers: *mut GList);
    pub fn gst_video_encoder_merge_tags(encoder: *mut GstVideoEncoder,
                                        tags: *const GstTagList,
                                        mode: GstTagMergeMode);
    pub fn gst_video_encoder_get_allocator(encoder: *mut GstVideoEncoder,
                                           allocator: *mut *mut GstAllocator,
                                           params: *mut GstAllocationParams);
    pub fn gst_base_transform_get_type() -> GType;
    pub fn gst_base_transform_set_passthrough(trans: *mut GstBaseTransform,
                                              passthrough: gboolean);
    pub fn gst_base_transform_is_passthrough(trans: *mut GstBaseTransform)
     -> gboolean;
    pub fn gst_base_transform_set_in_place(trans: *mut GstBaseTransform,
                                           in_place: gboolean);
    pub fn gst_base_transform_is_in_place(trans: *mut GstBaseTransform)
     -> gboolean;
    pub fn gst_base_transform_update_qos(trans: *mut GstBaseTransform,
                                         proportion: gdouble,
                                         diff: GstClockTimeDiff,
                                         timestamp: GstClockTime);
    pub fn gst_base_transform_set_qos_enabled(trans: *mut GstBaseTransform,
                                              enabled: gboolean);
    pub fn gst_base_transform_is_qos_enabled(trans: *mut GstBaseTransform)
     -> gboolean;
    pub fn gst_base_transform_set_gap_aware(trans: *mut GstBaseTransform,
                                            gap_aware: gboolean);
    pub fn gst_base_transform_set_prefer_passthrough(trans:
                                                         *mut GstBaseTransform,
                                                     prefer_passthrough:
                                                         gboolean);
    pub fn gst_base_transform_get_buffer_pool(trans: *mut GstBaseTransform)
     -> *mut GstBufferPool;
    pub fn gst_base_transform_get_allocator(trans: *mut GstBaseTransform,
                                            allocator: *mut *mut GstAllocator,
                                            params: *mut GstAllocationParams);
    pub fn gst_base_transform_reconfigure_sink(trans: *mut GstBaseTransform);
    pub fn gst_base_transform_reconfigure_src(trans: *mut GstBaseTransform);
    pub fn gst_video_filter_get_type() -> GType;
    pub fn gst_video_meta_api_get_type() -> GType;
    pub fn gst_video_meta_get_info() -> *const GstMetaInfo;
    pub fn gst_buffer_get_video_meta_id(buffer: *mut GstBuffer, id: gint)
     -> *mut GstVideoMeta;
    pub fn gst_buffer_add_video_meta(buffer: *mut GstBuffer,
                                     flags: GstVideoFrameFlags,
                                     format: GstVideoFormat, width: guint,
                                     height: guint) -> *mut GstVideoMeta;
    pub fn gst_buffer_add_video_meta_full(buffer: *mut GstBuffer,
                                          flags: GstVideoFrameFlags,
                                          format: GstVideoFormat,
                                          width: guint, height: guint,
                                          n_planes: guint, offset: *mut gsize,
                                          stride: *mut gint)
     -> *mut GstVideoMeta;
    pub fn gst_video_meta_map(meta: *mut GstVideoMeta, plane: guint,
                              info: *mut GstMapInfo, data: *mut gpointer,
                              stride: *mut gint, flags: GstMapFlags)
     -> gboolean;
    pub fn gst_video_meta_unmap(meta: *mut GstVideoMeta, plane: guint,
                                info: *mut GstMapInfo) -> gboolean;
    pub fn gst_video_crop_meta_api_get_type() -> GType;
    pub fn gst_video_crop_meta_get_info() -> *const GstMetaInfo;
    pub fn gst_video_meta_transform_scale_get_quark() -> GQuark;
    pub fn gst_video_gl_texture_upload_meta_api_get_type() -> GType;
    pub fn gst_video_gl_texture_upload_meta_get_info() -> *const GstMetaInfo;
    pub fn gst_buffer_add_video_gl_texture_upload_meta(buffer: *mut GstBuffer,
                                                       texture_orientation:
                                                           GstVideoGLTextureOrientation,
                                                       n_textures: guint,
                                                       texture_type:
                                                           *mut GstVideoGLTextureType,
                                                       upload:
                                                           GstVideoGLTextureUpload,
                                                       user_data: gpointer,
                                                       user_data_copy:
                                                           GBoxedCopyFunc,
                                                       user_data_free:
                                                           GBoxedFreeFunc)
     -> *mut GstVideoGLTextureUploadMeta;
    pub fn gst_video_gl_texture_upload_meta_upload(meta:
                                                       *mut GstVideoGLTextureUploadMeta,
                                                   texture_id: *mut guint)
     -> gboolean;
    pub fn gst_video_region_of_interest_meta_api_get_type() -> GType;
    pub fn gst_video_region_of_interest_meta_get_info() -> *const GstMetaInfo;
    pub fn gst_buffer_get_video_region_of_interest_meta_id(buffer:
                                                               *mut GstBuffer,
                                                           id: gint)
     -> *mut GstVideoRegionOfInterestMeta;
    pub fn gst_buffer_add_video_region_of_interest_meta(buffer:
                                                            *mut GstBuffer,
                                                        roi_type:
                                                            *const gchar,
                                                        x: guint, y: guint,
                                                        w: guint, h: guint)
     -> *mut GstVideoRegionOfInterestMeta;
    pub fn gst_buffer_add_video_region_of_interest_meta_id(buffer:
                                                               *mut GstBuffer,
                                                           roi_type: GQuark,
                                                           x: guint, y: guint,
                                                           w: guint, h: guint)
     -> *mut GstVideoRegionOfInterestMeta;
    pub fn gst_buffer_pool_config_set_video_alignment(config:
                                                          *mut GstStructure,
                                                      align:
                                                          *mut GstVideoAlignment);
    pub fn gst_buffer_pool_config_get_video_alignment(config:
                                                          *mut GstStructure,
                                                      align:
                                                          *mut GstVideoAlignment)
     -> gboolean;
    pub fn gst_video_buffer_pool_get_type() -> GType;
    pub fn gst_video_buffer_pool_new() -> *mut GstBufferPool;
    pub fn gst_video_sink_get_type() -> GType;
    pub fn gst_video_sink_center_rect(src: GstVideoRectangle,
                                      dst: GstVideoRectangle,
                                      result: *mut GstVideoRectangle,
                                      scaling: gboolean);
    pub fn gst_navigation_get_type() -> GType;
    pub fn gst_navigation_query_get_type(query: *mut GstQuery)
     -> GstNavigationQueryType;
    pub fn gst_navigation_query_new_commands() -> *mut GstQuery;
    pub fn gst_navigation_query_set_commands(query: *mut GstQuery,
                                             n_cmds: gint, ...);
    pub fn gst_navigation_query_set_commandsv(query: *mut GstQuery,
                                              n_cmds: gint,
                                              cmds:
                                                  *mut GstNavigationCommand);
    pub fn gst_navigation_query_parse_commands_length(query: *mut GstQuery,
                                                      n_cmds: *mut guint)
     -> gboolean;
    pub fn gst_navigation_query_parse_commands_nth(query: *mut GstQuery,
                                                   nth: guint,
                                                   cmd:
                                                       *mut GstNavigationCommand)
     -> gboolean;
    pub fn gst_navigation_query_new_angles() -> *mut GstQuery;
    pub fn gst_navigation_query_set_angles(query: *mut GstQuery,
                                           cur_angle: guint, n_angles: guint);
    pub fn gst_navigation_query_parse_angles(query: *mut GstQuery,
                                             cur_angle: *mut guint,
                                             n_angles: *mut guint)
     -> gboolean;
    pub fn gst_navigation_message_get_type(message: *mut GstMessage)
     -> GstNavigationMessageType;
    pub fn gst_navigation_message_new_mouse_over(src: *mut GstObject,
                                                 active: gboolean)
     -> *mut GstMessage;
    pub fn gst_navigation_message_parse_mouse_over(message: *mut GstMessage,
                                                   active: *mut gboolean)
     -> gboolean;
    pub fn gst_navigation_message_new_commands_changed(src: *mut GstObject)
     -> *mut GstMessage;
    pub fn gst_navigation_message_new_angles_changed(src: *mut GstObject,
                                                     cur_angle: guint,
                                                     n_angles: guint)
     -> *mut GstMessage;
    pub fn gst_navigation_message_parse_angles_changed(message:
                                                           *mut GstMessage,
                                                       cur_angle: *mut guint,
                                                       n_angles: *mut guint)
     -> gboolean;
    pub fn gst_navigation_event_get_type(event: *mut GstEvent)
     -> GstNavigationEventType;
    pub fn gst_navigation_event_parse_key_event(event: *mut GstEvent,
                                                key: *mut *const gchar)
     -> gboolean;
    pub fn gst_navigation_event_parse_mouse_button_event(event: *mut GstEvent,
                                                         button: *mut gint,
                                                         x: *mut gdouble,
                                                         y: *mut gdouble)
     -> gboolean;
    pub fn gst_navigation_event_parse_mouse_move_event(event: *mut GstEvent,
                                                       x: *mut gdouble,
                                                       y: *mut gdouble)
     -> gboolean;
    pub fn gst_navigation_event_parse_command(event: *mut GstEvent,
                                              command:
                                                  *mut GstNavigationCommand)
     -> gboolean;
    pub fn gst_navigation_send_event(navigation: *mut GstNavigation,
                                     structure: *mut GstStructure);
    pub fn gst_navigation_send_key_event(navigation: *mut GstNavigation,
                                         event: *const ::libc::c_char,
                                         key: *const ::libc::c_char);
    pub fn gst_navigation_send_mouse_event(navigation: *mut GstNavigation,
                                           event: *const ::libc::c_char,
                                           button: ::libc::c_int,
                                           x: ::libc::c_double,
                                           y: ::libc::c_double);
    pub fn gst_navigation_send_command(navigation: *mut GstNavigation,
                                       command: GstNavigationCommand);
    pub fn gst_video_blend_scale_linear_RGBA(src: *mut GstVideoInfo,
                                             src_buffer: *mut GstBuffer,
                                             dest_height: gint,
                                             dest_width: gint,
                                             dest: *mut GstVideoInfo,
                                             dest_buffer:
                                                 *mut *mut GstBuffer);
    pub fn gst_video_blend(dest: *mut GstVideoFrame, src: *mut GstVideoFrame,
                           x: gint, y: gint, global_alpha: gfloat)
     -> gboolean;
    pub fn gst_video_event_new_still_frame(in_still: gboolean)
     -> *mut GstEvent;
    pub fn gst_video_event_parse_still_frame(event: *mut GstEvent,
                                             in_still: *mut gboolean)
     -> gboolean;
    pub fn gst_video_event_new_downstream_force_key_unit(timestamp:
                                                             GstClockTime,
                                                         stream_time:
                                                             GstClockTime,
                                                         running_time:
                                                             GstClockTime,
                                                         all_headers:
                                                             gboolean,
                                                         count: guint)
     -> *mut GstEvent;
    pub fn gst_video_event_parse_downstream_force_key_unit(event:
                                                               *mut GstEvent,
                                                           timestamp:
                                                               *mut GstClockTime,
                                                           stream_time:
                                                               *mut GstClockTime,
                                                           running_time:
                                                               *mut GstClockTime,
                                                           all_headers:
                                                               *mut gboolean,
                                                           count: *mut guint)
     -> gboolean;
    pub fn gst_video_event_new_upstream_force_key_unit(running_time:
                                                           GstClockTime,
                                                       all_headers: gboolean,
                                                       count: guint)
     -> *mut GstEvent;
    pub fn gst_video_event_parse_upstream_force_key_unit(event: *mut GstEvent,
                                                         running_time:
                                                             *mut GstClockTime,
                                                         all_headers:
                                                             *mut gboolean,
                                                         count: *mut guint)
     -> gboolean;
    pub fn gst_video_event_is_force_key_unit(event: *mut GstEvent)
     -> gboolean;
    pub fn gst_video_orientation_get_type() -> GType;
    pub fn gst_video_orientation_get_hflip(video_orientation:
                                               *mut GstVideoOrientation,
                                           flip: *mut gboolean) -> gboolean;
    pub fn gst_video_orientation_get_vflip(video_orientation:
                                               *mut GstVideoOrientation,
                                           flip: *mut gboolean) -> gboolean;
    pub fn gst_video_orientation_get_hcenter(video_orientation:
                                                 *mut GstVideoOrientation,
                                             center: *mut gint) -> gboolean;
    pub fn gst_video_orientation_get_vcenter(video_orientation:
                                                 *mut GstVideoOrientation,
                                             center: *mut gint) -> gboolean;
    pub fn gst_video_orientation_set_hflip(video_orientation:
                                               *mut GstVideoOrientation,
                                           flip: gboolean) -> gboolean;
    pub fn gst_video_orientation_set_vflip(video_orientation:
                                               *mut GstVideoOrientation,
                                           flip: gboolean) -> gboolean;
    pub fn gst_video_orientation_set_hcenter(video_orientation:
                                                 *mut GstVideoOrientation,
                                             center: gint) -> gboolean;
    pub fn gst_video_orientation_set_vcenter(video_orientation:
                                                 *mut GstVideoOrientation,
                                             center: gint) -> gboolean;
    pub fn gst_video_overlay_rectangle_get_type() -> GType;
    pub fn gst_video_overlay_rectangle_new_raw(pixels: *mut GstBuffer,
                                               render_x: gint, render_y: gint,
                                               render_width: guint,
                                               render_height: guint,
                                               flags:
                                                   GstVideoOverlayFormatFlags)
     -> *mut GstVideoOverlayRectangle;
    pub fn gst_video_overlay_rectangle_copy(rectangle:
                                                *mut GstVideoOverlayRectangle)
     -> *mut GstVideoOverlayRectangle;
    pub fn gst_video_overlay_rectangle_get_seqnum(rectangle:
                                                      *mut GstVideoOverlayRectangle)
     -> guint;
    pub fn gst_video_overlay_rectangle_set_render_rectangle(rectangle:
                                                                *mut GstVideoOverlayRectangle,
                                                            render_x: gint,
                                                            render_y: gint,
                                                            render_width:
                                                                guint,
                                                            render_height:
                                                                guint);
    pub fn gst_video_overlay_rectangle_get_render_rectangle(rectangle:
                                                                *mut GstVideoOverlayRectangle,
                                                            render_x:
                                                                *mut gint,
                                                            render_y:
                                                                *mut gint,
                                                            render_width:
                                                                *mut guint,
                                                            render_height:
                                                                *mut guint)
     -> gboolean;
    pub fn gst_video_overlay_rectangle_get_pixels_raw(rectangle:
                                                          *mut GstVideoOverlayRectangle,
                                                      flags:
                                                          GstVideoOverlayFormatFlags)
     -> *mut GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_argb(rectangle:
                                                           *mut GstVideoOverlayRectangle,
                                                       flags:
                                                           GstVideoOverlayFormatFlags)
     -> *mut GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_ayuv(rectangle:
                                                           *mut GstVideoOverlayRectangle,
                                                       flags:
                                                           GstVideoOverlayFormatFlags)
     -> *mut GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_raw(rectangle:
                                                                   *mut GstVideoOverlayRectangle,
                                                               flags:
                                                                   GstVideoOverlayFormatFlags)
     -> *mut GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_argb(rectangle:
                                                                    *mut GstVideoOverlayRectangle,
                                                                flags:
                                                                    GstVideoOverlayFormatFlags)
     -> *mut GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_ayuv(rectangle:
                                                                    *mut GstVideoOverlayRectangle,
                                                                flags:
                                                                    GstVideoOverlayFormatFlags)
     -> *mut GstBuffer;
    pub fn gst_video_overlay_rectangle_get_flags(rectangle:
                                                     *mut GstVideoOverlayRectangle)
     -> GstVideoOverlayFormatFlags;
    pub fn gst_video_overlay_rectangle_get_global_alpha(rectangle:
                                                            *mut GstVideoOverlayRectangle)
     -> gfloat;
    pub fn gst_video_overlay_rectangle_set_global_alpha(rectangle:
                                                            *mut GstVideoOverlayRectangle,
                                                        global_alpha: gfloat);
    pub fn gst_video_overlay_composition_get_type() -> GType;
    pub fn gst_video_overlay_composition_copy(comp:
                                                  *mut GstVideoOverlayComposition)
     -> *mut GstVideoOverlayComposition;
    pub fn gst_video_overlay_composition_make_writable(comp:
                                                           *mut GstVideoOverlayComposition)
     -> *mut GstVideoOverlayComposition;
    pub fn gst_video_overlay_composition_new(rectangle:
                                                 *mut GstVideoOverlayRectangle)
     -> *mut GstVideoOverlayComposition;
    pub fn gst_video_overlay_composition_add_rectangle(comp:
                                                           *mut GstVideoOverlayComposition,
                                                       rectangle:
                                                           *mut GstVideoOverlayRectangle);
    pub fn gst_video_overlay_composition_n_rectangles(comp:
                                                          *mut GstVideoOverlayComposition)
     -> guint;
    pub fn gst_video_overlay_composition_get_rectangle(comp:
                                                           *mut GstVideoOverlayComposition,
                                                       n: guint)
     -> *mut GstVideoOverlayRectangle;
    pub fn gst_video_overlay_composition_get_seqnum(comp:
                                                        *mut GstVideoOverlayComposition)
     -> guint;
    pub fn gst_video_overlay_composition_blend(comp:
                                                   *mut GstVideoOverlayComposition,
                                               video_buf: *mut GstVideoFrame)
     -> gboolean;
    pub fn gst_video_overlay_composition_meta_api_get_type() -> GType;
    pub fn gst_video_overlay_composition_meta_get_info()
     -> *const GstMetaInfo;
    pub fn gst_buffer_add_video_overlay_composition_meta(buf: *mut GstBuffer,
                                                         comp:
                                                             *mut GstVideoOverlayComposition)
     -> *mut GstVideoOverlayCompositionMeta;
    pub fn gst_video_overlay_get_type() -> GType;
    pub fn gst_video_overlay_set_render_rectangle(overlay:
                                                      *mut GstVideoOverlay,
                                                  x: gint, y: gint,
                                                  width: gint, height: gint)
     -> gboolean;
    pub fn gst_video_overlay_expose(overlay: *mut GstVideoOverlay);
    pub fn gst_video_overlay_handle_events(overlay: *mut GstVideoOverlay,
                                           handle_events: gboolean);
    pub fn gst_video_overlay_set_window_handle(overlay: *mut GstVideoOverlay,
                                               handle: guintptr);
    pub fn gst_video_overlay_got_window_handle(overlay: *mut GstVideoOverlay,
                                               handle: guintptr);
    pub fn gst_video_overlay_prepare_window_handle(overlay:
                                                       *mut GstVideoOverlay);
    pub fn gst_is_video_overlay_prepare_window_handle_message(msg:
                                                                  *mut GstMessage)
     -> gboolean;
}
